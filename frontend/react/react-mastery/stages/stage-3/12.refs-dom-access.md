# üìÖ NG√ÄY 12: Refs & DOM Access

## üéØ M·ª•c ti√™u h√¥m nay

- useRef: DOM references & mutable values
- forwardRef pattern
- useImperativeHandle
- Callback refs
- Ref vs State
- Common patterns v√† use cases

---

## üìö PH·∫¶N 1: L√ù THUY·∫æT (30-45 ph√∫t)

### **1.1. useRef - Basics**

useRef t·∫°o m·ªôt mutable object persist qua renders m√† KH√îNG trigger re-render khi thay ƒë·ªïi.

#### **Syntax**

```jsx
const ref = useRef(initialValue);

// ref l√† object: { current: initialValue }
// C√≥ th·ªÉ read/write ref.current
```

#### **Two Main Use Cases:**

**1. DOM References**

```jsx
import { useRef } from "react";

function TextInput() {
  const inputRef = useRef(null);

  const focusInput = () => {
    // Access DOM node
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
```

**2. Mutable Values (kh√¥ng trigger re-render)**

```jsx
function Timer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null);

  const startTimer = () => {
    intervalRef.current = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    clearInterval(intervalRef.current);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

---

### **1.2. useRef vs useState**

#### **Key Differences:**

```jsx
// useState - Triggers re-render
function ComponentWithState() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1); // ‚úÖ Re-render happens
  };

  return <div>Count: {count}</div>; // ‚úÖ UI updates
}

// useRef - NO re-render
function ComponentWithRef() {
  const countRef = useRef(0);

  const increment = () => {
    countRef.current += 1; // ‚ùå NO re-render
    console.log(countRef.current); // Log updates
  };

  return <div>Count: {countRef.current}</div>; // ‚ùå UI kh√¥ng update
}
```

#### **When to Use What:**

**Use useState khi:**

- ‚úÖ Value c·∫ßn hi·ªÉn th·ªã trong UI
- ‚úÖ Changes c·∫ßn trigger re-render
- ‚úÖ Value l√† part of component state

**Use useRef khi:**

- ‚úÖ Access DOM elements
- ‚úÖ Store values kh√¥ng affect UI (timers, previous values)
- ‚úÖ C·∫ßn mutable value kh√¥ng trigger re-render
- ‚úÖ Store instance values (WebSocket connections, etc.)

---

### **1.3. DOM Access Patterns**

#### **Pattern 1: Focus Management**

```jsx
function AutoFocusInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    // Auto-focus khi component mount
    inputRef.current?.focus();
  }, []);

  return <input ref={inputRef} placeholder="Auto-focused" />;
}

// Focus conditionally
function ConditionalFocus({ shouldFocus }) {
  const inputRef = useRef(null);

  useEffect(() => {
    if (shouldFocus) {
      inputRef.current?.focus();
    }
  }, [shouldFocus]);

  return <input ref={inputRef} />;
}
```

#### **Pattern 2: Scroll Management**

```jsx
function ScrollToBottom({ messages }) {
  const messagesEndRef = useRef(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  return (
    <div className="messages">
      {messages.map((msg) => (
        <div key={msg.id}>{msg.text}</div>
      ))}
      <div ref={messagesEndRef} />
    </div>
  );
}

// Scroll to top
function ScrollToTop() {
  const topRef = useRef(null);

  const handleScrollToTop = () => {
    topRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  return (
    <div>
      <div ref={topRef} />
      {/* Long content */}
      <button onClick={handleScrollToTop}>Back to Top ‚Üë</button>
    </div>
  );
}
```

#### **Pattern 3: Measuring Elements**

```jsx
function MeasureElement() {
  const elementRef = useRef(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

  useLayoutEffect(() => {
    if (elementRef.current) {
      const { width, height } = elementRef.current.getBoundingClientRect();
      setDimensions({ width, height });
    }
  }, []); // Measure on mount

  return (
    <div>
      <div ref={elementRef} className="measured-element">
        Content to measure
      </div>
      <p>Width: {dimensions.width}px</p>
      <p>Height: {dimensions.height}px</p>
    </div>
  );
}

// Responsive measurements
function ResponsiveComponent() {
  const containerRef = useRef(null);
  const [width, setWidth] = useState(0);

  useEffect(() => {
    const handleResize = () => {
      if (containerRef.current) {
        setWidth(containerRef.current.offsetWidth);
      }
    };

    handleResize(); // Initial measure
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return (
    <div ref={containerRef}>
      <p>Container width: {width}px</p>
      {width < 600 ? <MobileView /> : <DesktopView />}
    </div>
  );
}
```

#### **Pattern 4: Video/Audio Control**

```jsx
function VideoPlayer({ src }) {
  const videoRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);

  const togglePlay = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const handleSeek = (time) => {
    if (videoRef.current) {
      videoRef.current.currentTime = time;
    }
  };

  const handleVolumeChange = (volume) => {
    if (videoRef.current) {
      videoRef.current.volume = volume;
    }
  };

  return (
    <div className="video-player">
      <video ref={videoRef} src={src} />

      <div className="controls">
        <button onClick={togglePlay}>{isPlaying ? "‚è∏ Pause" : "‚ñ∂ Play"}</button>
        <button onClick={() => handleSeek(0)}>‚èÆ Restart</button>
        <input
          type="range"
          min="0"
          max="1"
          step="0.1"
          defaultValue="1"
          onChange={(e) => handleVolumeChange(e.target.value)}
        />
      </div>
    </div>
  );
}
```

---

### **1.4. Mutable Values Pattern**

#### **Pattern 1: Previous Values**

```jsx
function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

// Usage
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

#### **Pattern 2: Timer/Interval IDs**

```jsx
function Stopwatch() {
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);

  useEffect(() => {
    if (isRunning) {
      intervalRef.current = setInterval(() => {
        setTime((t) => t + 10);
      }, 10);
    } else {
      clearInterval(intervalRef.current);
    }

    return () => clearInterval(intervalRef.current);
  }, [isRunning]);

  const reset = () => {
    setTime(0);
    setIsRunning(false);
  };

  const formatTime = (ms) => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const milliseconds = ms % 1000;

    return `${minutes.toString().padStart(2, "0")}:${(seconds % 60)
      .toString()
      .padStart(2, "0")}.${Math.floor(milliseconds / 10)
      .toString()
      .padStart(2, "0")}`;
  };

  return (
    <div className="stopwatch">
      <h2>{formatTime(time)}</h2>
      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? "‚è∏ Pause" : "‚ñ∂ Start"}
      </button>
      <button onClick={reset}>üîÑ Reset</button>
    </div>
  );
}
```

#### **Pattern 3: Avoiding Stale Closures**

```jsx
// ‚ùå Problem: Stale closure
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState("");

  useEffect(() => {
    const connection = createConnection(roomId);

    connection.on("message", (msg) => {
      // ‚ùå message c√≥ th·ªÉ stale!
      console.log("Current message:", message);
    });

    return () => connection.disconnect();
  }, [roomId]); // message kh√¥ng trong deps
}

// ‚úÖ Solution: Use ref
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState("");
  const messageRef = useRef(message);

  useEffect(() => {
    messageRef.current = message;
  }, [message]);

  useEffect(() => {
    const connection = createConnection(roomId);

    connection.on("message", (msg) => {
      // ‚úÖ messageRef.current lu√¥n up-to-date
      console.log("Current message:", messageRef.current);
    });

    return () => connection.disconnect();
  }, [roomId]);
}
```

#### **Pattern 4: Instance Variables**

```jsx
function WebSocketComponent() {
  const wsRef = useRef(null);
  const [messages, setMessages] = useState([]);
  const [status, setStatus] = useState("disconnected");

  useEffect(() => {
    // Create WebSocket connection
    wsRef.current = new WebSocket("ws://localhost:8080");

    wsRef.current.onopen = () => {
      setStatus("connected");
    };

    wsRef.current.onmessage = (event) => {
      setMessages((prev) => [...prev, event.data]);
    };

    wsRef.current.onclose = () => {
      setStatus("disconnected");
    };

    // Cleanup
    return () => {
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []);

  const sendMessage = (msg) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(msg);
    }
  };

  return (
    <div>
      <p>Status: {status}</p>
      <button onClick={() => sendMessage("Hello")}>Send Message</button>
      <ul>
        {messages.map((msg, i) => (
          <li key={i}>{msg}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

### **1.5. forwardRef Pattern**

forwardRef cho ph√©p component pass ref xu·ªëng child component.

#### **Problem: Cannot Pass Ref Directly**

```jsx
// ‚ùå Kh√¥ng ho·∫°t ƒë·ªông
function MyInput({ ref }) {
  return <input ref={ref} />; // Warning!
}

function Parent() {
  const inputRef = useRef(null);
  return <MyInput ref={inputRef} />; // ‚ùå ref kh√¥ng ph·∫£i prop th√¥ng th∆∞·ªùng
}
```

#### **Solution: forwardRef**

```jsx
import { forwardRef } from "react";

// ‚úÖ Wrap v·ªõi forwardRef
const MyInput = forwardRef(function MyInput(props, ref) {
  return <input ref={ref} {...props} />;
});

function Parent() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current?.focus();
  };

  return (
    <div>
      <MyInput ref={inputRef} placeholder="Type here..." />
      <button onClick={focusInput}>Focus</button>
    </div>
  );
}
```

#### **forwardRef v·ªõi Additional Props**

```jsx
const FancyInput = forwardRef(function FancyInput(
  { label, error, ...props },
  ref
) {
  return (
    <div className="fancy-input">
      {label && <label>{label}</label>}
      <input ref={ref} {...props} />
      {error && <span className="error">{error}</span>}
    </div>
  );
});

// Usage
function Form() {
  const emailRef = useRef(null);

  return (
    <form>
      <FancyInput
        ref={emailRef}
        label="Email"
        type="email"
        error="Invalid email"
      />
    </form>
  );
}
```

#### **forwardRef v·ªõi TypeScript**

```typescript
import { forwardRef, InputHTMLAttributes } from "react";

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
}

const FancyInput = forwardRef<HTMLInputElement, InputProps>(function FancyInput(
  { label, error, ...props },
  ref
) {
  return (
    <div>
      {label && <label>{label}</label>}
      <input ref={ref} {...props} />
      {error && <span className="error">{error}</span>}
    </div>
  );
});
```

---

### **1.6. useImperativeHandle**

useImperativeHandle customize gi√° tr·ªã exposed qua ref.

#### **Problem: Expose Entire DOM Node**

```jsx
const VideoPlayer = forwardRef(function VideoPlayer(props, ref) {
  return <video ref={ref} {...props} />;
  // ‚ùå Expose to√†n b·ªô video DOM node - c√≥ th·ªÉ l√†m nhi·ªÅu th·ª© kh√¥ng mong mu·ªën
});

// Parent c√≥ th·ªÉ:
// videoRef.current.remove() ‚ùå
// videoRef.current.style.display = 'none' ‚ùå
```

#### **Solution: useImperativeHandle**

```jsx
import { useRef, forwardRef, useImperativeHandle } from "react";

const VideoPlayer = forwardRef(function VideoPlayer({ src }, ref) {
  const videoRef = useRef(null);

  // ‚úÖ Ch·ªâ expose specific methods
  useImperativeHandle(
    ref,
    () => ({
      play: () => {
        videoRef.current?.play();
      },
      pause: () => {
        videoRef.current?.pause();
      },
      seek: (time) => {
        if (videoRef.current) {
          videoRef.current.currentTime = time;
        }
      },
      setVolume: (volume) => {
        if (videoRef.current) {
          videoRef.current.volume = volume;
        }
      },
    }),
    []
  ); // Dependencies

  return <video ref={videoRef} src={src} />;
});

// Usage
function App() {
  const playerRef = useRef(null);

  return (
    <div>
      <VideoPlayer ref={playerRef} src="/video.mp4" />

      <button onClick={() => playerRef.current?.play()}>Play</button>
      <button onClick={() => playerRef.current?.pause()}>Pause</button>
      <button onClick={() => playerRef.current?.seek(0)}>Restart</button>

      {/* ‚ùå Cannot do: playerRef.current.remove() */}
    </div>
  );
}
```

#### **Complex Example: Form Component**

```jsx
const Form = forwardRef(function Form({ children, onSubmit }, ref) {
  const formRef = useRef(null);
  const fieldsRef = useRef({});

  useImperativeHandle(
    ref,
    () => ({
      // Submit form programmatically
      submit: () => {
        formRef.current?.requestSubmit();
      },

      // Reset form
      reset: () => {
        formRef.current?.reset();
      },

      // Get form values
      getValues: () => {
        const formData = new FormData(formRef.current);
        return Object.fromEntries(formData);
      },

      // Set values
      setValues: (values) => {
        Object.entries(values).forEach(([name, value]) => {
          const field = formRef.current?.elements[name];
          if (field) field.value = value;
        });
      },

      // Focus first error
      focusError: () => {
        const firstError = formRef.current?.querySelector(
          '[aria-invalid="true"]'
        );
        firstError?.focus();
      },
    }),
    []
  );

  return (
    <form ref={formRef} onSubmit={onSubmit}>
      {children}
    </form>
  );
});

// Usage
function RegistrationPage() {
  const formRef = useRef(null);

  const handleExternalSubmit = () => {
    formRef.current?.submit();
  };

  const handleReset = () => {
    formRef.current?.reset();
  };

  const handlePrefill = () => {
    formRef.current?.setValues({
      username: "john_doe",
      email: "john@example.com",
    });
  };

  return (
    <div>
      <Form ref={formRef} onSubmit={(e) => e.preventDefault()}>
        <input name="username" required />
        <input name="email" type="email" required />
        <button type="submit">Submit</button>
      </Form>

      <button onClick={handleExternalSubmit}>External Submit</button>
      <button onClick={handleReset}>Reset</button>
      <button onClick={handlePrefill}>Prefill</button>
    </div>
  );
}
```

---

### **1.7. Callback Refs**

Alternative to useRef - function ƒë∆∞·ª£c g·ªçi v·ªõi DOM node.

#### **Basic Callback Ref**

```jsx
function Component() {
  const [height, setHeight] = useState(0);

  const measureRef = (node) => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  };

  return (
    <div>
      <div ref={measureRef}>Content to measure</div>
      <p>Height: {height}px</p>
    </div>
  );
}
```

#### **Dynamic Refs (Multiple Elements)**

```jsx
function ItemList({ items }) {
  const itemRefs = useRef({});

  const scrollToItem = (id) => {
    itemRefs.current[id]?.scrollIntoView({ behavior: "smooth" });
  };

  return (
    <div>
      {items.map((item) => (
        <div
          key={item.id}
          ref={(node) => {
            if (node) {
              itemRefs.current[item.id] = node;
            } else {
              delete itemRefs.current[item.id];
            }
          }}
        >
          {item.text}
          <button onClick={() => scrollToItem(item.id)}>Scroll here</button>
        </div>
      ))}
    </div>
  );
}
```

#### **Callback Ref v·ªõi Intersection Observer**

```jsx
function LazyImage({ src, alt }) {
  const [isVisible, setIsVisible] = useState(false);
  const [imageSrc, setImageSrc] = useState("placeholder.jpg");

  const observerRef = useCallback(
    (node) => {
      if (node === null) return;

      const observer = new IntersectionObserver(
        ([entry]) => {
          if (entry.isIntersecting) {
            setIsVisible(true);
            setImageSrc(src);
            observer.disconnect();
          }
        },
        { threshold: 0.1 }
      );

      observer.observe(node);

      return () => observer.disconnect();
    },
    [src]
  );

  return (
    <img
      ref={observerRef}
      src={imageSrc}
      alt={alt}
      className={isVisible ? "loaded" : "loading"}
    />
  );
}
```

---

### **1.8. Common Patterns & Use Cases**

#### **Pattern 1: Auto-resize Textarea**

```jsx
function AutoResizeTextarea({ value, onChange }) {
  const textareaRef = useRef(null);

  useLayoutEffect(() => {
    if (textareaRef.current) {
      // Reset height
      textareaRef.current.style.height = "0px";
      // Set to scrollHeight
      const scrollHeight = textareaRef.current.scrollHeight;
      textareaRef.current.style.height = scrollHeight + "px";
    }
  }, [value]);

  return (
    <textarea
      ref={textareaRef}
      value={value}
      onChange={onChange}
      style={{ resize: "none", overflow: "hidden" }}
    />
  );
}
```

#### **Pattern 2: Click Outside**

```jsx
function useClickOutside(handler) {
  const ref = useRef(null);

  useEffect(() => {
    const handleClick = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        handler();
      }
    };

    document.addEventListener("mousedown", handleClick);
    return () => document.removeEventListener("mousedown", handleClick);
  }, [handler]);

  return ref;
}

// Usage
function Modal({ onClose }) {
  const modalRef = useClickOutside(onClose);

  return (
    <div className="modal-backdrop">
      <div ref={modalRef} className="modal">
        <p>Click outside to close</p>
      </div>
    </div>
  );
}
```

#### **Pattern 3: Drag and Drop**

```jsx
function DraggableBox() {
  const boxRef = useRef(null);
  const positionRef = useRef({ x: 0, y: 0 });
  const dragStartRef = useRef({ x: 0, y: 0 });

  useEffect(() => {
    const box = boxRef.current;
    if (!box) return;

    const handleMouseDown = (e) => {
      dragStartRef.current = {
        x: e.clientX - positionRef.current.x,
        y: e.clientY - positionRef.current.y,
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    };

    const handleMouseMove = (e) => {
      const x = e.clientX - dragStartRef.current.x;
      const y = e.clientY - dragStartRef.current.y;

      positionRef.current = { x, y };
      box.style.transform = `translate(${x}px, ${y}px)`;
    };

    const handleMouseUp = () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };

    box.addEventListener("mousedown", handleMouseDown);

    return () => {
      box.removeEventListener("mousedown", handleMouseDown);
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, []);

  return (
    <div
      ref={boxRef}
      style={{
        width: 100,
        height: 100,
        background: "blue",
        cursor: "move",
        position: "absolute",
      }}
    >
      Drag me
    </div>
  );
}
```

#### **Pattern 4: Canvas Drawing**

```jsx
function DrawingCanvas() {
  const canvasRef = useRef(null);
  const isDrawingRef = useRef(false);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;

    const startDrawing = (e) => {
      isDrawingRef.current = true;
      ctx.beginPath();
      ctx.moveTo(e.offsetX, e.offsetY);
    };

    const draw = (e) => {
      if (!isDrawingRef.current) return;
      ctx.lineTo(e.offsetX, e.offsetY);
      ctx.stroke();
    };

    const stopDrawing = () => {
      isDrawingRef.current = false;
    };

    canvas.addEventListener("mousedown", startDrawing);
    canvas.addEventListener("mousemove", draw);
    canvas.addEventListener("mouseup", stopDrawing);
    canvas.addEventListener("mouseleave", stopDrawing);

    return () => {
      canvas.removeEventListener("mousedown", startDrawing);
      canvas.removeEventListener("mousemove", draw);
      canvas.removeEventListener("mouseup", stopDrawing);
      canvas.removeEventListener("mouseleave", stopDrawing);
    };
  }, []);

  const clearCanvas = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  };

  return (
    <div>
      <canvas
        ref={canvasRef}
        width={800}
        height={600}
        style={{ border: "1px solid black" }}
      />
      <button onClick={clearCanvas}>Clear</button>
    </div>
  );
}
```

---

## üíª PH·∫¶N 2: CODE DEMO (30-45 ph√∫t)

### **Demo 1: Custom Video Player**

```jsx
const VideoPlayer = forwardRef(function VideoPlayer({ src }, ref) {
  const videoRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [isMuted, setIsMuted] = useState(false);
  const [playbackRate, setPlaybackRate] = useState(1);

  useImperativeHandle(
    ref,
    () => ({
      play: () => videoRef.current?.play(),
      pause: () => videoRef.current?.pause(),
      seek: (time) => {
        if (videoRef.current) {
          videoRef.current.currentTime = time;
        }
      },
      setVolume: (vol) => {
        if (videoRef.current) {
          videoRef.current.volume = vol;
          setVolume(vol);
        }
      },
      toggleFullscreen: () => {
        if (videoRef.current) {
          if (document.fullscreenElement) {
            document.exitFullscreen();
          } else {
            videoRef.current.requestFullscreen();
          }
        }
      },
    }),
    []
  );

  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleTimeUpdate = () => setCurrentTime(video.currentTime);
    const handleDurationChange = () => setDuration(video.duration);
    const handlePlay = () => setIsPlaying(true);
    const handlePause = () => setIsPlaying(false);

    video.addEventListener("timeupdate", handleTimeUpdate);
    video.addEventListener("durationchange", handleDurationChange);
    video.addEventListener("play", handlePlay);
    video.addEventListener("pause", handlePause);

    return () => {
      video.removeEventListener("timeupdate", handleTimeUpdate);
      video.removeEventListener("durationchange", handleDurationChange);
      video.removeEventListener("play", handlePlay);
      video.removeEventListener("pause", handlePause);
    };
  }, []);

  const togglePlay = () => {
    if (isPlaying) {
      videoRef.current?.pause();
    } else {
      videoRef.current?.play();
    }
  };

  const handleSeek = (e) => {
    const time = parseFloat(e.target.value);
    if (videoRef.current) {
      videoRef.current.currentTime = time;
    }
  };

  const handleVolumeChange = (e) => {
    const vol = parseFloat(e.target.value);
    setVolume(vol);
    if (videoRef.current) {
      videoRef.current.volume = vol;
    }
  };

  const toggleMute = () => {
    if (videoRef.current) {
      videoRef.current.muted = !isMuted;
      setIsMuted(!isMuted);
    }
  };

  const changePlaybackRate = (rate) => {
    setPlaybackRate(rate);
    if (videoRef.current) {
      videoRef.current.playbackRate = rate;
    }
  };

  const formatTime = (time) => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, "0")}`;
  };

  return (
    <div className="video-player">
      <video
        ref={videoRef}
        src={src}
        onClick={togglePlay}
        style={{ width: "100%", cursor: "pointer" }}
      />

      <div className="controls">
        {/* Play/Pause */}
        <button onClick={togglePlay}>{isPlaying ? "‚è∏" : "‚ñ∂"}</button>

        {/* Time Display */}
        <span className="time">
          {formatTime(currentTime)} / {formatTime(duration)}
        </span>

        {/* Progress Bar */}
        <input
          type="range"
          min="0"
          max={duration || 0}
          value={currentTime}
          onChange={handleSeek}
          style={{ flex: 1 }}
        />

        {/* Volume */}
        <button onClick={toggleMute}>
          {isMuted ? "üîá" : volume > 0.5 ? "üîä" : "üîâ"}
        </button>
        <input
          type="range"
          min="0"
          max="1"
          step="0.1"
          value={volume}
          onChange={handleVolumeChange}
          style={{ width: 80 }}
        />

        {/* Playback Speed */}
        <select
          value={playbackRate}
          onChange={(e) => changePlaybackRate(parseFloat(e.target.value))}
        >
          <option value="0.5">0.5x</option>
          <option value="1">1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
        </select>

        {/* Fullscreen */}
        <button
          onClick={() => {
            if (videoRef.current) {
              if (document.fullscreenElement) {
                document.exitFullscreen();
              } else {
                videoRef.current.requestFullscreen();
              }
            }
          }}
        >
          ‚õ∂
        </button>
      </div>
    </div>
  );
});

// Usage
function App() {
  const playerRef = useRef(null);

  return (
    <div>
      <h1>Custom Video Player</h1>
      <VideoPlayer
        ref={playerRef}
        src="https://www.w3schools.com/html/mov_bbb.mp4"
      />

      <div className="external-controls">
        <button onClick={() => playerRef.current?.play()}>Play</button>
        <button onClick={() => playerRef.current?.pause()}>Pause</button>
        <button onClick={() => playerRef.current?.seek(0)}>Restart</button>
        <button onClick={() => playerRef.current?.setVolume(0.5)}>
          50% Volume
        </button>
        <button onClick={() => playerRef.current?.toggleFullscreen()}>
          Fullscreen
        </button>
      </div>
    </div>
  );
}
```

### **Demo 2: Form v·ªõi Ref API**

```jsx
const FormField = forwardRef(function FormField(
  { label, name, type = "text", error, ...props },
  ref
) {
  return (
    <div className="form-field">
      <label htmlFor={name}>{label}</label>
      <input
        ref={ref}
        id={name}
        name={name}
        type={type}
        aria-invalid={!!error}
        {...props}
      />
      {error && <span className="error">{error}</span>}
    </div>
  );
});

const Form = forwardRef(function Form({ children, onSubmit }, ref) {
  const formRef = useRef(null);
  const fieldsRef = useRef({});

  useImperativeHandle(
    ref,
    () => ({
      submit: () => {
        formRef.current?.requestSubmit();
      },

      reset: () => {
        formRef.current?.reset();
        Object.values(fieldsRef.current).forEach((field) => {
          if (field) field.value = "";
        });
      },

      getValues: () => {
        const formData = new FormData(formRef.current);
        return Object.fromEntries(formData);
      },

      setValues: (values) => {
        Object.entries(values).forEach(([name, value]) => {
          if (fieldsRef.current[name]) {
            fieldsRef.current[name].value = value;
          }
        });
      },

      focus: (fieldName) => {
        fieldsRef.current[fieldName]?.focus();
      },

      validate: () => {
        const errors = {};
        const values = Object.fromEntries(new FormData(formRef.current));

        // Simple validation
        if (!values.email?.includes("@")) {
          errors.email = "Email kh√¥ng h·ª£p l·ªá";
        }
        if (values.password?.length < 6) {
          errors.password = "M·∫≠t kh·∫©u ph·∫£i ‚â• 6 k√Ω t·ª±";
        }

        return {
          isValid: Object.keys(errors).length === 0,
          errors,
        };
      },
    }),
    []
  );

  const registerField = (name) => (node) => {
    if (node) {
      fieldsRef.current[name] = node;
    } else {
      delete fieldsRef.current[name];
    }
  };

  return (
    <form ref={formRef} onSubmit={onSubmit}>
      {children}
    </form>
  );
});

// Usage
function RegistrationForm() {
  const formRef = useRef(null);
  const [errors, setErrors] = useState({});

  const handleSubmit = (e) => {
    e.preventDefault();

    const validation = formRef.current?.validate();

    if (validation?.isValid) {
      const values = formRef.current?.getValues();
      console.log("Submitting:", values);
      alert("Form submitted!");
    } else {
      setErrors(validation?.errors || {});
      // Focus first error field
      const firstErrorField = Object.keys(validation?.errors || {})[0];
      formRef.current?.focus(firstErrorField);
    }
  };

  const handleReset = () => {
    formRef.current?.reset();
    setErrors({});
  };

  const handlePrefill = () => {
    formRef.current?.setValues({
      username: "john_doe",
      email: "john@example.com",
      password: "password123",
    });
  };

  return (
    <div className="registration-form">
      <h2>ƒêƒÉng k√Ω t√†i kho·∫£n</h2>

      <Form ref={formRef} onSubmit={handleSubmit}>
        <FormField
          ref={(node) => {
            if (formRef.current) {
              formRef.current.fieldsRef.current.username = node;
            }
          }}
          name="username"
          label="Username"
          required
          error={errors.username}
        />

        <FormField
          ref={(node) => {
            if (formRef.current) {
              formRef.current.fieldsRef.current.email = node;
            }
          }}
          name="email"
          label="Email"
          type="email"
          required
          error={errors.email}
        />

        <FormField
          ref={(node) => {
            if (formRef.current) {
              formRef.current.fieldsRef.current.password = node;
            }
          }}
          name="password"
          label="M·∫≠t kh·∫©u"
          type="password"
          required
          error={errors.password}
        />

        <div className="form-actions">
          <button type="submit">ƒêƒÉng k√Ω</button>
          <button type="button" onClick={handleReset}>
            Reset
          </button>
          <button type="button" onClick={handlePrefill}>
            Prefill
          </button>
        </div>
      </Form>
    </div>
  );
}
```

---

## üî® PH·∫¶N 3: TH·ª∞C H√ÄNH (60-90 ph√∫t)

### **Exercise 1: Image Gallery v·ªõi Keyboard Navigation**

```jsx
// TODO: Implement image gallery v·ªõi ref API

function ImageGallery({ images }) {
  // TODO: State v√† refs
  // - currentIndex: current image
  // - imageRefs: refs cho t·∫•t c·∫£ images
  // - containerRef: ref cho container

  // TODO: useRef ƒë·ªÉ track refs
  const imageRefs = useRef([]);
  const containerRef = useRef(null);

  // TODO: Keyboard navigation
  // - Arrow Left: previous image
  // - Arrow Right: next image
  // - Home: first image
  // - End: last image
  // - Enter: toggle fullscreen
  // - Escape: exit fullscreen

  // TODO: Auto-scroll to current image

  // TODO: Features
  // - Thumbnail navigation
  // - Zoom in/out
  // - Rotate
  // - Download current image
  // - Slideshow mode

  return <div className="image-gallery">{/* Your code */}</div>;
}

// TODO: Test v·ªõi 50+ images
const demoImages = Array.from({ length: 50 }, (_, i) => ({
  id: i,
  url: `https://picsum.photos/800/600?random=${i}`,
  thumbnail: `https://picsum.photos/200/150?random=${i}`,
  title: `Image ${i + 1}`,
}));
```

### **Exercise 2: Code Editor v·ªõi Syntax Highlighting**

```jsx
// TODO: Simple code editor

const CodeEditor = forwardRef(function CodeEditor(
  { defaultValue = "", language = "javascript", theme = "dark" },
  ref
) {
  const editorRef = useRef(null);
  const lineNumbersRef = useRef(null);
  const [code, setCode] = useState(defaultValue);
  const [cursorPosition, setCursorPosition] = useState({ line: 1, column: 1 });

  // TODO: useImperativeHandle to expose methods
  // - getValue(): get current code
  // - setValue(code): set code
  // - insertText(text): insert at cursor
  // - format(): auto-format code
  // - undo(): undo last change
  // - redo(): redo
  // - find(text): find text
  // - replace(oldText, newText): replace

  useImperativeHandle(
    ref,
    () => ({
      getValue: () => code,
      setValue: (newCode) => setCode(newCode),
      insertText: (text) => {
        // TODO: Insert at cursor position
      },
      format: () => {
        // TODO: Auto-format
      },
      focus: () => {
        editorRef.current?.focus();
      },
    }),
    [code]
  );

  // TODO: Sync scroll gi·ªØa line numbers v√† editor

  // TODO: Update cursor position

  // TODO: Syntax highlighting (simple)

  // TODO: Auto-indent

  // TODO: Bracket matching

  return (
    <div className="code-editor">
      <div className="editor-header">
        <span>Language: {language}</span>
        <span>
          Line {cursorPosition.line}, Col {cursorPosition.column}
        </span>
      </div>

      <div className="editor-body">
        <div ref={lineNumbersRef} className="line-numbers">
          {/* Line numbers */}
        </div>

        <textarea
          ref={editorRef}
          value={code}
          onChange={(e) => setCode(e.target.value)}
          spellCheck={false}
          className="editor-textarea"
        />
      </div>
    </div>
  );
});

// Usage
function CodeEditorDemo() {
  const editorRef = useRef(null);

  const handleFormat = () => {
    editorRef.current?.format();
  };

  const handleInsert = () => {
    editorRef.current?.insertText('console.log("Hello");');
  };

  return (
    <div>
      <div className="toolbar">
        <button onClick={handleFormat}>Format</button>
        <button onClick={handleInsert}>Insert Log</button>
        <button onClick={() => console.log(editorRef.current?.getValue())}>
          Get Code
        </button>
      </div>

      <CodeEditor
        ref={editorRef}
        defaultValue="function hello() {\n  console.log('Hello World');\n}"
        language="javascript"
      />
    </div>
  );
}
```

### **Exercise 3: Draggable Resizable Panel**

```jsx
// TODO: Implement draggable v√† resizable panel

function DraggablePanel({ children, initialPosition, initialSize }) {
  const panelRef = useRef(null);
  const dragHandleRef = useRef(null);
  const resizeHandleRef = useRef(null);

  const positionRef = useRef(initialPosition || { x: 100, y: 100 });
  const sizeRef = useRef(initialSize || { width: 400, height: 300 });

  // TODO: Drag functionality
  // - Click and drag header to move
  // - Keep panel within viewport bounds
  // - Snap to edges (optional)

  // TODO: Resize functionality
  // - Drag bottom-right corner to resize
  // - Min/max size constraints
  // - Maintain aspect ratio (v·ªõi Shift key)

  // TODO: Features
  // - Minimize/maximize
  // - Close
  // - Save position/size to localStorage
  // - Restore on mount

  useEffect(() => {
    const panel = panelRef.current;
    const dragHandle = dragHandleRef.current;
    if (!panel || !dragHandle) return;

    let isDragging = false;
    let dragStart = { x: 0, y: 0 };

    const handleMouseDown = (e) => {
      isDragging = true;
      dragStart = {
        x: e.clientX - positionRef.current.x,
        y: e.clientY - positionRef.current.y,
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    };

    const handleMouseMove = (e) => {
      if (!isDragging) return;

      const x = e.clientX - dragStart.x;
      const y = e.clientY - dragStart.y;

      // Keep within viewport
      const maxX = window.innerWidth - sizeRef.current.width;
      const maxY = window.innerHeight - sizeRef.current.height;

      positionRef.current = {
        x: Math.max(0, Math.min(x, maxX)),
        y: Math.max(0, Math.min(y, maxY)),
      };

      panel.style.transform = `translate(${positionRef.current.x}px, ${positionRef.current.y}px)`;
    };

    const handleMouseUp = () => {
      isDragging = false;
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };

    dragHandle.addEventListener("mousedown", handleMouseDown);

    return () => {
      dragHandle.removeEventListener("mousedown", handleMouseDown);
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, []);

  // TODO: Implement resize logic

  return (
    <div
      ref={panelRef}
      className="draggable-panel"
      style={{
        position: "fixed",
        width: sizeRef.current.width,
        height: sizeRef.current.height,
        transform: `translate(${positionRef.current.x}px, ${positionRef.current.y}px)`,
      }}
    >
      <div ref={dragHandleRef} className="panel-header">
        <span>Draggable Panel</span>
        <button>√ó</button>
      </div>

      <div className="panel-body">{children}</div>

      <div ref={resizeHandleRef} className="resize-handle" />
    </div>
  );
}

// Usage
function App() {
  return (
    <div>
      <DraggablePanel>
        <p>Panel content here</p>
      </DraggablePanel>
    </div>
  );
}
```

### **Exercise 4: Infinite Canvas Drawing**

```jsx
// TODO: Implement infinite canvas v·ªõi pan v√† zoom

function InfiniteCanvas() {
  const canvasRef = useRef(null);
  const contextRef = useRef(null);

  const viewportRef = useRef({
    x: 0,
    y: 0,
    zoom: 1,
  });

  const isDrawingRef = useRef(false);
  const lastPointRef = useRef(null);

  // TODO: Drawing functionality
  // - Pen tool
  // - Eraser tool
  // - Line tool
  // - Rectangle tool
  // - Circle tool
  // - Color picker
  // - Brush size

  // TODO: Pan functionality
  // - Click and drag to pan (v·ªõi Space key)
  // - Touch support

  // TODO: Zoom functionality
  // - Mouse wheel to zoom
  // - Zoom in/out buttons
  // - Fit to screen
  // - Zoom to cursor position

  // TODO: Features
  // - Undo/redo stack
  // - Clear canvas
  // - Export as image
  // - Load image
  // - Grid overlay
  // - Ruler/guides

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    contextRef.current = ctx;

    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // TODO: Setup drawing event listeners

    // TODO: Setup pan/zoom event listeners
  }, []);

  const draw = (x, y) => {
    const ctx = contextRef.current;
    if (!ctx) return;

    // Apply viewport transform
    const worldX = (x - viewportRef.current.x) / viewportRef.current.zoom;
    const worldY = (y - viewportRef.current.y) / viewportRef.current.zoom;

    if (lastPointRef.current) {
      ctx.beginPath();
      ctx.moveTo(lastPointRef.current.x, lastPointRef.current.y);
      ctx.lineTo(worldX, worldY);
      ctx.stroke();
    }

    lastPointRef.current = { x: worldX, y: worldY };
  };

  return (
    <div className="infinite-canvas">
      <div className="toolbar">{/* Tools */}</div>

      <canvas ref={canvasRef} style={{ cursor: "crosshair" }} />
    </div>
  );
}
```

### **Exercise 5: Advanced Modal Manager (Challenge)**

```jsx
// TODO: Implement modal manager v·ªõi ref API

const Modal = forwardRef(function Modal(
  { children, title, onClose, size = "medium" },
  ref
) {
  const modalRef = useRef(null);
  const focusTrapRef = useRef([]);
  const previousActiveElement = useRef(null);

  useImperativeHandle(
    ref,
    () => ({
      open: () => {
        // TODO: Open modal
        // - Show modal
        // - Lock body scroll
        // - Save current focus
        // - Focus first element in modal
      },

      close: () => {
        // TODO: Close modal
        // - Hide modal
        // - Unlock body scroll
        // - Restore previous focus
      },

      toggle: () => {
        // TODO: Toggle modal state
      },

      focusFirstElement: () => {
        // TODO: Focus first focusable element
      },

      focusLastElement: () => {
        // TODO: Focus last focusable element
      },
    }),
    []
  );

  // TODO: Focus trap
  // - Tab key cycles through focusable elements
  // - Shift+Tab goes backward
  // - Cannot tab outside modal

  // TODO: Keyboard handling
  // - Escape to close
  // - Tab navigation

  // TODO: Click outside to close (optional)

  // TODO: Prevent body scroll when open

  return (
    <div className="modal-backdrop">
      <div
        ref={modalRef}
        className={`modal modal-${size}`}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
      >
        <div className="modal-header">
          <h2 id="modal-title">{title}</h2>
          <button onClick={onClose} aria-label="Close">
            √ó
          </button>
        </div>

        <div className="modal-body">{children}</div>
      </div>
    </div>
  );
});

// Modal Manager
function ModalManager() {
  const modalRefs = useRef({});

  const openModal = (id) => {
    modalRefs.current[id]?.open();
  };

  const closeModal = (id) => {
    modalRefs.current[id]?.close();
  };

  const closeAllModals = () => {
    Object.values(modalRefs.current).forEach((modal) => {
      modal?.close();
    });
  };

  return (
    <div className="modal-manager">
      <h1>Modal Manager</h1>

      <button onClick={() => openModal("confirm")}>Open Confirm Modal</button>
      <button onClick={() => openModal("form")}>Open Form Modal</button>
      <button onClick={() => openModal("nested")}>Open Nested Modal</button>
      <button onClick={closeAllModals}>Close All</button>

      {/* Confirm Modal */}
      <Modal
        ref={(node) => (modalRefs.current.confirm = node)}
        title="Confirm Action"
        onClose={() => closeModal("confirm")}
        size="small"
      >
        <p>Are you sure you want to proceed?</p>
        <div className="modal-actions">
          <button onClick={() => closeModal("confirm")}>Cancel</button>
          <button
            onClick={() => {
              console.log("Confirmed");
              closeModal("confirm");
            }}
          >
            Confirm
          </button>
        </div>
      </Modal>

      {/* Form Modal */}
      <Modal
        ref={(node) => (modalRefs.current.form = node)}
        title="Contact Form"
        onClose={() => closeModal("form")}
        size="medium"
      >
        <form>
          <input type="text" placeholder="Name" />
          <input type="email" placeholder="Email" />
          <textarea placeholder="Message" rows={5} />
          <button type="submit">Submit</button>
        </form>
      </Modal>

      {/* Nested Modal */}
      <Modal
        ref={(node) => (modalRefs.current.nested = node)}
        title="Parent Modal"
        onClose={() => closeModal("nested")}
        size="large"
      >
        <p>This modal can open another modal</p>
        <button onClick={() => openModal("confirm")}>Open Nested Modal</button>
      </Modal>
    </div>
  );
}

// TODO:
// 1. Implement open/close functionality
// 2. Focus trap implementation
// 3. Keyboard navigation
// 4. Body scroll lock
// 5. Nested modals support
// 6. Animation (fade in/out)
// 7. Accessibility (ARIA attributes)
```

---

## ‚úÖ PH·∫¶N 4: REVIEW & CHECKLIST (15-30 ph√∫t)

### **useRef:**

- [ ] Syntax: `const ref = useRef(initialValue)`
- [ ] Returns: `{ current: value }`
- [ ] Mutable, kh√¥ng trigger re-render
- [ ] 2 use cases: DOM refs & mutable values

### **forwardRef:**

- [ ] Pass ref xu·ªëng child component
- [ ] Syntax: `forwardRef((props, ref) => ...)`
- [ ] C·∫ßn khi component wrap DOM element

### **useImperativeHandle:**

- [ ] Customize ref value
- [ ] Syntax: `useImperativeHandle(ref, () => ({ methods }), [deps])`
- [ ] Expose specific methods, kh√¥ng ph·∫£i entire DOM

### **Callback Refs:**

- [ ] Alternative to useRef
- [ ] Function called v·ªõi DOM node
- [ ] Useful cho dynamic refs

### **Common Patterns:**

- [ ] Focus management
- [ ] Scroll control
- [ ] DOM measurements
- [ ] Video/audio control
- [ ] Previous values
- [ ] Timer IDs
- [ ] Instance variables

### **Common Mistakes:**

```jsx
// ‚ùå D√πng ref cho state
const countRef = useRef(0);
const increment = () => {
  countRef.current++; // UI kh√¥ng update!
};

// ‚ùå Read ref trong render
function Component() {
  const ref = useRef(null);
  console.log(ref.current); // null l·∫ßn ƒë·∫ßu!
  return <div ref={ref}>Content</div>;
}

// ‚ùå Forgot to check null
const focusInput = () => {
  inputRef.current.focus(); // C√≥ th·ªÉ null!
};

// ‚ùå Mutate ref.current trong render
function Component() {
  const ref = useRef(0);
  ref.current++; // Side effect trong render!
  return <div>{ref.current}</div>;
}

// ‚úÖ ƒê√öNG
const [count, setCount] = useState(0);
const increment = () => setCount(count + 1);

useEffect(() => {
  console.log(ref.current); // Sau render
}, []);

const focusInput = () => {
  inputRef.current?.focus(); // Optional chaining
};

useEffect(() => {
  ref.current++; // Trong effect
}, []);
```

---

## üéØ HOMEWORK

### **1. Rich Text Editor**

Simple WYSIWYG editor v·ªõi:

- Bold, italic, underline
- Text alignment
- Font size v√† color
- Undo/redo
- Selection management v·ªõi refs
- Export HTML

### **2. Spreadsheet Component**

Mini Excel-like v·ªõi:

- Editable cells
- Formula support (SUM, AVERAGE, etc.)
- Cell selection
- Copy/paste
- Keyboard navigation
- Focus management

### **3. Drawing App**

Paint-like application v·ªõi:

- Multiple tools (pen, line, rectangle, circle)
- Color picker
- Undo/redo stack
- Layers
- Export as PNG
- Touch support

### **4. Audio Player v·ªõi Waveform**

Custom audio player v·ªõi:

- Waveform visualization
- Seek by clicking waveform
- Playback controls
- Speed control
- Loop sections
- Bookmarks

### **5. Dashboard Builder (Challenge)**

Drag-and-drop dashboard v·ªõi:

- Draggable widgets
- Resizable widgets
- Grid snapping
- Widget library
- Save/load layouts
- Export configuration

---

## üìö ƒê·ªçc Th√™m

### **Official Docs:**

- [React - useRef](https://react.dev/reference/react/useRef)
- [React - forwardRef](https://react.dev/reference/react/forwardRef)
- [React - useImperativeHandle](https://react.dev/reference/react/useImperativeHandle)
- [React - Manipulating the DOM with Refs](https://react.dev/learn/manipulating-the-dom-with-refs)

### **Advanced Reading:**

- [MDN - Element API](https://developer.mozilla.org/en-US/docs/Web/API/Element)
- [Focus Management](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/)

---

## üìù Key Takeaways

1. **useRef ‚â† useState** - Ref kh√¥ng trigger re-render
2. **DOM Access** - useRef l√† c√°ch official ƒë·ªÉ access DOM
3. **forwardRef** - Pass refs through components
4. **useImperativeHandle** - Customize exposed API
5. **Callback Refs** - Dynamic v√† flexible
6. **Focus Management** - Critical cho accessibility
7. **Mutable Values** - Store timers, connections, previous values

---

## üí° Pro Tips

1. **Always check null**: `ref.current?.method()`
2. **Read refs trong effects**: Kh√¥ng ph·∫£i render
3. **useLayoutEffect cho DOM**: Khi c·∫ßn sync updates
4. **Accessibility**: Focus management r·∫•t quan tr·ªçng
5. **Cleanup**: Clear timers, disconnect listeners

---

**üéâ HO√ÄN TH√ÄNH NG√ÄY 12!**

**Achievements:**

- ‚úÖ useRef mastery
- ‚úÖ forwardRef patterns
- ‚úÖ useImperativeHandle usage
- ‚úÖ Callback refs
- ‚úÖ DOM manipulation skills

**üìä Progress: 40% (12/30 ng√†y)**

**üöÄ Ng√†y mai (Ng√†y 13):** React 18 Concurrent Hooks - useTransition, useDeferredValue, useSyncExternalStore!
