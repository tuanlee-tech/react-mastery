# üìÖ NG√ÄY 5: Class Components (Legacy)

## üéØ M·ª•c ti√™u h√¥m nay

- Hi·ªÉu Class Components syntax (ƒë·ªÉ ƒë·ªçc code c≈©)
- Master Lifecycle Methods
- So s√°nh Class vs Function Components
- Bi·∫øt c√°ch refactor Class ‚Üí Function
- Migration strategies

**‚ö†Ô∏è L∆∞u √Ω:** Class components l√† legacy! H·ªçc ƒë·ªÉ hi·ªÉu code c≈©, KH√îNG n√™n vi·∫øt m·ªõi.

---

## üìö PH·∫¶N 1: THEORY (30-45 ph√∫t)

### **1.1. Class Component Basics**

#### **Syntax c∆° b·∫£n**

```jsx
import React, { Component } from "react";

// Function Component (Modern)
function Welcome({ name }) {
  return <h1>Hello, {name}</h1>;
}

// Class Component (Legacy)
class Welcome extends Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

#### **State trong Class Components**

```jsx
class Counter extends Component {
  // C√°ch 1: Constructor
  constructor(props) {
    super(props); // PH·∫¢I g·ªçi super(props)
    this.state = {
      count: 0,
    };
  }

  // C√°ch 2: Class field (modern syntax)
  state = {
    count: 0,
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
      </div>
    );
  }
}
```

#### **Updating State**

```jsx
class Counter extends Component {
  state = {
    count: 0,
    name: "Counter",
  };

  // ‚ùå WRONG - Direct mutation
  increment() {
    this.state.count++; // NEVER DO THIS!
  }

  // ‚úÖ CORRECT - setState
  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  // ‚úÖ CORRECT - Functional update (khi c·∫ßn previous state)
  incrementByTwo = () => {
    this.setState((prevState) => ({ count: prevState.count + 1 }));
    this.setState((prevState) => ({ count: prevState.count + 1 }));
  };

  render() {
    return (
      <div>
        <p>
          {this.state.name}: {this.state.count}
        </p>
        <button onClick={this.increment}>+1</button>
        <button onClick={this.incrementByTwo}>+2</button>
      </div>
    );
  }
}
```

**setState Callback:**

```jsx
this.setState({ count: this.state.count + 1 }, () => {
  console.log("State updated:", this.state.count);
  // Callback ch·∫°y sau khi state ƒë√£ update
});
```

#### **Event Handlers & Binding**

```jsx
class Form extends Component {
  state = { text: "" };

  // ‚ùå PROBLEM - this is undefined
  handleChange(e) {
    this.setState({ text: e.target.value }); // Error!
  }

  // ‚úÖ Solution 1: Arrow function (khuy√™n d√πng)
  handleChange = (e) => {
    this.setState({ text: e.target.value });
  };

  // ‚úÖ Solution 2: Bind trong constructor
  constructor(props) {
    super(props);
    this.state = { text: "" };
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleSubmit(e) {
    e.preventDefault();
    console.log(this.state.text);
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input value={this.state.text} onChange={this.handleChange} />
        <button type="submit">Submit</button>
      </form>
    );
  }
}
```

---

### **1.2. Component Lifecycle Methods**

Lifecycle methods ch·ªâ c√≥ trong Class Components (Function components d√πng useEffect).

#### **Lifecycle Phases**

```
1. MOUNTING (Component ƒë∆∞·ª£c t·∫°o v√† insert v√†o DOM)
   constructor() ‚Üí render() ‚Üí componentDidMount()

2. UPDATING (Component re-render khi props/state thay ƒë·ªïi)
   render() ‚Üí componentDidUpdate()

3. UNMOUNTING (Component b·ªã remove kh·ªèi DOM)
   componentWillUnmount()

4. ERROR HANDLING
   componentDidCatch()
```

#### **1. componentDidMount()**

Ch·∫°y sau khi component ƒë∆∞·ª£c mount (render l·∫ßn ƒë·∫ßu).

```jsx
class UserProfile extends Component {
  state = {
    user: null,
    loading: true,
  };

  componentDidMount() {
    // ‚úÖ Perfect cho:
    // - Data fetching
    // - Subscriptions
    // - DOM manipulation
    // - Timers

    fetch(`/api/users/${this.props.userId}`)
      .then((res) => res.json())
      .then((user) => {
        this.setState({ user, loading: false });
      });

    // Setup timer
    this.timer = setInterval(() => {
      console.log("Tick");
    }, 1000);

    // Add event listener
    window.addEventListener("resize", this.handleResize);
  }

  componentWillUnmount() {
    // ‚ö†Ô∏è CLEANUP - R·∫•t quan tr·ªçng!
    clearInterval(this.timer);
    window.removeEventListener("resize", this.handleResize);
  }

  handleResize = () => {
    console.log("Window resized");
  };

  render() {
    if (this.state.loading) return <div>Loading...</div>;
    return <div>{this.state.user.name}</div>;
  }
}
```

**Function Component equivalent:**

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then((res) => res.json())
      .then((user) => {
        setUser(user);
        setLoading(false);
      });

    const timer = setInterval(() => {
      console.log("Tick");
    }, 1000);

    const handleResize = () => {
      console.log("Window resized");
    };
    window.addEventListener("resize", handleResize);

    // Cleanup
    return () => {
      clearInterval(timer);
      window.removeEventListener("resize", handleResize);
    };
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>{user.name}</div>;
}
```

#### **2. componentDidUpdate(prevProps, prevState)**

Ch·∫°y sau m·ªói l·∫ßn re-render (tr·ª´ l·∫ßn ƒë·∫ßu).

```jsx
class SearchResults extends Component {
  state = {
    results: [],
    loading: false,
  };

  componentDidUpdate(prevProps, prevState) {
    // ‚ö†Ô∏è PH·∫¢I c√≥ condition, kh√¥ng th√¨ infinite loop!

    // ‚úÖ Fetch khi query thay ƒë·ªïi
    if (this.props.query !== prevProps.query) {
      this.fetchResults(this.props.query);
    }

    // ‚úÖ Save to localStorage khi state thay ƒë·ªïi
    if (this.state.favorites !== prevState.favorites) {
      localStorage.setItem("favorites", JSON.stringify(this.state.favorites));
    }

    // ‚úÖ Scroll to top khi page thay ƒë·ªïi
    if (this.props.page !== prevProps.page) {
      window.scrollTo(0, 0);
    }
  }

  fetchResults = (query) => {
    this.setState({ loading: true });
    fetch(`/api/search?q=${query}`)
      .then((res) => res.json())
      .then((results) => {
        this.setState({ results, loading: false });
      });
  };

  render() {
    return <div>{/* render results */}</div>;
  }
}
```

**Function Component equivalent:**

```jsx
function SearchResults({ query, page }) {
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);

  // Fetch khi query thay ƒë·ªïi
  useEffect(() => {
    setLoading(true);
    fetch(`/api/search?q=${query}`)
      .then((res) => res.json())
      .then((results) => {
        setResults(results);
        setLoading(false);
      });
  }, [query]);

  // Scroll khi page thay ƒë·ªïi
  useEffect(() => {
    window.scrollTo(0, 0);
  }, [page]);

  return <div>{/* render results */}</div>;
}
```

#### **3. componentWillUnmount()**

Ch·∫°y tr∆∞·ªõc khi component b·ªã remove.

```jsx
class ChatRoom extends Component {
  componentDidMount() {
    // Subscribe
    this.subscription = chatAPI.subscribe(
      this.props.roomId,
      this.handleMessage
    );
  }

  componentWillUnmount() {
    // ‚úÖ CLEANUP - NgƒÉn memory leaks!
    // - Unsubscribe
    // - Clear timers
    // - Cancel requests
    // - Remove event listeners

    this.subscription.unsubscribe();
  }

  handleMessage = (message) => {
    console.log("New message:", message);
  };

  render() {
    return <div>Chat Room {this.props.roomId}</div>;
  }
}
```

#### **4. shouldComponentUpdate(nextProps, nextState)**

Optimization method - quy·∫øt ƒë·ªãnh c√≥ n√™n re-render kh√¥ng.

```jsx
class ExpensiveComponent extends Component {
  shouldComponentUpdate(nextProps, nextState) {
    // ‚ö†Ô∏è Ch·ªâ d√πng khi c·∫ßn optimize performance!

    // Return false = skip re-render
    // Return true = re-render nh∆∞ b√¨nh th∆∞·ªùng

    // ‚úÖ Only re-render if data changed
    return (
      nextProps.data !== this.props.data || nextState.count !== this.state.count
    );
  }

  render() {
    console.log("Rendering expensive component...");
    // Expensive calculations here
    return <div>{this.props.data}</div>;
  }
}
```

**Modern alternative: React.memo() cho function components**

```jsx
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
  console.log("Rendering expensive component...");
  return <div>{data}</div>;
});
```

#### **5. getDerivedStateFromProps() (Static method)**

Sync state v·ªõi props (hi·∫øm khi c·∫ßn).

```jsx
class EmailInput extends Component {
  state = {
    email: this.props.defaultEmail,
  };

  // ‚ö†Ô∏è RARELY NEEDED! Usually anti-pattern
  static getDerivedStateFromProps(props, state) {
    // Update state khi props.defaultEmail thay ƒë·ªïi
    // NH∆ØNG ch·ªâ khi user ch∆∞a edit
    if (props.defaultEmail !== state.email && !state.edited) {
      return { email: props.defaultEmail };
    }
    return null; // Kh√¥ng update state
  }

  handleChange = (e) => {
    this.setState({ email: e.target.value, edited: true });
  };

  render() {
    return <input value={this.state.email} onChange={this.handleChange} />;
  }
}
```

**‚ö†Ô∏è Th∆∞·ªùng kh√¥ng c·∫ßn getDerivedStateFromProps! Alternatives:**

```jsx
// ‚úÖ Better: Controlled component
function EmailInput({ email, onChange }) {
  return <input value={email} onChange={onChange} />;
}

// ‚úÖ Better: Key prop ƒë·ªÉ reset
<EmailInput key={userId} defaultEmail={user.email} />;

// ‚úÖ Better: useEffect trong function component
function EmailInput({ defaultEmail }) {
  const [email, setEmail] = useState(defaultEmail);

  useEffect(() => {
    setEmail(defaultEmail);
  }, [defaultEmail]);

  return <input value={email} onChange={(e) => setEmail(e.target.value)} />;
}
```

---

### **1.3. Error Boundaries**

Error Boundaries ch·ªâ c√≥ th·ªÉ implement v·ªõi Class Components (ch∆∞a c√≥ Hook).

```jsx
class ErrorBoundary extends Component {
  state = {
    hasError: false,
    error: null,
    errorInfo: null
  };

  // 1. Catch errors v√† update state
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  // 2. Log error
  componentDidCatch(error, errorInfo) {
    // Log to error reporting service
    console.error('Error caught:', error, errorInfo);

    this.setState({
      error,
      errorInfo
    });

    // Send to Sentry, LogRocket, etc.
    // logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Fallback UI
      return (
        <div className="error-boundary">
          <h2>‚ö†Ô∏è Something went wrong</h2>
          <details>
            <summary>Error details</summary>
            <p>{this.state.error?.toString()}</p>
            <pre>{this.state.errorInfo?.componentStack}</pre>
          </details>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Usage
<ErrorBoundary>
  <App />
</ErrorBoundary>

// Multiple boundaries
<ErrorBoundary>
  <Header />
  <ErrorBoundary>
    <MainContent />
  </ErrorBoundary>
  <ErrorBoundary>
    <Sidebar />
  </ErrorBoundary>
</ErrorBoundary>
```

**‚ö†Ô∏è Error Boundaries KH√îNG catch:**

- Event handlers (d√πng try-catch)
- Async code (setTimeout, promises)
- Server-side rendering
- Errors trong ch√≠nh Error Boundary

```jsx
// ‚ùå Error Boundary kh√¥ng catch
class Button extends Component {
  handleClick = () => {
    throw new Error("Click error"); // ‚ùå Kh√¥ng catch ƒë∆∞·ª£c
  };

  render() {
    return <button onClick={this.handleClick}>Click</button>;
  }
}

// ‚úÖ Ph·∫£i d√πng try-catch
class Button extends Component {
  handleClick = () => {
    try {
      // risky code
      throw new Error("Click error");
    } catch (error) {
      console.error("Caught:", error);
    }
  };

  render() {
    return <button onClick={this.handleClick}>Click</button>;
  }
}
```

---

### **1.4. Class vs Function Components**

#### **Comparison Table**

| Feature        | Class Component                 | Function Component |
| -------------- | ------------------------------- | ------------------ |
| State          | `this.state`, `this.setState()` | `useState()`       |
| Lifecycle      | lifecycle methods               | `useEffect()`      |
| Props          | `this.props`                    | function parameter |
| Methods        | class methods                   | functions          |
| `this` binding | Required                        | Not needed         |
| Code length    | Longer                          | Shorter            |
| Performance    | Slightly slower                 | Faster             |
| Hooks          | ‚ùå No                           | ‚úÖ Yes             |
| Modern?        | ‚ùå Legacy                       | ‚úÖ Recommended     |

#### **Same Component, Both Ways**

```jsx
// ‚ùå CLASS COMPONENT (Old way)
class UserProfile extends Component {
  state = {
    user: null,
    loading: true,
    error: null,
  };

  componentDidMount() {
    this.fetchUser();
  }

  componentDidUpdate(prevProps) {
    if (this.props.userId !== prevProps.userId) {
      this.fetchUser();
    }
  }

  componentWillUnmount() {
    // Cancel requests if needed
  }

  fetchUser = async () => {
    this.setState({ loading: true, error: null });
    try {
      const response = await fetch(`/api/users/${this.props.userId}`);
      const user = await response.json();
      this.setState({ user, loading: false });
    } catch (error) {
      this.setState({ error, loading: false });
    }
  };

  render() {
    const { user, loading, error } = this.state;

    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;
    if (!user) return null;

    return (
      <div>
        <h2>{user.name}</h2>
        <p>{user.email}</p>
      </div>
    );
  }
}

// ‚úÖ FUNCTION COMPONENT (Modern way)
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let cancelled = false;

    const fetchUser = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        if (!cancelled) {
          setUser(userData);
          setLoading(false);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err);
          setLoading(false);
        }
      }
    };

    fetchUser();

    return () => {
      cancelled = true;
    };
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user) return null;

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

---

### **1.5. Migration Strategies**

#### **Step-by-step Refactoring**

```jsx
// STEP 1: Class Component
class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    this.increment = this.increment.bind(this);
  }

  increment() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>+</button>
      </div>
    );
  }
}

// STEP 2: Remove constructor, use arrow functions
class Counter extends Component {
  state = { count: 0 };

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>+</button>
      </div>
    );
  }
}

// STEP 3: Convert to function component
function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}

// STEP 4: Simplify
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

#### **Lifecycle to Hooks Cheatsheet**

```jsx
// componentDidMount
componentDidMount() {
  // Do something
}
// ‚Üì
useEffect(() => {
  // Do something
}, []); // Empty deps = run once

// componentDidUpdate
componentDidUpdate(prevProps) {
  if (this.props.value !== prevProps.value) {
    // Do something
  }
}
// ‚Üì
useEffect(() => {
  // Do something
}, [value]); // Run when value changes

// componentWillUnmount
componentWillUnmount() {
  // Cleanup
}
// ‚Üì
useEffect(() => {
  return () => {
    // Cleanup
  };
}, []);

// componentDidMount + componentDidUpdate + componentWillUnmount
componentDidMount() {
  this.subscribe();
}
componentDidUpdate(prevProps) {
  if (this.props.id !== prevProps.id) {
    this.unsubscribe();
    this.subscribe();
  }
}
componentWillUnmount() {
  this.unsubscribe();
}
// ‚Üì
useEffect(() => {
  subscribe();
  return () => {
    unsubscribe();
  };
}, [id]);
```

---

## üíª PH·∫¶N 2: CODE DEMO (30-45 ph√∫t)

### **Demo: Complete Class Component Example**

```jsx
// Timer Component - Class version
class Timer extends Component {
  constructor(props) {
    super(props);
    this.state = {
      seconds: 0,
      isRunning: false,
    };
  }

  componentDidMount() {
    console.log("Timer mounted");
  }

  componentDidUpdate(prevProps, prevState) {
    // Start/stop timer based on isRunning
    if (this.state.isRunning && !prevState.isRunning) {
      this.startTimer();
    } else if (!this.state.isRunning && prevState.isRunning) {
      this.stopTimer();
    }
  }

  componentWillUnmount() {
    this.stopTimer();
    console.log("Timer unmounted");
  }

  startTimer = () => {
    this.interval = setInterval(() => {
      this.setState((prevState) => ({
        seconds: prevState.seconds + 1,
      }));
    }, 1000);
  };

  stopTimer = () => {
    if (this.interval) {
      clearInterval(this.interval);
    }
  };

  toggleTimer = () => {
    this.setState((prevState) => ({
      isRunning: !prevState.isRunning,
    }));
  };

  resetTimer = () => {
    this.setState({
      seconds: 0,
      isRunning: false,
    });
  };

  formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, "0")}:${secs
      .toString()
      .padStart(2, "0")}`;
  };

  render() {
    return (
      <div className="timer">
        <h2>Timer</h2>
        <div className="time-display">
          {this.formatTime(this.state.seconds)}
        </div>
        <div className="controls">
          <button onClick={this.toggleTimer}>
            {this.state.isRunning ? "Pause" : "Start"}
          </button>
          <button onClick={this.resetTimer}>Reset</button>
        </div>
      </div>
    );
  }
}

// Same component - Function version
function Timer() {
  const [seconds, setSeconds] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    let interval;
    if (isRunning) {
      interval = setInterval(() => {
        setSeconds((s) => s + 1);
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [isRunning]);

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, "0")}:${secs
      .toString()
      .padStart(2, "0")}`;
  };

  return (
    <div className="timer">
      <h2>Timer</h2>
      <div className="time-display">{formatTime(seconds)}</div>
      <div className="controls">
        <button onClick={() => setIsRunning(!isRunning)}>
          {isRunning ? "Pause" : "Start"}
        </button>
        <button
          onClick={() => {
            setSeconds(0);
            setIsRunning(false);
          }}
        >
          Reset
        </button>
      </div>
    </div>
  );
}
```

---

## üî® PH·∫¶N 3: TH·ª∞C H√ÄNH (60-90 ph√∫t)

### **Exercise 1: Convert Class to Function**

Refactor c√°c class components sau th√†nh function components:

```jsx
// TODO: Convert to function component
class TodoList extends Component {
  state = {
    todos: [],
    inputValue: '',
    filter: 'all' // 'all', 'active', 'completed'
  };

  componentDidMount() {
    const saved = localStorage.getItem('todos');
    if (saved) {
      this.setState({ todos: JSON.parse(saved) });
    }
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevState.todos !== this.state.todos) {
      localStorage.setItem('todos', JSON.stringify(this.state.todos));
    }
  }

  addTodo = () => {
    if (this.state.inputValue.trim()) {
      this.setState(prevState => ({
        todos: [
          ...prevState.todos,
          {
            id: Date.now(),
            text: prevState.inputValue,
            completed: false
          }
        ],
        inputValue: ''
      }));
    }
  };

  toggle Todo = (id) => {
    this.setState(prevState => ({
      todos: prevState.todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    }));
  };

  deleteTodo = (id) => {
    this.setState(prevState => ({
      todos: prevState.todos.filter(todo => todo.id !== id)
    }));
  };

  getFilteredTodos = () => {
    const { todos, filter } = this.state;
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.completed);
      case 'completed':
        return todos.filter(t => t.completed);
      default:
        return todos;
    }
  };

  render() {
    const filteredTodos = this.getFilteredTodos();

    return (
      <div>
        <input
          value={this.state.inputValue}
          onChange={(e) => this.setState({ inputValue: e.target.value })}
          onKeyPress={(e) => e.key === 'Enter' && this.addTodo()}
        />
        <button onClick={this.addTodo}>Add</button>

        <div>
          {['all', 'active', 'completed'].map(filter => (
            <button
              key={filter}
              onClick={() => this.setState({ filter })}
            >
              {filter}
            </button>
          ))}
        </div>

        <ul>
          {filteredTodos.map(todo => (
            <li key={todo.id}>
              <input
                type="checkbox"
                checked={todo.completed}
                onChange={() => this.toggleTodo(todo.id)}
              />
              <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
                {todo.text}
              </span>
              <button onClick={() => this.deleteTodo(todo.id)}>Delete</button>
            </li>
          ))}
        </ul>
      </div>
    );
  }
}
```

### **Exercise 2: Form with Validation (Class Component)**

T·∫°o form v·ªõi validation using class component (ƒë·ªÉ practice):

```jsx
// TODO: Implement class component
class RegistrationForm extends Component {
  state = {
    formData: {
      username: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
    errors: {},
    touched: {},
    isSubmitting: false,
  };

  // TODO:
  // 1. Validate field on blur
  // 2. Validate entire form on submit
  // 3. Show errors only for touched fields
  // 4. Disable submit if form invalid
  // 5. Handle async submission

  validateField = (name, value) => {
    // TODO: Return error message or null
    // - username: min 3 chars
    // - email: valid email
    // - password: min 6 chars
    // - confirmPassword: must match password
  };

  handleChange = (e) => {
    // TODO: Update formData
  };

  handleBlur = (e) => {
    // TODO: Mark field as touched, validate
  };

  handleSubmit = (e) => {
    e.preventDefault();
    // TODO: Validate all, submit if valid
  };

  render() {
    // TODO: Render form with error messages
  }
}
```

### **Exercise 3: Data Table with Sorting (Both versions)**

Implement c·∫£ Class v√† Function version:

```jsx
// Version 1: Class Component
class DataTable extends Component {
  state = {
    data: this.props.initialData,
    sortKey: null,
    sortDirection: "asc",
    currentPage: 1,
    itemsPerPage: 10,
  };

  // TODO:
  // 1. Sort functionality
  // 2. Pagination
  // 3. Search filter
  // 4. Select rows
  // 5. Bulk actions
}

// Version 2: Function Component
function DataTable({ initialData }) {
  // TODO: Convert above to hooks
}
```

### **Exercise 4: Error Boundary Usage**

```jsx
// TODO: Create custom ErrorBoundary
class ErrorBoundary extends Component {
  // TODO:
  // 1. Catch errors
  // 2. Log to service
  // 3. Show fallback UI
  // 4. Retry mechanism
  // 5. Reset on navigation
}

// TODO: Component that throws error
class BuggyComponent extends Component {
  state = { shouldThrow: false };

  componentDidUpdate() {
    if (this.state.shouldThrow) {
      throw new Error("Intentional error for testing");
    }
  }

  render() {
    return (
      <div>
        <button onClick={() => this.setState({ shouldThrow: true })}>
          Trigger Error
        </button>
      </div>
    );
  }
}

// Usage
<ErrorBoundary>
  <BuggyComponent />
</ErrorBoundary>;
```

### **Exercise 5: Lifecycle Playground (Challenge)**

T·∫°o component ƒë·ªÉ visualize lifecycle methods:

```jsx
class LifecycleDemo extends Component {
  state = {
    logs: [],
    count: 0,
    showChild: true,
  };

  log = (message) => {
    this.setState((prevState) => ({
      logs: [
        ...prevState.logs,
        `${new Date().toLocaleTimeString()}: ${message}`,
      ],
    }));
  };

  componentDidMount() {
    this.log("Parent: componentDidMount");
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevState.count !== this.state.count) {
      this.log(`Parent: componentDidUpdate (count: ${this.state.count})`);
    }
  }

  render() {
    this.log("Parent: render");

    return (
      <div>
        <h2>Lifecycle Demo</h2>

        <div>
          <button
            onClick={() => this.setState({ count: this.state.count + 1 })}
          >
            Increment Count ({this.state.count})
          </button>

          <button
            onClick={() => this.setState({ showChild: !this.state.showChild })}
          >
            {this.state.showChild ? "Hide" : "Show"} Child
          </button>
        </div>

        {this.state.showChild && (
          <ChildComponent log={this.log} count={this.state.count} />
        )}

        <div className="logs">
          <h3>Lifecycle Logs:</h3>
          <button onClick={() => this.setState({ logs: [] })}>
            Clear Logs
          </button>
          <ul>
            {this.state.logs.map((log, i) => (
              <li key={i}>{log}</li>
            ))}
          </ul>
        </div>
      </div>
    );
  }
}

class ChildComponent extends Component {
  componentDidMount() {
    this.props.log("Child: componentDidMount");
  }

  componentDidUpdate(prevProps) {
    if (prevProps.count !== this.props.count) {
      this.props.log(`Child: componentDidUpdate (count: ${this.props.count})`);
    }
  }

  componentWillUnmount() {
    this.props.log("Child: componentWillUnmount");
  }

  render() {
    this.props.log("Child: render");
    return <div>Child Component (count: {this.props.count})</div>;
  }
}

// TODO:
// 1. Observe lifecycle order
// 2. Add more lifecycle methods (shouldComponentUpdate, getDerivedStateFromProps)
// 3. Compare with function component + useEffect
// 4. Add performance metrics
```

---

## ‚úÖ PH·∫¶N 4: REVIEW & CHECKLIST (15-30 ph√∫t)

### **Class Components:**

- [ ] Extends `Component` or `PureComponent`
- [ ] `this.state` v√† `this.setState()`
- [ ] `this.props` ƒë·ªÉ access props
- [ ] `render()` method required
- [ ] Constructor v√† `super(props)`
- [ ] Event handler binding (arrow functions)

### **Lifecycle Methods:**

- [ ] **componentDidMount**: setup, data fetching
- [ ] **componentDidUpdate**: respond to changes
- [ ] **componentWillUnmount**: cleanup
- [ ] **shouldComponentUpdate**: optimization
- [ ] **getDerivedStateFromProps**: sync state with props (rare)
- [ ] **componentDidCatch**: error handling

### **Error Boundaries:**

- [ ] Ch·ªâ c√≥ trong class components
- [ ] `getDerivedStateFromError()` + `componentDidCatch()`
- [ ] Fallback UI
- [ ] Error logging
- [ ] Kh√¥ng catch event handlers, async code

### **Migration:**

- [ ] Class ‚Üí Function component
- [ ] State ‚Üí `useState`
- [ ] Lifecycle ‚Üí `useEffect`
- [ ] Methods ‚Üí functions
- [ ] `this` ‚Üí kh√¥ng c·∫ßn

### **Common Mistakes:**

```jsx
// ‚ùå Forgot super(props)
class MyComponent extends Component {
  constructor(props) {
    this.state = { count: 0 }; // Error!
  }
}

// ‚ùå Direct state mutation
this.state.count = 1; // NEVER!

// ‚ùå Not binding event handlers
class MyComponent extends Component {
  handleClick() {
    this.setState(...); // this is undefined!
  }
  render() {
    return <button onClick={this.handleClick}>Click</button>;
  }
}

// ‚ùå Infinite loop in componentDidUpdate
componentDidUpdate() {
  this.setState({ count: this.state.count + 1 }); // Infinite loop!
}

// ‚ùå Forgot cleanup
componentDidMount() {
  setInterval(() => {...}, 1000);
  // Memory leak! No cleanup in componentWillUnmount
}

// ‚úÖ ƒê√öNG
class MyComponent extends Component {
  constructor(props) {
    super(props); // ‚úÖ
    this.state = { count: 0 };
  }

  // ‚úÖ Arrow function
  handleClick = () => {
    this.setState({ count: this.state.count + 1 }); // ‚úÖ
  };

  // ‚úÖ Condition in componentDidUpdate
  componentDidUpdate(prevProps) {
    if (this.props.value !== prevProps.value) {
      this.setState({ count: 0 });
    }
  }

  // ‚úÖ Cleanup
  componentDidMount() {
    this.interval = setInterval(() => {...}, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval); // ‚úÖ
  }

  render() {
    return <button onClick={this.handleClick}>Count: {this.state.count}</button>;
  }
}
```

---

## üéØ HOMEWORK

### **1. Migration Practice**

Refactor 3 class components t·ª´ projects c≈© sang function components:

- Component v·ªõi complex state
- Component v·ªõi multiple lifecycle methods
- Component v·ªõi data fetching

### **2. Error Boundary Library**

T·∫°o reusable Error Boundary library:

```jsx
// ErrorBoundary.jsx
class ErrorBoundary extends Component {
  // TODO:
  // - Multiple fallback options
  // - Error logging integration
  // - Retry mechanism
  // - Reset on route change
  // - Development vs Production mode
}

// FallbackComponent.jsx
function ErrorFallback({ error, resetError, errorInfo }) {
  // TODO: Customizable error UI
}

// Usage
<ErrorBoundary
  fallback={<ErrorFallback />}
  onError={(error, errorInfo) => logToService(error, errorInfo)}
  onReset={() => console.log("Reset")}
>
  <App />
</ErrorBoundary>;
```

### **3. Lifecycle Comparison Chart**

T·∫°o interactive demo comparing:

- Class component lifecycles
- Function component + useEffect
- Visual timeline
- Performance comparison

### **4. Legacy Code Reader**

Practice ƒë·ªçc v√† hi·ªÉu code c≈©:

- T√¨m open source projects d√πng class components
- ƒê·ªçc v√† document lifecycle flow
- Identify potential bugs (missing cleanup, infinite loops)
- Propose refactoring strategies

### **5. PureComponent vs React.memo**

So s√°nh performance:

```jsx
// Version 1: PureComponent
class ExpensiveList extends PureComponent {
  render() {
    console.log('PureComponent render');
    return <ul>{this.props.items.map(...)}</ul>;
  }
}

// Version 2: Component + shouldComponentUpdate
class ExpensiveList extends Component {
  shouldComponentUpdate(nextProps) {
    return nextProps.items !== this.props.items;
  }
  render() {
    console.log('Component + SCU render');
    return <ul>{this.props.items.map(...)}</ul>;
  }
}

// Version 3: React.memo
const ExpensiveList = React.memo(function ExpensiveList({ items }) {
  console.log('React.memo render');
  return <ul>{items.map(...)}</ul>;
});

// TODO: Benchmark v√† so s√°nh
```

---

## üìö Additional Resources

### **ƒê·ªçc th√™m:**

- [React Docs - Components and Props](https://react.dev/reference/react/Component)
- [React Docs - State and Lifecycle](https://react.dev/learn/state-a-components-memory)
- [Dan Abramov - How Are Function Components Different from Classes?](https://overreacted.io/how-are-function-components-different-from-classes/)
- [React Lifecycle Diagram](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

### **Migration Tools:**

- [React Codemod](https://github.com/reactjs/react-codemod) - Automated refactoring
- ESLint rules for detecting class component anti-patterns
- TypeScript migration guides

---

## üìù Key Takeaways

1. **Class Components = Legacy**: H·ªçc ƒë·ªÉ ƒë·ªçc code c≈©, KH√îNG vi·∫øt m·ªõi
2. **Lifecycle Methods**: Hi·ªÉu ƒë·ªÉ migrate sang useEffect
3. **Error Boundaries**: V·∫´n c·∫ßn class components (ch∆∞a c√≥ Hook)
4. **`this` binding**: Source of bugs trong class components
5. **Function Components**: Ng·∫Øn g·ªçn, d·ªÖ test, d·ªÖ maintain h∆°n
6. **Migration**: T·ª´ng b∆∞·ªõc, test k·ªπ, kh√¥ng c·∫ßn rewrite to√†n b·ªô ngay

---

## üîç Quick Reference

### **Class Component Lifecycle Order**

**Mounting:**

```
constructor()
‚Üì
getDerivedStateFromProps()
‚Üì
render()
‚Üì
componentDidMount()
```

**Updating:**

```
getDerivedStateFromProps()
‚Üì
shouldComponentUpdate()
‚Üì
render()
‚Üì
getSnapshotBeforeUpdate()
‚Üì
componentDidUpdate()
```

**Unmounting:**

```
componentWillUnmount()
```

**Error:**

```
getDerivedStateFromError()
‚Üì
componentDidCatch()
```

### **Class ‚Üí Hooks Mapping**

| Class                   | Hooks                           |
| ----------------------- | ------------------------------- |
| `this.state`            | `useState()`                    |
| `this.setState()`       | `setState()` function           |
| `componentDidMount`     | `useEffect(() => {}, [])`       |
| `componentDidUpdate`    | `useEffect(() => {}, [deps])`   |
| `componentWillUnmount`  | `useEffect(() => () => {}, [])` |
| `shouldComponentUpdate` | `React.memo()`                  |
| Instance variables      | `useRef()`                      |
| `forceUpdate()`         | `useState()[1]` with counter    |

---

## üí° Pro Tips

1. **Khi refactor:**

   - B·∫Øt ƒë·∫ßu v·ªõi leaf components (kh√¥ng c√≥ children)
   - Test thoroughly sau m·ªói conversion
   - Gi·ªØ nguy√™n functionality, ƒë·ª´ng th√™m features

2. **Error Boundaries:**

   - Wrap ·ªü nhi·ªÅu levels
   - C√≥ fallback UI t·ªët
   - Log errors to service
   - Test error scenarios

3. **Performance:**

   - PureComponent cho class
   - React.memo cho function
   - Profile tr∆∞·ªõc khi optimize

4. **ƒê·ªçc legacy code:**
   - T√¨m lifecycle methods tr∆∞·ªõc
   - Map ra flow diagram
   - Identify side effects
   - Document dependencies

---

## üéÆ Mini Challenge

Tr∆∞·ªõc khi qua ng√†y 6, th·ª≠ challenges n√†y:

1. **Convert trong 5 ph√∫t:**

   ```jsx
   class Counter extends Component {
     state = { count: 0 };
     render() {
       return (
         <div>
           <p>{this.state.count}</p>
           <button
             onClick={() => this.setState({ count: this.state.count + 1 })}
           >
             +
           </button>
         </div>
       );
     }
   }
   ```

   ‚Üí Convert sang function component!

2. **Spot the bugs:**

   ```jsx
   class BuggyComponent extends Component {
     constructor(props) {
       this.state = { count: 0 };
     }

     componentDidUpdate() {
       if (this.state.count < 10) {
         this.setState({ count: this.state.count + 1 });
       }
     }

     handleClick() {
       this.setState({ count: 0 });
     }

     render() {
       return <button onClick={this.handleClick}>Reset</button>;
     }
   }
   ```

   ‚Üí T√¨m 3 bugs!

3. **Lifecycle Quiz:**
   - Component mount ‚Üí lifecycle n√†o ch·∫°y theo th·ª© t·ª±?
   - Props thay ƒë·ªïi ‚Üí lifecycle n√†o ch·∫°y?
   - Component unmount ‚Üí cleanup ·ªü ƒë√¢u?

---

**üöÄ Tu·∫ßn t·ªõi (Ng√†y 6-10):** STATE & EFFECTS - Deep dive v√†o useState, useReducer, v√† useEffect! Ph·∫ßn n√†y c·ª±c k·ª≥ quan tr·ªçng!
