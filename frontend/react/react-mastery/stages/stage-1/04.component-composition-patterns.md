# üìÖ NG√ÄY 4: Component Composition Patterns

## üéØ M·ª•c ti√™u h√¥m nay

- Master Compound Components pattern
- Hi·ªÉu v√† implement Render Props pattern
- Container/Presentational pattern
- H·ªçc c√°ch build flexible v√† reusable components
- Tr√°nh prop drilling v·ªõi composition

---

## üìö PH·∫¶N 1: THEORY (30-45 ph√∫t)

### **1.1. Compound Components Pattern**

Compound Components l√† pattern cho ph√©p nhi·ªÅu components l√†m vi·ªác c√πng nhau ƒë·ªÉ t·∫°o m·ªôt functionality ho√†n ch·ªânh.

**V√≠ d·ª• trong HTML:**

```html
<select>
  <option value="1">Option 1</option>
  <option value="2">Option 2</option>
</select>
```

`<select>` v√† `<option>` l√† compound components - ch√∫ng work together!

#### **Basic Compound Components**

```jsx
// ‚ùå C√°ch c≈©: Props hell
function Tabs({ tabs, activeTab, onTabChange }) {
  return (
    <div>
      <div className="tab-list">
        {tabs.map((tab) => (
          <button key={tab.id} onClick={() => onTabChange(tab.id)}>
            {tab.label}
          </button>
        ))}
      </div>
      <div className="tab-content">
        {tabs.find((t) => t.id === activeTab)?.content}
      </div>
    </div>
  );
}

// Usage - kh√¥ng flexible
<Tabs
  tabs={[
    { id: 1, label: "Tab 1", content: <div>Content 1</div> },
    { id: 2, label: "Tab 2", content: <div>Content 2</div> },
  ]}
  activeTab={1}
  onTabChange={handleChange}
/>;
```

```jsx
// ‚úÖ Compound Components - Flexible v√† d·ªÖ customize
function Tabs({ children, defaultActiveKey }) {
  const [activeKey, setActiveKey] = useState(defaultActiveKey);

  return (
    <div className="tabs">
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          return React.cloneElement(child, { activeKey, setActiveKey });
        }
        return child;
      })}
    </div>
  );
}

Tabs.List = function TabList({ children, activeKey, setActiveKey }) {
  return (
    <div className="tab-list">
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          return React.cloneElement(child, { activeKey, setActiveKey });
        }
        return child;
      })}
    </div>
  );
};

Tabs.Tab = function Tab({ children, eventKey, activeKey, setActiveKey }) {
  const isActive = eventKey === activeKey;

  return (
    <button
      className={`tab ${isActive ? "active" : ""}`}
      onClick={() => setActiveKey(eventKey)}
    >
      {children}
    </button>
  );
};

Tabs.Panels = function TabPanels({ children, activeKey }) {
  return (
    <div className="tab-panels">
      {React.Children.map(children, (child) => {
        if (React.isValidElement(child)) {
          return React.cloneElement(child, { activeKey });
        }
        return child;
      })}
    </div>
  );
};

Tabs.Panel = function TabPanel({ children, eventKey, activeKey }) {
  if (eventKey !== activeKey) return null;

  return <div className="tab-panel">{children}</div>;
};

// Usage - Flexible v√† expressive!
<Tabs defaultActiveKey="profile">
  <Tabs.List>
    <Tabs.Tab eventKey="profile">Profile</Tabs.Tab>
    <Tabs.Tab eventKey="settings">Settings</Tabs.Tab>
    <Tabs.Tab eventKey="messages">Messages</Tabs.Tab>
  </Tabs.List>

  <Tabs.Panels>
    <Tabs.Panel eventKey="profile">
      <h2>Profile Content</h2>
      <p>Your profile information here...</p>
    </Tabs.Panel>

    <Tabs.Panel eventKey="settings">
      <h2>Settings Content</h2>
      <p>Your settings here...</p>
    </Tabs.Panel>

    <Tabs.Panel eventKey="messages">
      <h2>Messages Content</h2>
      <p>Your messages here...</p>
    </Tabs.Panel>
  </Tabs.Panels>
</Tabs>;
```

#### **Compound Components v·ªõi Context (Modern approach)**

```jsx
import { createContext, useContext, useState } from "react";

// 1. Create context
const AccordionContext = createContext();

// 2. Main component
function Accordion({ children, defaultOpenItems = [] }) {
  const [openItems, setOpenItems] = useState(defaultOpenItems);

  const toggleItem = (id) => {
    setOpenItems((prev) =>
      prev.includes(id) ? prev.filter((item) => item !== id) : [...prev, id]
    );
  };

  return (
    <AccordionContext.Provider value={{ openItems, toggleItem }}>
      <div className="accordion">{children}</div>
    </AccordionContext.Provider>
  );
}

// 3. Sub-components
Accordion.Item = function AccordionItem({ children, id }) {
  return (
    <div className="accordion-item" data-id={id}>
      {children}
    </div>
  );
};

Accordion.Header = function AccordionHeader({ children, id }) {
  const { openItems, toggleItem } = useContext(AccordionContext);
  const isOpen = openItems.includes(id);

  return (
    <button className="accordion-header" onClick={() => toggleItem(id)}>
      {children}
      <span>{isOpen ? "‚ñ≤" : "‚ñº"}</span>
    </button>
  );
};

Accordion.Content = function AccordionContent({ children, id }) {
  const { openItems } = useContext(AccordionContext);
  const isOpen = openItems.includes(id);

  if (!isOpen) return null;

  return <div className="accordion-content">{children}</div>;
};

// Usage
<Accordion defaultOpenItems={["item1"]}>
  <Accordion.Item id="item1">
    <Accordion.Header id="item1">What is React?</Accordion.Header>
    <Accordion.Content id="item1">
      React is a JavaScript library for building user interfaces.
    </Accordion.Content>
  </Accordion.Item>

  <Accordion.Item id="item2">
    <Accordion.Header id="item2">What is JSX?</Accordion.Header>
    <Accordion.Content id="item2">
      JSX is a syntax extension for JavaScript.
    </Accordion.Content>
  </Accordion.Item>
</Accordion>;
```

**∆Øu ƒëi·ªÉm Compound Components:**

- ‚úÖ Flexible - customize d·ªÖ d√†ng
- ‚úÖ Expressive API - ƒë·ªçc nh∆∞ HTML
- ‚úÖ No prop drilling
- ‚úÖ Separation of concerns
- ‚úÖ Easy to extend

---

### **1.2. Render Props Pattern**

Render Props l√† technique ƒë·ªÉ share code gi·ªØa components b·∫±ng c√°ch d√πng prop c√≥ gi√° tr·ªã l√† function.

#### **Basic Render Props**

```jsx
// Component v·ªõi render prop
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  const handleMouseMove = (e) => {
    setPosition({ x: e.clientX, y: e.clientY });
  };

  return (
    <div style={{ height: "100vh" }} onMouseMove={handleMouseMove}>
      {render(position)}
    </div>
  );
}

// Usage
<MouseTracker
  render={({ x, y }) => (
    <div>
      <h2>Mouse Position</h2>
      <p>
        X: {x}, Y: {y}
      </p>
    </div>
  )}
/>;
```

#### **Children as Function (Render Props variant)**

```jsx
function DataFetcher({ url, children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, [url]);

  return children({ data, loading, error });
}

// Usage
<DataFetcher url="/api/users">
  {({ data, loading, error }) => {
    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;
    return (
      <ul>
        {data.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    );
  }}
</DataFetcher>;
```

#### **Practical Example: Toggle Component**

```jsx
function Toggle({ children, defaultOn = false }) {
  const [on, setOn] = useState(defaultOn);

  const toggle = () => setOn(prev => !prev);
  const setOff = () => setOn(false);
  const setOn = () => setOn(true);

  return children({
    on,
    toggle,
    setOff,
    setOn
  });
}

// Usage 1: Modal
<Toggle>
  {({ on, toggle, setOff }) => (
    <div>
      <button onClick={toggle}>Open Modal</button>
      {on && (
        <div className="modal">
          <h2>Modal Content</h2>
          <button onClick={setOff}>Close</button>
        </div>
      )}
    </div>
  )}
</Toggle>

// Usage 2: Dropdown
<Toggle>
  {({ on, toggle }) => (
    <div className="dropdown">
      <button onClick={toggle}>
        Menu {on ? '‚ñ≤' : '‚ñº'}
      </button>
      {on && (
        <ul className="dropdown-menu">
          <li>Item 1</li>
          <li>Item 2</li>
          <li>Item 3</li>
        </ul>
      )}
    </div>
  )}
</Toggle>

// Usage 3: Theme Switcher
<Toggle defaultOn={false}>
  {({ on, toggle }) => (
    <div className={on ? 'dark-theme' : 'light-theme'}>
      <button onClick={toggle}>
        {on ? 'üåô Dark' : '‚òÄÔ∏è Light'}
      </button>
      <p>Content here...</p>
    </div>
  )}
</Toggle>
```

**∆Øu ƒëi·ªÉm Render Props:**

- ‚úÖ Highly flexible
- ‚úÖ Reuse logic across components
- ‚úÖ Control rendering t·ª´ parent
- ‚úÖ No naming collision

**Nh∆∞·ª£c ƒëi·ªÉm:**

- ‚ùå "Callback hell" n·∫øu nest nhi·ªÅu
- ‚ùå Code kh√≥ ƒë·ªçc h∆°n compound components

---

### **1.3. Container/Presentational Pattern**

T√°ch logic (Container) v√† UI (Presentational) ra ri√™ng.

#### **Presentational Component (Dumb/Stateless)**

```jsx
// Ch·ªâ nh·∫≠n props v√† render UI
function UserList({ users, onUserClick, loading }) {
  if (loading) {
    return <div>Loading users...</div>;
  }

  return (
    <ul className="user-list">
      {users.map((user) => (
        <li key={user.id} onClick={() => onUserClick(user)}>
          <img src={user.avatar} alt={user.name} />
          <span>{user.name}</span>
        </li>
      ))}
    </ul>
  );
}
```

#### **Container Component (Smart/Stateful)**

```jsx
// Ch·ª©a logic, state, side effects
function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUsers().then((data) => {
      setUsers(data);
      setLoading(false);
    });
  }, []);

  const handleUserClick = (user) => {
    console.log("User clicked:", user);
    // Navigate, open modal, etc.
  };

  // Render presentational component
  return (
    <UserList users={users} loading={loading} onUserClick={handleUserClick} />
  );
}
```

#### **Full Example: Todo App**

```jsx
// Presentational - TodoList.jsx
function TodoList({ todos, onToggle, onDelete }) {
  return (
    <ul>
      {todos.map((todo) => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={onToggle}
          onDelete={onDelete}
        />
      ))}
    </ul>
  );
}

// Presentational - TodoItem.jsx
function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <li className={todo.completed ? "completed" : ""}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      <span>{todo.text}</span>
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </li>
  );
}

// Presentational - TodoForm.jsx
function TodoForm({ onSubmit }) {
  const [text, setText] = useState("");

  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      onSubmit(text);
      setText("");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add todo..."
      />
      <button type="submit">Add</button>
    </form>
  );
}

// Container - TodoApp.jsx
function TodoApp() {
  const [todos, setTodos] = useState([]);

  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text, completed: false }]);
  };

  const toggleTodo = (id) => {
    setTodos(
      todos.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter((todo) => todo.id !== id));
  };

  return (
    <div className="todo-app">
      <h1>Todo App</h1>
      <TodoForm onSubmit={addTodo} />
      <TodoList todos={todos} onToggle={toggleTodo} onDelete={deleteTodo} />
    </div>
  );
}
```

**∆Øu ƒëi·ªÉm:**

- ‚úÖ Separation of concerns
- ‚úÖ Presentational components d·ªÖ test
- ‚úÖ Reusability cao
- ‚úÖ Code d·ªÖ maintain

---

### **1.4. Solving Prop Drilling v·ªõi Composition**

#### **Problem: Prop Drilling**

```jsx
// ‚ùå Prop drilling through many levels
function App() {
  const user = { name: "John", avatar: "..." };
  return <Dashboard user={user} />;
}

function Dashboard({ user }) {
  return (
    <div>
      <Sidebar user={user} />
      <MainContent user={user} />
    </div>
  );
}

function Sidebar({ user }) {
  return (
    <div>
      <Navigation user={user} />
    </div>
  );
}

function Navigation({ user }) {
  return <UserMenu user={user} />;
}

function UserMenu({ user }) {
  return <div>Hello, {user.name}</div>;
}
```

#### **Solution 1: Component Composition**

```jsx
// ‚úÖ No prop drilling
function App() {
  const user = { name: "John", avatar: "..." };

  return (
    <Dashboard
      sidebar={
        <Sidebar>
          <Navigation>
            <UserMenu user={user} />
          </Navigation>
        </Sidebar>
      }
      content={<MainContent />}
    />
  );
}

function Dashboard({ sidebar, content }) {
  return (
    <div className="dashboard">
      {sidebar}
      {content}
    </div>
  );
}

function Sidebar({ children }) {
  return <aside>{children}</aside>;
}

function Navigation({ children }) {
  return <nav>{children}</nav>;
}

function UserMenu({ user }) {
  return <div>Hello, {user.name}</div>;
}
```

#### **Solution 2: Inversion of Control**

```jsx
// ‚úÖ Parent controls what to render
function App() {
  const user = { name: "John", avatar: "..." };

  return (
    <Dashboard>
      <Sidebar>
        <Navigation>
          <UserMenu user={user} />
        </Navigation>
      </Sidebar>
      <MainContent />
    </Dashboard>
  );
}

function Dashboard({ children }) {
  return <div className="dashboard">{children}</div>;
}

function Sidebar({ children }) {
  return <aside className="sidebar">{children}</aside>;
}

function Navigation({ children }) {
  return <nav className="navigation">{children}</nav>;
}
```

---

## üíª PH·∫¶N 2: CODE DEMO (30-45 ph√∫t)

### **Demo 1: Dropdown v·ªõi Compound Components**

```jsx
import { createContext, useContext, useState, useRef, useEffect } from "react";

const DropdownContext = createContext();

function Dropdown({ children }) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  // Close on outside click
  useEffect(() => {
    const handleClickOutside = (e) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
        setIsOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const toggle = () => setIsOpen((prev) => !prev);
  const close = () => setIsOpen(false);

  return (
    <DropdownContext.Provider value={{ isOpen, toggle, close }}>
      <div className="dropdown" ref={dropdownRef}>
        {children}
      </div>
    </DropdownContext.Provider>
  );
}

Dropdown.Toggle = function DropdownToggle({ children }) {
  const { toggle } = useContext(DropdownContext);

  return (
    <button className="dropdown-toggle" onClick={toggle}>
      {children}
    </button>
  );
};

Dropdown.Menu = function DropdownMenu({ children }) {
  const { isOpen } = useContext(DropdownContext);

  if (!isOpen) return null;

  return <div className="dropdown-menu">{children}</div>;
};

Dropdown.Item = function DropdownItem({ children, onClick }) {
  const { close } = useContext(DropdownContext);

  const handleClick = () => {
    onClick?.();
    close();
  };

  return (
    <button className="dropdown-item" onClick={handleClick}>
      {children}
    </button>
  );
};

// Usage
function App() {
  return (
    <Dropdown>
      <Dropdown.Toggle>Actions ‚ñº</Dropdown.Toggle>

      <Dropdown.Menu>
        <Dropdown.Item onClick={() => console.log("Edit")}>
          ‚úèÔ∏è Edit
        </Dropdown.Item>
        <Dropdown.Item onClick={() => console.log("Delete")}>
          üóëÔ∏è Delete
        </Dropdown.Item>
        <Dropdown.Item onClick={() => console.log("Share")}>
          üì§ Share
        </Dropdown.Item>
      </Dropdown.Menu>
    </Dropdown>
  );
}
```

### **Demo 2: Modal v·ªõi Render Props**

```jsx
function Modal({ children, trigger }) {
  const [isOpen, setIsOpen] = useState(false);

  const open = () => setIsOpen(true);
  const close = () => setIsOpen(false);

  return (
    <>
      {trigger({ open })}

      {isOpen && (
        <>
          <div className="modal-backdrop" onClick={close} />
          <div className="modal">{children({ close })}</div>
        </>
      )}
    </>
  );
}

// Usage
<Modal trigger={({ open }) => <button onClick={open}>Open Modal</button>}>
  {({ close }) => (
    <div>
      <h2>Modal Title</h2>
      <p>Modal content here...</p>
      <button onClick={close}>Close</button>
    </div>
  )}
</Modal>;
```

### **Demo 3: Data Table v·ªõi Container/Presentational**

```jsx
// Presentational
function Table({ columns, data, onSort, sortConfig }) {
  return (
    <table>
      <thead>
        <tr>
          {columns.map((col) => (
            <th key={col.key} onClick={() => onSort(col.key)}>
              {col.label}
              {sortConfig.key === col.key && (
                <span>{sortConfig.direction === "asc" ? " ‚ñ≤" : " ‚ñº"}</span>
              )}
            </th>
          ))}
        </tr>
      </thead>
      <tbody>
        {data.map((row, idx) => (
          <tr key={idx}>
            {columns.map((col) => (
              <td key={col.key}>
                {col.render ? col.render(row[col.key], row) : row[col.key]}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}

// Container
function DataTable({ data: initialData, columns }) {
  const [data, setData] = useState(initialData);
  const [sortConfig, setSortConfig] = useState({ key: null, direction: "asc" });

  const handleSort = (key) => {
    let direction = "asc";
    if (sortConfig.key === key && sortConfig.direction === "asc") {
      direction = "desc";
    }

    const sortedData = [...data].sort((a, b) => {
      if (a[key] < b[key]) return direction === "asc" ? -1 : 1;
      if (a[key] > b[key]) return direction === "asc" ? 1 : -1;
      return 0;
    });

    setData(sortedData);
    setSortConfig({ key, direction });
  };

  return (
    <Table
      columns={columns}
      data={data}
      onSort={handleSort}
      sortConfig={sortConfig}
    />
  );
}

// Usage
const columns = [
  { key: "name", label: "Name" },
  { key: "age", label: "Age" },
  {
    key: "status",
    label: "Status",
    render: (value) => <span className={`badge ${value}`}>{value}</span>,
  },
];

const users = [
  { name: "John", age: 30, status: "active" },
  { name: "Jane", age: 25, status: "inactive" },
  { name: "Bob", age: 35, status: "active" },
];

<DataTable columns={columns} data={users} />;
```

---

## üî® PH·∫¶N 3: TH·ª∞C H√ÄNH (60-90 ph√∫t)

### **Exercise 1: Alert/Toast System (Compound Components)**

```jsx
// TODO: Implement compound components Alert system

// Alert.jsx
function Alert({ children, variant = 'info', dismissible = false }) {
  // TODO:
  // - Context ƒë·ªÉ share state
  // - Auto dismiss sau X seconds (optional)
  // - Variants: info, success, warning, error
}

Alert.Icon = function AlertIcon({ children }) {
  // TODO: Render icon based on variant from context
}

Alert.Title = function AlertTitle({ children }) {
  // TODO: Render title
}

Alert.Description = function AlertDescription({ children }) {
  // TODO: Render description
}

Alert.CloseButton = function AlertCloseButton() {
  // TODO: Dismiss button
}

// Usage
<Alert variant="success" dismissible>
  <Alert.Icon />
  <div>
    <Alert.Title>Success!</Alert.Title>
    <Alert.Description>
      Your changes have been saved.
    </Alert.Description>
  </div>
  <Alert.CloseButton />
</Alert>
```

### **Exercise 2: Wizard/Stepper (Compound Components)**

```jsx
// TODO: Multi-step form wizard

function Wizard({ children, onComplete }) {
  // TODO:
  // - Track current step
  // - Navigation (next, prev, jump to step)
  // - Validation before next
  // - Progress indicator
}

Wizard.Steps = function WizardSteps({ children }) {
  // TODO: Render step indicators
}

Wizard.Step = function WizardStep({ children, stepId, title }) {
  // TODO: Individual step indicator
}

Wizard.Panels = function WizardPanels({ children }) {
  // TODO: Container for panels
}

Wizard.Panel = function WizardPanel({ children, stepId }) {
  // TODO: Content for each step
}

Wizard.Navigation = function WizardNavigation() {
  // TODO: Previous, Next, Submit buttons
}

// Usage
<Wizard onComplete={handleComplete}>
  <Wizard.Steps>
    <Wizard.Step stepId={1} title="Account" />
    <Wizard.Step stepId={2} title="Profile" />
    <Wizard.Step stepId={3} title="Review" />
  </Wizard.Steps>

  <Wizard.Panels>
    <Wizard.Panel stepId={1}>
      <h2>Account Information</h2>
      {/* Form fields */}
    </Wizard.Panel>

    <Wizard.Panel stepId={2}>
      <h2>Profile Details</h2>
      {/* Form fields */}
    </Wizard.Panel>

    <Wizard.Panel stepId={3}>
      <h2>Review & Submit</h2>
      {/* Summary */}
    </Wizard.Panel>
  </Wizard.Panels>

  <Wizard.Navigation />
</Wizard>
```

### **Exercise 3: Data Fetcher (Render Props)**

```jsx
// TODO: Reusable data fetching component

function DataFetcher({ url, children, method = 'GET', body }) {
  // TODO:
  // - Fetch data from URL
  // - Handle loading, error, success states
  // - Retry functionality
  // - Cache (optional)
  // Pass { data, loading, error, retry } to children
}

// Usage 1: User List
<DataFetcher url="/api/users">
  {({ data, loading, error, retry }) => {
    if (loading) return <Spinner />;
    if (error) return (
      <div>
        <p>Error: {error.message}</p>
        <button onClick={retry}>Retry</button>
      </div>
    );
    return <UserList users={data} />;
  }}
</DataFetcher>

// Usage 2: Product Details
<DataFetcher url="/api/products/123">
  {({ data: product, loading }) => {
    if (loading) return <Skeleton />;
    return <ProductCard product={product} />;
  }}
</DataFetcher>
```

### **Exercise 4: Form Builder (Mixed Patterns - Challenge)**

```jsx
// TODO: Flexible form builder v·ªõi compound components + render props

// H√†m validate m·ªôt field
// C·∫•u tr√∫c c√°c rules
// {
//   required: <true | string>,               // B·∫Øt bu·ªôc nh·∫≠p hay kh√¥ng (c√≥ th·ªÉ l√† chu·ªói th√¥ng b√°o l·ªói)
//   minLength: <s·ªë>,                         // ƒê·ªô d√†i t·ªëi thi·ªÉu
//   maxLength: <s·ªë>,                         // ƒê·ªô d√†i t·ªëi ƒëa
//   pattern: <RegExp | { value: <RegExp>, message: <string> }> // Ki·ªÉm tra ƒë·ªãnh d·∫°ng (pattern l√† m·ªôt RegExp ho·∫∑c object v·ªõi value v√† message),
//   validate: <h√†m t√πy ch·ªânh(value, formData) => string | null>  // H√†m ki·ªÉm tra tu·ª≥ ch·ªânh
// }

function Form({ onSubmit, children }) {
  // TODO:
  // - Form state management
  // - Validation
  // - Error handling
  // - Submit handling
}

Form.Field = function FormField({ name, label, rules, children }) {
  // TODO:
  // - Register field
  // - Validation
  // - Error display
  // Use render props pattern
}

Form.Input = function FormInput({ name, ...props }) {
  // TODO: Controlled input
}

Form.Select = function FormSelect({ name, options, ...props }) {
  // TODO: Controlled select
}

Form.Checkbox = function FormCheckbox({ name, label, ...props }) {
  // TODO: Controlled checkbox
}

Form.Submit = function FormSubmit({ children, loading }) {
  // TODO: Submit button v·ªõi loading state
}

Form.Reset = function FormReset({ children }) {
  // TODO: Reset form
}

// Usage
<Form onSubmit={handleSubmit}>
  <Form.Field
    name="email"
    label="Email"
    rules={{ required: true, pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ }}
  >
    {({ value, onChange, error }) => (
      <>
        <Form.Input
          name="email"
          type="email"
          value={value}
          onChange={onChange}
        />
        {error && <span className="error">{error}</span>}
      </>
    )}
  </Form.Field>

  <Form.Field name="country" label="Country">
    {({ value, onChange }) => (
      <Form.Select
        name="country"
        value={value}
        onChange={onChange}
        options={countries}
      />
    )}
  </Form.Field>

  <Form.Field name="terms">
    {({ value, onChange }) => (
      <Form.Checkbox
        name="terms"
        checked={value}
        onChange={onChange}
        label="I agree to terms"
      />
    )}
  </Form.Field>

  <Form.Submit>Submit</Form.Submit>
  <Form.Reset>Reset</Form.Reset>
</Form>
```

### **Exercise 5: Infinite Scroll List (Container/Presentational)**

```jsx
// TODO: Presentational Component
function List({ items, loading, hasMore, observerRef }) {
  // TODO:
  // - Render items
  // - Loading indicator
  // - Observer element for intersection
}

// TODO: Container Component
function InfiniteScrollList({ fetchItems, initialItems = [] }) {
  // TODO:
  // - Manage items state
  // - Intersection Observer setup
  // - Load more when reaching bottom
  // - Handle loading state

  return (
    <List
      items={items}
      loading={loading}
      hasMore={hasMore}
      observerRef={observerRef}
    />
  );
}

// Usage
<InfiniteScrollList fetchItems={(page) => fetch(`/api/items?page=${page}`)} />;
```

---

#### ‚úÖ PH·∫¶N 4: REVIEW & CHECKLIST (15-30 ph√∫t)

### **Compound Components:**

- [ ] Hi·ªÉu compound components pattern
- [ ] D√πng React.Children API
- [ ] D√πng Context ƒë·ªÉ share state
- [ ] T·∫°o flexible v√† expressive APIs
- [ ] Sub-components (Tabs.List, Tabs.Tab)
- [ ] Clone elements v√† pass props

### **Render Props:**

- [ ] Hi·ªÉu render props pattern
- [ ] Children as function
- [ ] Pass data v√† methods qua function
- [ ] Use cases: data fetching, toggle, mouse tracking
- [ ] Tr√°nh callback hell

### **Container/Presentational:**

- [ ] T√°ch logic v√† UI
- [ ] Smart vs Dumb components
- [ ] Presentational components d·ªÖ test
- [ ] Container ch·ª©a state v√† side effects
- [ ] Reusability v√† maintainability

### **Composition:**

- [ ] Solve prop drilling
- [ ] Inversion of control
- [ ] Component composition
- [ ] Flexibility qua children prop

### **Common Mistakes:**

```jsx
// ‚ùå Compound Components kh√¥ng share state
function Tabs({ children }) {
  return <div>{children}</div>;
}
// Sub-components kh√¥ng bi·∫øt active tab

// ‚ùå Render Props qu√° nhi·ªÅu tham s·ªë
<Component>
  {(a, b, c, d, e, f, g) => ...} // Too many!
</Component>

// ‚ùå Container c√≥ UI logic
function UserContainer() {
  const [users, setUsers] = useState([]);
  return (
    <div className="fancy-container"> {/* ‚ùå UI in container */}
      <h1>Users</h1> {/* ‚ùå */}
      <UserList users={users} />
    </div>
  );
}

// ‚úÖ ƒê√öNG - Context cho Compound Components
const TabContext = createContext();

function Tabs({ children }) {
  const [active, setActive] = useState(0);
  return (
    <TabContext.Provider value={{ active, setActive }}>
      {children}
    </TabContext.Provider>
  );
}

// ‚úÖ ƒê√öNG - Render Props v·ªõi object
<Component>
  {({ data, loading, error, actions }) => ...}
</Component>

// ‚úÖ ƒê√öNG - Container ch·ªâ logic
function UserContainer() {
  const [users, setUsers] = useState([]);
  const handleAdd = () => {...};

  return <UserList users={users} onAdd={handleAdd} />;
}
```

---

## üéØ HOMEWORK

### **1. Card Component System**

T·∫°o flexible card system:

```jsx
<Card variant="elevated">
  <Card.Image src="..." alt="..." />
  <Card.Header>
    <Card.Title>Title</Card.Title>
    <Card.Subtitle>Subtitle</Card.Subtitle>
  </Card.Header>
  <Card.Body>Content here</Card.Body>
  <Card.Footer>
    <Card.Actions>
      <Button>Action 1</Button>
      <Button>Action 2</Button>
    </Card.Actions>
  </Card.Footer>
</Card>
```

Features:

- Variants: default, elevated, outlined
- Optional sections
- Flexible layout
- Responsive

### **2. Pagination Component (Render Props)**

```jsx
<Pagination totalItems={1000} itemsPerPage={20} initialPage={1}>
  {({ currentPage, totalPages, nextPage, prevPage, goToPage, items }) => (
    <div>
      <ItemList items={items} />
      <PaginationControls
        current={currentPage}
        total={totalPages}
        onNext={nextPage}
        onPrev={prevPage}
        onPageClick={goToPage}
      />
    </div>
  )}
</Pagination>
```

Features:

- Page navigation
- Items calculation
- Boundary handling
- Custom rendering

### **3. Search Component (Container/Presentational)**

**Container:**

```jsx
function SearchContainer({ onSearch, debounceMs = 300 }) {
  // TODO:
  // - Search state
  // - Debounce input
  // - Loading state
  // - Results fetching
  // - Clear search
}
```

**Presentational:**

```jsx
function SearchView({
  query,
  onChange,
  onClear,
  results,
  loading,
  onResultClick,
}) {
  // TODO:
  // - Search input
  // - Clear button
  // - Loading indicator
  // - Results list
  // - Empty state
}
```

### **4. Advanced Menu System (Mixed Patterns)**

Combine compound components + render props:

```jsx
<Menu>
  <Menu.Trigger>
    {({ open, toggle }) => (
      <button onClick={toggle}>Menu {open ? "‚ñ≤" : "‚ñº"}</button>
    )}
  </Menu.Trigger>

  <Menu.Items>
    <Menu.Item icon="üë§">Profile</Menu.Item>

    <Menu.Submenu label="Settings">
      <Menu.Item icon="üîî">Notifications</Menu.Item>
      <Menu.Item icon="üîí">Privacy</Menu.Item>
    </Menu.Submenu>

    <Menu.Divider />

    <Menu.Item icon="üö™" variant="danger">
      Logout
    </Menu.Item>
  </Menu.Items>
</Menu>
```

Features:

- Nested menus
- Keyboard navigation
- Click outside to close
- Custom trigger
- Icons support

### **5. Filter Builder (Challenge)**

Complex filtering system:

```jsx
<FilterBuilder onChange={handleFilterChange}>
  {({ filters, addFilter, removeFilter, updateFilter }) => (
    <>
      <FilterBuilder.Controls>
        <button onClick={addFilter}>Add Filter</button>
      </FilterBuilder.Controls>

      <FilterBuilder.Filters>
        {filters.map((filter) => (
          <FilterBuilder.Filter key={filter.id} filterId={filter.id}>
            <FilterBuilder.Field
              value={filter.field}
              options={["name", "age", "status"]}
              onChange={(field) => updateFilter(filter.id, { field })}
            />

            <FilterBuilder.Operator
              value={filter.operator}
              options={getOperators(filter.field)}
              onChange={(operator) => updateFilter(filter.id, { operator })}
            />

            <FilterBuilder.Value
              type={getValueType(filter.field)}
              value={filter.value}
              onChange={(value) => updateFilter(filter.id, { value })}
            />

            <button onClick={() => removeFilter(filter.id)}>√ó</button>
          </FilterBuilder.Filter>
        ))}
      </FilterBuilder.Filters>

      <FilterBuilder.Preview>
        {({ query }) => <pre>{JSON.stringify(query, null, 2)}</pre>}
      </FilterBuilder.Preview>
    </>
  )}
</FilterBuilder>
```

Features:

- Dynamic filters
- Different field types
- Operator based on field type
- Query preview
- Add/remove filters

---

## üìö Additional Resources

### **ƒê·ªçc th√™m:**

- [React Docs - Composition vs Inheritance](https://react.dev/learn/composition-vs-inheritance)
- [Kent C. Dodds - Compound Components](https://kentcdodds.com/blog/compound-components-with-react-hooks)
- [Michael Jackson - Never Write Another HoC](https://www.youtube.com/watch?v=BcVAq3YFiuc) (v·ªÅ Render Props)
- [Dan Abramov - Presentational and Container Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)

### **Real-world Examples:**

- **Radix UI**: Master c·ªßa compound components pattern
- **Headless UI**: Render props + compound components
- **React Table**: Flexible API v·ªõi render props
- **Reach UI**: Accessibility-first compound components

---

## üé® Pattern Selection Guide

**Khi n√†o d√πng Compound Components?**

- ‚úÖ C·∫ßn flexible v√† customizable API
- ‚úÖ Components work together nh∆∞ m·ªôt system
- ‚úÖ User c·∫ßn control layout v√† structure
- ‚úÖ Examples: Tabs, Accordion, Dropdown, Menu

**Khi n√†o d√πng Render Props?**

- ‚úÖ Share logic, not UI
- ‚úÖ User c·∫ßn full control rendering
- ‚úÖ Data fetching, animation, form state
- ‚úÖ Examples: MouseTracker, DataFetcher, Toggle

**Khi n√†o d√πng Container/Presentational?**

- ‚úÖ Clear separation of concerns
- ‚úÖ Testability quan tr·ªçng
- ‚úÖ Reusable presentational components
- ‚úÖ Examples: Lists, Forms, Charts

**Modern Trend:**

- Custom Hooks ƒëang thay th·∫ø nhi·ªÅu patterns n√†y
- Nh∆∞ng patterns n√†y v·∫´n valuable cho component libraries
- Hi·ªÉu patterns gi√∫p ƒë·ªçc code legacy v√† third-party libs

---

## üìù Key Takeaways

1. **Compound Components**: Best cho component systems c·∫ßn flexibility
2. **Render Props**: Powerful cho logic sharing
3. **Container/Presentational**: Clean architecture cho maintainability
4. **Composition > Inheritance**: React way of building UIs
5. **Flexibility vs Simplicity**: Balance d·ª±a tr√™n use case

---

## üîç Mini Quiz

Tr∆∞·ªõc khi qua ng√†y 5, test yourself:

1. Khi n√†o n√™n d√πng Compound Components thay v√¨ single component v·ªõi nhi·ªÅu props?
2. S·ª± kh√°c bi·ªát gi·ªØa Render Props v√† Children as Function?
3. Container component n√™n ch·ª©a g√¨? Presentational component n√™n ch·ª©a g√¨?
4. L√†m th·∫ø n√†o ƒë·ªÉ avoid prop drilling m√† kh√¥ng d√πng Context?
5. Trade-offs gi·ªØa flexibility v√† simplicity?

---

**üöÄ Ng√†y mai:** Class Components (Legacy) - H·ªçc ƒë·ªÉ ƒë·ªçc code c≈©, lifecycle methods, v√† migration strategies!
