# üìÖ NG√ÄY 6: useState Mastery

## üéØ M·ª•c ti√™u h√¥m nay

- Hi·ªÉu s√¢u v·ªÅ useState hook
- Lazy initialization
- Functional updates
- State immutability
- Best practices v√† patterns
- Tr√°nh nh·ªØng l·ªói ph·ªï bi·∫øn

---

## üìö PH·∫¶N 1: L√ù THUY·∫æT (30-45 ph√∫t)

### **1.1. useState C∆° B·∫£n**

#### **Syntax v√† C√°ch D√πng**

```jsx
import { useState } from "react";

function Counter() {
  // [state, setState] = useState(initialValue)
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

**Gi·∫£i th√≠ch:**

- `useState(0)` - kh·ªüi t·∫°o state v·ªõi gi√° tr·ªã 0
- Tr·∫£ v·ªÅ array v·ªõi 2 elements: `[gi√° tr·ªã hi·ªán t·∫°i, h√†m ƒë·ªÉ update]`
- Destructuring ƒë·ªÉ l·∫•y ra: `const [count, setCount] = ...`
- Naming convention: `[thing, setThing]`

#### **Multiple State Variables**

```jsx
function UserProfile() {
  const [name, setName] = useState("");
  const [age, setAge] = useState(0);
  const [email, setEmail] = useState("");
  const [isActive, setIsActive] = useState(true);

  return (
    <div>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <input
        type="number"
        value={age}
        onChange={(e) => setAge(e.target.value)}
      />
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <input
        type="checkbox"
        checked={isActive}
        onChange={(e) => setIsActive(e.target.checked)}
      />
    </div>
  );
}
```

**‚ö†Ô∏è Quy t·∫Øc quan tr·ªçng:**

- Hooks ph·∫£i ·ªü top level c·ªßa component
- Kh√¥ng ƒë∆∞·ª£c trong if/loop/nested function
- Th·ª© t·ª± hooks ph·∫£i gi·ªëng nhau m·ªói l·∫ßn render

```jsx
// ‚ùå SAI - Trong ƒëi·ªÅu ki·ªán
function BadComponent() {
  if (someCondition) {
    const [count, setCount] = useState(0); // ‚ùå L·ªói!
  }
}

// ‚ùå SAI - Trong loop
function BadComponent() {
  for (let i = 0; i < 5; i++) {
    const [count, setCount] = useState(0); // ‚ùå L·ªói!
  }
}

// ‚úÖ ƒê√öNG - Top level
function GoodComponent() {
  const [count, setCount] = useState(0);

  if (someCondition) {
    // D√πng count ·ªü ƒë√¢y OK
  }
}
```

---

### **1.2. C√°c Ki·ªÉu D·ªØ Li·ªáu State**

#### **Primitives (Number, String, Boolean)**

```jsx
function Examples() {
  const [count, setCount] = useState(0); // Number
  const [text, setText] = useState(""); // String
  const [isOpen, setIsOpen] = useState(false); // Boolean
  const [user, setUser] = useState(null); // Null
  const [data, setData] = useState(undefined); // Undefined

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setIsOpen(!isOpen)}>
        {isOpen ? "ƒê√≥ng" : "M·ªü"}
      </button>
    </div>
  );
}
```

#### **Objects**

```jsx
function UserForm() {
  const [user, setUser] = useState({
    name: "",
    email: "",
    age: 0,
  });

  // ‚ùå SAI - Mutation tr·ª±c ti·∫øp
  const updateNameWrong = (newName) => {
    user.name = newName; // ‚ùå Kh√¥ng trigger re-render!
    setUser(user);
  };

  // ‚úÖ ƒê√öNG - T·∫°o object m·ªõi
  const updateName = (newName) => {
    setUser({
      ...user, // Spread existing properties
      name: newName, // Override name
    });
  };

  // ‚úÖ ƒê√öNG - Update nhi·ªÅu fields
  const updateUser = (updates) => {
    setUser({
      ...user,
      ...updates,
    });
  };

  return (
    <div>
      <input
        value={user.name}
        onChange={(e) => setUser({ ...user, name: e.target.value })}
        placeholder="T√™n"
      />
      <input
        value={user.email}
        onChange={(e) => setUser({ ...user, email: e.target.value })}
        placeholder="Email"
      />
      <input
        type="number"
        value={user.age}
        onChange={(e) => setUser({ ...user, age: parseInt(e.target.value) })}
        placeholder="Tu·ªïi"
      />
    </div>
  );
}
```

#### **Arrays**

```jsx
function TodoList() {
  const [todos, setTodos] = useState([]);

  // ‚úÖ Th√™m item m·ªõi
  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text, completed: false }]);
    // Ho·∫∑c: setTodos(todos.concat({ id: Date.now(), text, completed: false }));
  };

  // ‚úÖ X√≥a item
  const deleteTodo = (id) => {
    setTodos(todos.filter((todo) => todo.id !== id));
  };

  // ‚úÖ Update item
  const toggleTodo = (id) => {
    setTodos(
      todos.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  };

  // ‚úÖ Insert v√†o v·ªã tr√≠ c·ª• th·ªÉ
  const insertAt = (index, item) => {
    setTodos([...todos.slice(0, index), item, ...todos.slice(index)]);
  };

  // ‚úÖ Sort
  const sortTodos = () => {
    setTodos([...todos].sort((a, b) => a.text.localeCompare(b.text)));
  };

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleTodo(todo.id)}
          />
          {todo.text}
          <button onClick={() => deleteTodo(todo.id)}>X√≥a</button>
        </li>
      ))}
    </ul>
  );
}
```

**‚ö†Ô∏è Array Methods - Mutating vs Non-mutating:**

```jsx
// ‚ùå Mutating (KH√îNG d√πng v·ªõi setState)
push()      // Th√™m v√†o cu·ªëi
pop()       // X√≥a cu·ªëi
shift()     // X√≥a ƒë·∫ßu
unshift()   // Th√™m v√†o ƒë·∫ßu
splice()    // X√≥a/th√™m t·∫°i v·ªã tr√≠
sort()      // S·∫Øp x·∫øp
reverse()   // ƒê·∫£o ng∆∞·ª£c

// ‚úÖ Non-mutating (AN TO√ÄN)
concat()    // N·ªëi arrays
slice()     // Copy m·ªôt ph·∫ßn
filter()    // L·ªçc
map()       // Transform
spread [...]// Copy array
```

---

### **1.3. Lazy Initialization**

Khi initial state c·∫ßn t√≠nh to√°n ph·ª©c t·∫°p, d√πng function ƒë·ªÉ tr√°nh ch·∫°y l·∫°i m·ªói render.

```jsx
// ‚ùå KH√îNG T·ªêT - expensiveCalculation ch·∫°y m·ªói render
function Component() {
  const [data, setData] = useState(expensiveCalculation());
  // expensiveCalculation() ch·∫°y m·ªói l·∫ßn component re-render!
}

// ‚úÖ T·ªêT - Ch·ªâ ch·∫°y l·∫ßn ƒë·∫ßu
function Component() {
  const [data, setData] = useState(() => expensiveCalculation());
  // Function ch·ªâ ch·∫°y khi mount l·∫ßn ƒë·∫ßu
}
```

**V√≠ d·ª• th·ª±c t·∫ø:**

```jsx
function TodoApp() {
  // ‚ùå ƒê·ªçc localStorage m·ªói render
  const [todos, setTodos] = useState(
    JSON.parse(localStorage.getItem("todos") || "[]")
  );

  // ‚úÖ Ch·ªâ ƒë·ªçc localStorage m·ªôt l·∫ßn
  const [todos, setTodos] = useState(() => {
    const saved = localStorage.getItem("todos");
    return saved ? JSON.parse(saved) : [];
  });

  // ‚úÖ Initial state ph·ª©c t·∫°p
  const [user, setUser] = useState(() => {
    const stored = localStorage.getItem("user");
    if (stored) {
      const parsed = JSON.parse(stored);
      // Validate v√† transform data
      return {
        ...parsed,
        lastLogin: new Date(parsed.lastLogin),
        preferences: parsed.preferences || {},
      };
    }
    return null;
  });
}
```

**Khi n√†o d√πng lazy initialization:**

- ‚úÖ ƒê·ªçc t·ª´ localStorage/sessionStorage
- ‚úÖ T√≠nh to√°n ph·ª©c t·∫°p (parsing, computation)
- ‚úÖ T·∫°o objects/arrays l·ªõn
- ‚ùå KH√îNG c·∫ßn cho gi√° tr·ªã ƒë∆°n gi·∫£n (0, '', false, [])

---

### **1.4. Functional Updates**

Khi state m·ªõi ph·ª• thu·ªôc v√†o state c≈©, d√πng functional update.

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  // ‚ùå C√≥ th·ªÉ b·ªã stale closure
  const increment = () => {
    setCount(count + 1);
  };

  // ‚ùå KH√îNG ho·∫°t ƒë·ªông nh∆∞ mong ƒë·ª£i
  const incrementTwice = () => {
    setCount(count + 1); // count = 0 ‚Üí 1
    setCount(count + 1); // count v·∫´n = 0 ‚Üí 1 (kh√¥ng ph·∫£i 2!)
  };

  // ‚úÖ ƒê√öNG - Functional update
  const increment = () => {
    setCount((prevCount) => prevCount + 1);
  };

  // ‚úÖ B√¢y gi·ªù increment twice ho·∫°t ƒë·ªông ƒë√∫ng
  const incrementTwice = () => {
    setCount((prev) => prev + 1); // 0 ‚Üí 1
    setCount((prev) => prev + 1); // 1 ‚Üí 2 ‚úÖ
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={incrementTwice}>+2</button>
    </div>
  );
}
```

**T·∫°i sao c·∫ßn functional updates:**

```jsx
function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      // ‚ùå count lu√¥n l√† 0 (stale closure)
      setCount(count + 1);
    }, 1000);

    return () => clearInterval(interval);
  }, []); // Empty deps - count kh√¥ng update

  // ‚úÖ ƒê√öNG
  useEffect(() => {
    const interval = setInterval(() => {
      setCount((prev) => prev + 1); // Lu√¥n c√≥ gi√° tr·ªã m·ªõi nh·∫•t
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return <div>Count: {count}</div>;
}
```

**V·ªõi Objects v√† Arrays:**

```jsx
function TodoList() {
  const [todos, setTodos] = useState([]);

  // ‚úÖ Functional update v·ªõi array
  const addTodo = (text) => {
    setTodos((prevTodos) => [
      ...prevTodos,
      { id: Date.now(), text, completed: false },
    ]);
  };

  // ‚úÖ Functional update v·ªõi object
  const [user, setUser] = useState({ name: "", age: 0 });

  const updateAge = (increment) => {
    setUser((prevUser) => ({
      ...prevUser,
      age: prevUser.age + increment,
    }));
  };
}
```

---

### **1.5. State Immutability - T√≠nh B·∫•t Bi·∫øn**

React d·ª±a v√†o reference comparison ƒë·ªÉ detect changes. Ph·∫£i t·∫°o object/array M·ªöI!

#### **T·∫°i sao c·∫ßn immutability?**

```jsx
const [user, setUser] = useState({ name: "John", age: 30 });

// ‚ùå SAI - Mutation
user.age = 31;
setUser(user); // React: "Object gi·ªëng nhau, kh√¥ng re-render!"

// ‚úÖ ƒê√öNG - T·∫°o object m·ªõi
setUser({ ...user, age: 31 }); // React: "Object kh√°c, re-render!"
```

#### **Immutable Updates - Objects**

```jsx
const [person, setPerson] = useState({
  name: "John",
  address: {
    city: "Hanoi",
    street: "Nguyen Trai",
  },
  hobbies: ["reading", "coding"],
});

// ‚úÖ Update top-level property
setPerson({ ...person, name: "Jane" });

// ‚úÖ Update nested property
setPerson({
  ...person,
  address: {
    ...person.address,
    city: "HCMC",
  },
});

// ‚úÖ Update array trong object
setPerson({
  ...person,
  hobbies: [...person.hobbies, "gaming"],
});

// ‚úÖ Deep nested update
setPerson({
  ...person,
  address: {
    ...person.address,
    coordinates: {
      ...person.address.coordinates,
      lat: 21.0285,
    },
  },
});
```

#### **Immutable Updates - Arrays**

```jsx
const [items, setItems] = useState([
  { id: 1, name: "Item 1", tags: ["a", "b"] },
  { id: 2, name: "Item 2", tags: ["c", "d"] },
]);

// ‚úÖ Update item property
setItems(
  items.map((item) => (item.id === 1 ? { ...item, name: "Updated" } : item))
);

// ‚úÖ Update nested array
setItems(
  items.map((item) =>
    item.id === 1 ? { ...item, tags: [...item.tags, "new-tag"] } : item
  )
);

// ‚úÖ X√≥a item
setItems(items.filter((item) => item.id !== 1));

// ‚úÖ Insert item t·∫°i v·ªã tr√≠
const insertAtIndex = (array, index, item) => [
  ...array.slice(0, index),
  item,
  ...array.slice(index),
];

setItems(insertAtIndex(items, 1, { id: 3, name: "New Item" }));
```

#### **Helper Functions cho Immutable Updates**

```jsx
// Helper: Update object property
const updateObject = (obj, updates) => ({
  ...obj,
  ...updates,
});

// Helper: Update nested property
const updateNested = (obj, path, value) => {
  const keys = path.split(".");
  const lastKey = keys.pop();

  const updated = { ...obj };
  let current = updated;

  for (const key of keys) {
    current[key] = { ...current[key] };
    current = current[key];
  }

  current[lastKey] = value;
  return updated;
};

// Usage
setPerson(updateNested(person, "address.city", "HCMC"));

// Helper: Toggle item trong array
const toggleItem = (array, id, key) =>
  array.map((item) => (item.id === id ? { ...item, [key]: !item[key] } : item));

// Usage
setTodos(toggleItem(todos, 1, "completed"));
```

---

### **1.6. State Best Practices**

#### **1. Nh√≥m related state**

```jsx
// ‚ùå KH√îNG T·ªêT - Qu√° nhi·ªÅu state ri√™ng l·∫ª
function Form() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [email, setEmail] = useState("");
  const [phone, setPhone] = useState("");
  const [address, setAddress] = useState("");
  // ... nhi·ªÅu state kh√°c
}

// ‚úÖ T·ªêT H∆†N - Nh√≥m l·∫°i
function Form() {
  const [formData, setFormData] = useState({
    firstName: "",
    lastName: "",
    email: "",
    phone: "",
    address: "",
  });

  const updateField = (field, value) => {
    setFormData({ ...formData, [field]: value });
  };
}
```

#### **2. Tr√°nh redundant state**

```jsx
// ‚ùå Redundant - fullName c√≥ th·ªÉ t√≠nh t·ª´ firstName v√† lastName
function User() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [fullName, setFullName] = useState(""); // ‚ùå Kh√¥ng c·∫ßn!

  // Ph·∫£i sync fullName m·ªói khi firstName/lastName thay ƒë·ªïi
  useEffect(() => {
    setFullName(`${firstName} ${lastName}`);
  }, [firstName, lastName]);
}

// ‚úÖ Derived state - T√≠nh to√°n tr·ª±c ti·∫øp
function User() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");

  const fullName = `${firstName} ${lastName}`; // ‚úÖ ƒê∆°n gi·∫£n h∆°n!
}
```

#### **3. Tr√°nh duplicate state t·ª´ props**

```jsx
// ‚ùå SAI - Copy props v√†o state
function Message({ initialText }) {
  const [text, setText] = useState(initialText);

  // Khi initialText thay ƒë·ªïi, text kh√¥ng update!
  return <div>{text}</div>;
}

// ‚úÖ Option 1: D√πng props tr·ª±c ti·∫øp
function Message({ text }) {
  return <div>{text}</div>;
}

// ‚úÖ Option 2: Controlled component
function Message({ text, onChange }) {
  return <input value={text} onChange={onChange} />;
}

// ‚úÖ Option 3: D√πng key ƒë·ªÉ reset
<Message key={userId} initialText={user.message} />;
```

#### **4. State structure t·ªët**

```jsx
// ‚ùå KH√îNG T·ªêT - Flat structure kh√≥ manage
const [users, setUsers] = useState([...]);
const [selectedUserId, setSelectedUserId] = useState(null);
const [isEditing, setIsEditing] = useState(false);
const [editingUserId, setEditingUserId] = useState(null);

// ‚úÖ T√ìT H∆†N - Normalized structure
const [state, setState] = useState({
  users: {
    byId: {
      '1': { id: '1', name: 'John' },
      '2': { id: '2', name: 'Jane' }
    },
    allIds: ['1', '2']
  },
  ui: {
    selectedId: null,
    isEditing: false,
    editingId: null
  }
});
```

---

## üíª PH·∫¶N 2: CODE DEMO (30-45 ph√∫t)

### **Demo 1: Form v·ªõi Multiple State**

```jsx
function RegistrationForm() {
  // Method 1: Multiple useState
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [agreeTerms, setAgreeTerms] = useState(false);

  // Method 2: Single object state (t·ªët h∆°n)
  const [formData, setFormData] = useState({
    email: "",
    password: "",
    confirmPassword: "",
    agreeTerms: false,
  });

  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const updateField = (field) => (e) => {
    const value =
      e.target.type === "checkbox" ? e.target.checked : e.target.value;
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
    // Clear error khi user b·∫Øt ƒë·∫ßu s·ª≠a
    if (errors[field]) {
      setErrors((prev) => ({ ...prev, [field]: "" }));
    }
  };

  const validate = () => {
    const newErrors = {};

    if (!formData.email) {
      newErrors.email = "Email l√† b·∫Øt bu·ªôc";
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = "Email kh√¥ng h·ª£p l·ªá";
    }

    if (!formData.password) {
      newErrors.password = "M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc";
    } else if (formData.password.length < 6) {
      newErrors.password = "M·∫≠t kh·∫©u ph·∫£i √≠t nh·∫•t 6 k√Ω t·ª±";
    }

    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = "M·∫≠t kh·∫©u kh√¥ng kh·ªõp";
    }

    if (!formData.agreeTerms) {
      newErrors.agreeTerms = "B·∫°n ph·∫£i ƒë·ªìng √Ω v·ªõi ƒëi·ªÅu kho·∫£n";
    }

    return newErrors;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    const newErrors = validate();
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return;
    }

    setIsSubmitting(true);
    try {
      // Simulate API call
      await new Promise((resolve) => setTimeout(resolve, 2000));
      console.log("Form submitted:", formData);
      alert("ƒêƒÉng k√Ω th√†nh c√¥ng!");

      // Reset form
      setFormData({
        email: "",
        password: "",
        confirmPassword: "",
        agreeTerms: false,
      });
    } catch (error) {
      setErrors({ submit: "C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i." });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Email:</label>
        <input
          type="email"
          value={formData.email}
          onChange={updateField("email")}
          disabled={isSubmitting}
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>

      <div>
        <label>M·∫≠t kh·∫©u:</label>
        <input
          type="password"
          value={formData.password}
          onChange={updateField("password")}
          disabled={isSubmitting}
        />
        {errors.password && <span className="error">{errors.password}</span>}
      </div>

      <div>
        <label>X√°c nh·∫≠n m·∫≠t kh·∫©u:</label>
        <input
          type="password"
          value={formData.confirmPassword}
          onChange={updateField("confirmPassword")}
          disabled={isSubmitting}
        />
        {errors.confirmPassword && (
          <span className="error">{errors.confirmPassword}</span>
        )}
      </div>

      <div>
        <label>
          <input
            type="checkbox"
            checked={formData.agreeTerms}
            onChange={updateField("agreeTerms")}
            disabled={isSubmitting}
          />
          T√¥i ƒë·ªìng √Ω v·ªõi ƒëi·ªÅu kho·∫£n s·ª≠ d·ª•ng
        </label>
        {errors.agreeTerms && (
          <span className="error">{errors.agreeTerms}</span>
        )}
      </div>

      {errors.submit && <div className="error">{errors.submit}</div>}

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "ƒêang x·ª≠ l√Ω..." : "ƒêƒÉng k√Ω"}
      </button>
    </form>
  );
}
```

### **Demo 2: Shopping Cart**

```jsx
function ShoppingCart() {
  const [cart, setCart] = useState([]);

  // Th√™m s·∫£n ph·∫©m v√†o gi·ªè
  const addToCart = (product) => {
    setCart((prevCart) => {
      const existingItem = prevCart.find((item) => item.id === product.id);

      if (existingItem) {
        // TƒÉng quantity n·∫øu ƒë√£ c√≥
        return prevCart.map((item) =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }

      // Th√™m m·ªõi
      return [...prevCart, { ...product, quantity: 1 }];
    });
  };

  // X√≥a s·∫£n ph·∫©m
  const removeFromCart = (productId) => {
    setCart((prevCart) => prevCart.filter((item) => item.id !== productId));
  };

  // Update quantity
  const updateQuantity = (productId, newQuantity) => {
    if (newQuantity < 1) {
      removeFromCart(productId);
      return;
    }

    setCart((prevCart) =>
      prevCart.map((item) =>
        item.id === productId ? { ...item, quantity: newQuantity } : item
      )
    );
  };

  // T√≠nh t·ªïng
  const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
  const itemCount = cart.reduce((sum, item) => sum + item.quantity, 0);

  return (
    <div>
      <h2>Gi·ªè h√†ng ({itemCount} s·∫£n ph·∫©m)</h2>

      {cart.length === 0 ? (
        <p>Gi·ªè h√†ng tr·ªëng</p>
      ) : (
        <>
          <ul>
            {cart.map((item) => (
              <li key={item.id}>
                <span>{item.name}</span>
                <span>{item.price.toLocaleString("vi-VN")}ƒë</span>
                <input
                  type="number"
                  value={item.quantity}
                  onChange={(e) =>
                    updateQuantity(item.id, parseInt(e.target.value) || 0)
                  }
                  min="1"
                />
                <button onClick={() => removeFromCart(item.id)}>X√≥a</button>
              </li>
            ))}
          </ul>

          <div>
            <strong>T·ªïng c·ªông: {total.toLocaleString("vi-VN")}ƒë</strong>
          </div>

          <button onClick={() => setCart([])}>X√≥a t·∫•t c·∫£</button>
        </>
      )}
    </div>
  );
}
```

---

## üî® PH·∫¶N 3: TH·ª∞C H√ÄNH (60-90 ph√∫t)

### **Exercise 1: Counter N√¢ng Cao**

```jsx
function AdvancedCounter() {
  // TODO:
  // 1. Count state
  // 2. Step size state (c√≥ th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c)
  // 3. History state (l∆∞u c√°c gi√° tr·ªã tr∆∞·ªõc ƒë√≥)
  // 4. Min/max limits
  // 5. C√°c n√∫t: +, -, Reset, Undo, Redo
  // 6. Hi·ªÉn th·ªã history

  return <div>{/* Your code */}</div>;
}
```

### **Exercise 2: Todo App Ho√†n Ch·ªânh**

```jsx
function TodoApp() {
  // TODO:
  // 1. Todos array state v·ªõi: id, text, completed, priority, createdAt
  // 2. Input state
  // 3. Filter state (all/active/completed)
  // 4. Sort state (date/priority/alphabetical)
  // 5. Ch·ª©c nƒÉng:
  //    - Th√™m todo
  //    - X√≥a todo
  //    - Toggle completed
  //    - Edit todo (inline editing)
  //    - Set priority (low/medium/high)
  //    - Filter v√† sort
  //    - Clear completed
  //    - Toggle all
  // 6. Save v√†o localStorage
  // 7. Stats: total, active, completed

  return <div>{/* Your code */}</div>;
}
```

### **Exercise 3: Multi-Step Form**

```jsx
function MultiStepForm() {
  // TODO:
  // 1. Current step state (1, 2, 3)
  // 2. Form data state cho m·ªói step:
  //    Step 1: Personal info (name, email, phone)
  //    Step 2: Address (street, city, postal code)
  //    Step 3: Payment (card number, expiry, cvv)
  // 3. Errors state cho m·ªói step
  // 4. Validation cho m·ªói step
  // 5. N√∫t: Next, Previous, Submit
  // 6. Progress bar
  // 7. Review t·∫•t c·∫£ data ·ªü step cu·ªëi
  // 8. Kh√¥ng cho next n·∫øu step hi·ªán t·∫°i invalid

  return <div>{/* Your code */}</div>;
}
```

### **Exercise 4: Quiz App**

```jsx
const quizData = [
  {
    id: 1,
    question: "React ƒë∆∞·ª£c t·∫°o b·ªüi?",
    options: ["Google", "Facebook", "Microsoft", "Apple"],
    correctAnswer: 1,
  },
  // More questions...
];

function QuizApp() {
  // TODO:
  // 1. Current question index state
  // 2. Selected answers state (array)
  // 3. Show result state (boolean)
  // 4. Time remaining state (optional - countdown timer)
  // 5. Ch·ª©c nƒÉng:
  //    - Select answer
  //    - Next question
  //    - Previous question
  //    - Submit quiz
  //    - Show score
  //    - Restart quiz
  // 6. Highlight correct/incorrect answers khi submit
  // 7. Progress indicator
  // 8. Prevent changing answer after submit

  return <div>{/* Your code */}</div>;
}
```

### **Exercise 5: Expense Tracker (Challenge)**

```jsx
function ExpenseTracker() {
  // TODO:
  // 1. Expenses array state: { id, description, amount, category, date }
  // 2. Categories: ['ƒÇn u·ªëng', 'Di chuy·ªÉn', 'Gi·∫£i tr√≠', 'Mua s·∫Øm', 'Kh√°c']
  // 3. Filter state: { category, dateRange, minAmount, maxAmount }
  // 4. Form state cho add/edit expense
  // 5. Ch·ª©c nƒÉng:
  //    - Add expense
  //    - Edit expense
  //    - Delete expense
  //    - Filter by category
  //    - Filter by date range
  //    - Filter by amount range
  //    - Search by description
  // 6. Th·ªëng k√™:
  //    - T·ªïng chi ti√™u
  //    - Chi ti√™u theo category (pie chart ho·∫∑c bars)
  //    - Chi ti√™u theo th√°ng
  //    - Category chi nhi·ªÅu nh·∫•t
  // 7. Sort options: date, amount, category
  // 8. Export data (JSON)
  // 9. Import data
  // 10. LocalStorage persistence

  const [expenses, setExpenses] = useState(() => {
    const saved = localStorage.getItem("expenses");
    return saved ? JSON.parse(saved) : [];
  });

  const [formData, setFormData] = useState({
    description: "",
    amount: "",
    category: "ƒÇn u·ªëng",
    date: new Date().toISOString().split("T")[0],
  });

  const [filters, setFilters] = useState({
    category: "all",
    searchTerm: "",
    dateFrom: "",
    dateTo: "",
    minAmount: "",
    maxAmount: "",
  });

  const [editingId, setEditingId] = useState(null);

  // TODO: Implement c√°c functions:
  // - addExpense
  // - updateExpense
  // - deleteExpense
  // - getFilteredExpenses
  // - getStatistics
  // - exportData
  // - importData

  return (
    <div className="expense-tracker">
      <h1>Qu·∫£n L√Ω Chi Ti√™u</h1>

      {/* Add/Edit Form */}
      <div className="expense-form">{/* Your form code */}</div>

      {/* Filters */}
      <div className="filters">{/* Your filters code */}</div>

      {/* Statistics */}
      <div className="statistics">{/* Your statistics code */}</div>

      {/* Expense List */}
      <div className="expense-list">{/* Your list code */}</div>
    </div>
  );
}
```

---

## ‚úÖ PH·∫¶N 4: REVIEW & CHECKLIST (15-30 ph√∫t)

### **useState Basics:**

- [ ] Syntax: `const [state, setState] = useState(initialValue)`
- [ ] Naming convention: `[thing, setThing]`
- [ ] Hooks ph·∫£i ·ªü top level
- [ ] Kh√¥ng ƒë∆∞·ª£c trong if/loop/nested function

### **State Types:**

- [ ] Primitives: number, string, boolean
- [ ] Objects: d√πng spread `{...obj, key: value}`
- [ ] Arrays: d√πng spread `[...arr, item]` ho·∫∑c methods nh∆∞ `map`, `filter`
- [ ] Tr√°nh mutating methods: `push`, `pop`, `splice`, `sort`

### **Lazy Initialization:**

- [ ] D√πng function: `useState(() => expensiveCalculation())`
- [ ] Ch·ªâ ch·∫°y m·ªôt l·∫ßn khi mount
- [ ] D√πng cho localStorage, t√≠nh to√°n ph·ª©c t·∫°p

### **Functional Updates:**

- [ ] Syntax: `setState(prev => newValue)`
- [ ] D√πng khi state m·ªõi ph·ª• thu·ªôc state c≈©
- [ ] Tr√°nh stale closure trong useEffect/timers

### **Immutability:**

- [ ] KH√îNG mutate state tr·ª±c ti·∫øp
- [ ] Lu√¥n t·∫°o object/array M·ªöI
- [ ] D√πng spread operator
- [ ] React so s√°nh b·∫±ng reference

### **Best Practices:**

- [ ] Nh√≥m related state
- [ ] Tr√°nh redundant state (derived state)
- [ ] Tr√°nh duplicate props v√†o state
- [ ] Structure state t·ªët (flat ho·∫∑c normalized)

### **Common Mistakes:**

```jsx
// ‚ùå Mutate state tr·ª±c ti·∫øp
user.name = "New"; // NEVER!
setUser(user);

// ‚ùå Kh√¥ng d√πng functional update
setCount(count + 1);
setCount(count + 1); // V·∫´n ch·ªâ +1, kh√¥ng ph·∫£i +2

// ‚ùå Hooks trong ƒëi·ªÅu ki·ªán
if (condition) {
  const [state, setState] = useState(0); // Error!
}

// ‚ùå Array mutation
todos.push(newTodo); // NEVER!
setTodos(todos);

// ‚ùå Redundant state
const [firstName, setFirstName] = useState("");
const [lastName, setLastName] = useState("");
const [fullName, setFullName] = useState(""); // Kh√¥ng c·∫ßn!

// ‚úÖ ƒê√öNG
setUser({ ...user, name: "New" });

setCount((prev) => prev + 1);
setCount((prev) => prev + 1); // ƒê√∫ng +2

// Top level
const [state, setState] = useState(0);

setTodos([...todos, newTodo]);

// Derived state
const fullName = `${firstName} ${lastName}`;
```

---

## üéØ HOMEWORK

### **1. Notes App**

T·∫°o ·ª©ng d·ª•ng ghi ch√∫:

- CRUD operations (Create, Read, Update, Delete)
- Categories/Tags
- Search functionality
- Rich text formatting (optional)
- Pin/Favorite notes
- Sort by: date, title, modified
- LocalStorage persistence
- Export/Import notes

### **2. Budget Planner**

Qu·∫£n l√Ω ng√¢n s√°ch c√° nh√¢n:

```jsx
// State structure
{
  income: { amount, source, date },
  expenses: [{ amount, category, date, recurring }],
  budget: { category: limit },
  savings: { goal, current, deadline }
}

// Features:
// - Set income
// - Add/edit/delete expenses
// - Set budget limits per category
// - Alerts khi v∆∞·ª£t budget
// - Savings goal tracker
// - Monthly/yearly reports
// - Recurring expenses
```

### **3. Habit Tracker**

Theo d√µi th√≥i quen h√†ng ng√†y:

```jsx
// State structure
{
  habits: [
    {
      id,
      name,
      goal, // 'daily', 'weekly', s·ªë l·∫ßn
      streak,
      history: { date: completed },
    },
  ];
}

// Features:
// - Add/edit/delete habits
// - Mark as completed
// - Current streak
// - Best streak
// - Calendar view
// - Statistics
// - Reminders (optional)
```

### **4. Recipe Book**

S·ªï c√¥ng th·ª©c n·∫•u ƒÉn:

```jsx
// State structure
{
  recipes: [
    {
      id,
      title,
      ingredients: [{ name, amount, unit }],
      steps: [],
      prepTime,
      cookTime,
      servings,
      difficulty,
      category,
      tags,
      image,
      rating,
      notes
    }
  ],
  shoppingList: []
}

// Features:
// - Add/edit/delete recipes
// - Search and filter
// - Scale servings
// - Add to shopping list
// - Rate recipes
// - Categories and tags
// - Favorite recipes
```

### **5. Pomodoro Timer v·ªõi Stats (Challenge)**

Timer l√†m vi·ªác v·ªõi th·ªëng k√™:

```jsx
// State structure
{
  timer: {
    minutes,
    seconds,
    isRunning,
    mode // 'work', 'shortBreak', 'longBreak'
  },
  settings: {
    workDuration,
    shortBreakDuration,
    longBreakDuration,
    sessionsUntilLongBreak
  },
  sessions: [
    {
      date,
      completedPomodoros,
      totalFocusTime,
      tasks: [{ name, pomodoros }]
    }
  ],
  currentTask: { name, estimatedPomodoros, completed }
}

// Features:
// - Customizable durations
// - Auto-switch between work/break
// - Task list v·ªõi pomodoro estimates
// - Daily/weekly statistics
// - Focus time trends
// - Browser notifications
// - Sound alerts
// - Background work tracking
```

---

## üìö ƒê·ªçc Th√™m

### **Official Docs:**

- [React - useState](https://react.dev/reference/react/useState)
- [React - State as a Snapshot](https://react.dev/learn/state-as-a-snapshot)
- [React - Queueing State Updates](https://react.dev/learn/queueing-a-series-of-state-updates)
- [React - Updating Objects in State](https://react.dev/learn/updating-objects-in-state)
- [React - Updating Arrays in State](https://react.dev/learn/updating-arrays-in-state)

### **Advanced Topics:**

- [Kent C. Dodds - Don't Sync State. Derive It!](https://kentcdodds.com/blog/dont-sync-state-derive-it)
- [Dan Abramov - A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

---

## üìù Key Takeaways

1. **useState = State Management c∆° b·∫£n nh·∫•t** trong React hooks
2. **Immutability is KEY** - Lu√¥n t·∫°o object/array m·ªõi
3. **Functional Updates** - D√πng khi state m·ªõi ph·ª• thu·ªôc state c≈©
4. **Lazy Initialization** - Optimize performance cho initial state ph·ª©c t·∫°p
5. **State Structure** - Thi·∫øt k·∫ø t·ªët gi√∫p code d·ªÖ maintain
6. **Avoid Redundancy** - Derive state thay v√¨ duplicate
7. **Batching** - React t·ª± ƒë·ªông batch multiple setState calls

---

## üîç Debug Tips

### **1. State kh√¥ng update:**

```jsx
// Check: C√≥ mutate tr·ª±c ti·∫øp kh√¥ng?
user.name = "New"; // ‚ùå
setUser(user); // Kh√¥ng trigger re-render

// Fix:
setUser({ ...user, name: "New" }); // ‚úÖ
```

### **2. Stale closure:**

```jsx
// Problem:
useEffect(() => {
  setInterval(() => {
    setCount(count + 1); // count lu√¥n l√† gi√° tr·ªã ban ƒë·∫ßu
  }, 1000);
}, []); // Empty deps

// Fix:
useEffect(() => {
  setInterval(() => {
    setCount((prev) => prev + 1); // ‚úÖ Functional update
  }, 1000);
}, []);
```

### **3. useState kh√¥ng ch·∫°y lazy init:**

```jsx
// Wrong:
useState(expensiveFunction()); // Ch·∫°y m·ªói render

// Right:
useState(() => expensiveFunction()); // Ch·ªâ ch·∫°y l·∫ßn ƒë·∫ßu
```

---

## üí° Pro Tips

1. **DevTools**: D√πng React DevTools ƒë·ªÉ inspect state changes
2. **Immer**: Th∆∞ vi·ªán gi√∫p vi·∫øt immutable updates d·ªÖ h∆°n
3. **TypeScript**: Type safety cho state r·∫•t h·ªØu √≠ch
4. **Console.log**: Log state ƒë·ªÉ debug, nh∆∞ng nh·ªõ x√≥a sau khi xong
5. **Small Components**: T√°ch component nh·ªè = state d·ªÖ qu·∫£n l√Ω h∆°n

---

## üéÆ Quick Quiz

Tr∆∞·ªõc khi qua ng√†y 7, test ki·∫øn th·ª©c:

1. T·∫°i sao ph·∫£i d√πng spread operator khi update object/array state?
2. Khi n√†o d√πng functional update `setState(prev => ...)`?
3. Khi n√†o c·∫ßn lazy initialization?
4. Array methods n√†o an to√†n cho setState? (map, filter, slice...)
5. L√†m sao update nested object trong state?

**ƒê√°p √°n:**

1. React so s√°nh b·∫±ng reference. C√πng reference = kh√¥ng re-render.
2. Khi state m·ªõi ph·ª• thu·ªôc state c≈©, ho·∫∑c trong useEffect/timer.
3. Khi initial state t·ªën t√†i nguy√™n: localStorage, parsing, computation.
4. Non-mutating methods: map, filter, slice, concat, spread
5. D√πng nested spread: `{ ...obj, nested: { ...obj.nested, key: value } }`

---

**üöÄ Ng√†y mai (Ng√†y 7):** useReducer - Complex State Logic! Khi useState kh√¥ng ƒë·ªß m·∫°nh! üí™
