# üìÖ NG√ÄY 6: useState Mastery

## üéØ M·ª•c ti√™u h√¥m nay

-   Hi·ªÉu s√¢u v·ªÅ useState hook
-   Lazy initialization
-   Functional updates
-   State immutability
-   Best practices v√† patterns
-   Tr√°nh nh·ªØng l·ªói ph·ªï bi·∫øn

---

## üìö PH·∫¶N 1: L√ù THUY·∫æT (30-45 ph√∫t)

### **1.1. useState C∆° B·∫£n**

#### **Syntax v√† C√°ch D√πng**

```jsx
import { useState } from 'react';

function Counter() {
    // [state, setState] = useState(initialValue)
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>+1</button>
        </div>
    );
}
```

**Gi·∫£i th√≠ch:**

-   `useState(0)` - kh·ªüi t·∫°o state v·ªõi gi√° tr·ªã 0
-   Tr·∫£ v·ªÅ array v·ªõi 2 elements: `[gi√° tr·ªã hi·ªán t·∫°i, h√†m ƒë·ªÉ update]`
-   Destructuring ƒë·ªÉ l·∫•y ra: `const [count, setCount] = ...`
-   Naming convention: `[thing, setThing]`

#### **Multiple State Variables**

```jsx
function UserProfile() {
    const [name, setName] = useState('');
    const [age, setAge] = useState(0);
    const [email, setEmail] = useState('');
    const [isActive, setIsActive] = useState(true);

    return (
        <div>
            <input value={name} onChange={(e) => setName(e.target.value)} />
            <input
                type='number'
                value={age}
                onChange={(e) => setAge(e.target.value)}
            />
            <input
                type='email'
                value={email}
                onChange={(e) => setEmail(e.target.value)}
            />
            <input
                type='checkbox'
                checked={isActive}
                onChange={(e) => setIsActive(e.target.checked)}
            />
        </div>
    );
}
```

**‚ö†Ô∏è Quy t·∫Øc quan tr·ªçng:**

-   Hooks ph·∫£i ·ªü top level c·ªßa component
-   Kh√¥ng ƒë∆∞·ª£c trong if/loop/nested function
-   Th·ª© t·ª± hooks ph·∫£i gi·ªëng nhau m·ªói l·∫ßn render

```jsx
// ‚ùå SAI - Trong ƒëi·ªÅu ki·ªán
function BadComponent() {
    if (someCondition) {
        const [count, setCount] = useState(0); // ‚ùå L·ªói!
    }
}

// ‚ùå SAI - Trong loop
function BadComponent() {
    for (let i = 0; i < 5; i++) {
        const [count, setCount] = useState(0); // ‚ùå L·ªói!
    }
}

// ‚úÖ ƒê√öNG - Top level
function GoodComponent() {
    const [count, setCount] = useState(0);

    if (someCondition) {
        // D√πng count ·ªü ƒë√¢y OK
    }
}
```

---

### **1.2. C√°c Ki·ªÉu D·ªØ Li·ªáu State**

#### **Primitives (Number, String, Boolean)**

```jsx
function Examples() {
    const [count, setCount] = useState(0); // Number
    const [text, setText] = useState(''); // String
    const [isOpen, setIsOpen] = useState(false); // Boolean
    const [user, setUser] = useState(null); // Null
    const [data, setData] = useState(undefined); // Undefined

    return (
        <div>
            <button onClick={() => setCount(count + 1)}>Count: {count}</button>
            <input value={text} onChange={(e) => setText(e.target.value)} />
            <button onClick={() => setIsOpen(!isOpen)}>
                {isOpen ? 'ƒê√≥ng' : 'M·ªü'}
            </button>
        </div>
    );
}
```

#### **Objects**

```jsx
function UserForm() {
    const [user, setUser] = useState({
        name: '',
        email: '',
        age: 0,
    });

    // ‚ùå SAI - Mutation tr·ª±c ti·∫øp
    const updateNameWrong = (newName) => {
        user.name = newName; // ‚ùå Kh√¥ng trigger re-render!
        setUser(user);
    };

    // ‚úÖ ƒê√öNG - T·∫°o object m·ªõi
    const updateName = (newName) => {
        setUser({
            ...user, // Spread existing properties
            name: newName, // Override name
        });
    };

    // ‚úÖ ƒê√öNG - Update nhi·ªÅu fields
    const updateUser = (updates) => {
        setUser({
            ...user,
            ...updates,
        });
    };

    return (
        <div>
            <input
                value={user.name}
                onChange={(e) => setUser({ ...user, name: e.target.value })}
                placeholder='T√™n'
            />
            <input
                value={user.email}
                onChange={(e) => setUser({ ...user, email: e.target.value })}
                placeholder='Email'
            />
            <input
                type='number'
                value={user.age}
                onChange={(e) =>
                    setUser({ ...user, age: parseInt(e.target.value) })
                }
                placeholder='Tu·ªïi'
            />
        </div>
    );
}
```

#### **Arrays**

```jsx
function TodoList() {
    const [todos, setTodos] = useState([]);

    // ‚úÖ Th√™m item m·ªõi
    const addTodo = (text) => {
        setTodos([...todos, { id: Date.now(), text, completed: false }]);
        // Ho·∫∑c: setTodos(todos.concat({ id: Date.now(), text, completed: false }));
    };

    // ‚úÖ X√≥a item
    const deleteTodo = (id) => {
        setTodos(todos.filter((todo) => todo.id !== id));
    };

    // ‚úÖ Update item
    const toggleTodo = (id) => {
        setTodos(
            todos.map((todo) =>
                todo.id === id ? { ...todo, completed: !todo.completed } : todo
            )
        );
    };

    // ‚úÖ Insert v√†o v·ªã tr√≠ c·ª• th·ªÉ
    const insertAt = (index, item) => {
        setTodos([...todos.slice(0, index), item, ...todos.slice(index)]);
    };

    // ‚úÖ Sort
    const sortTodos = () => {
        setTodos([...todos].sort((a, b) => a.text.localeCompare(b.text)));
    };

    return (
        <ul>
            {todos.map((todo) => (
                <li key={todo.id}>
                    <input
                        type='checkbox'
                        checked={todo.completed}
                        onChange={() => toggleTodo(todo.id)}
                    />
                    {todo.text}
                    <button onClick={() => deleteTodo(todo.id)}>X√≥a</button>
                </li>
            ))}
        </ul>
    );
}
```

**‚ö†Ô∏è Array Methods - Mutating vs Non-mutating:**

```jsx
// ‚ùå Mutating (KH√îNG d√πng v·ªõi setState)
push()      // Th√™m v√†o cu·ªëi
pop()       // X√≥a cu·ªëi
shift()     // X√≥a ƒë·∫ßu
unshift()   // Th√™m v√†o ƒë·∫ßu
splice()    // X√≥a/th√™m t·∫°i v·ªã tr√≠
sort()      // S·∫Øp x·∫øp
reverse()   // ƒê·∫£o ng∆∞·ª£c

// ‚úÖ Non-mutating (AN TO√ÄN)
concat()    // N·ªëi arrays
slice()     // Copy m·ªôt ph·∫ßn
filter()    // L·ªçc
map()       // Transform
spread [...]// Copy array
```

---

### **1.3. Lazy Initialization**

Khi initial state c·∫ßn t√≠nh to√°n ph·ª©c t·∫°p, d√πng function ƒë·ªÉ tr√°nh ch·∫°y l·∫°i m·ªói render.

```jsx
// ‚ùå KH√îNG T·ªêT - expensiveCalculation ch·∫°y m·ªói render
function Component() {
    const [data, setData] = useState(expensiveCalculation());
    // expensiveCalculation() ch·∫°y m·ªói l·∫ßn component re-render!
}

// ‚úÖ T·ªêT - Ch·ªâ ch·∫°y l·∫ßn ƒë·∫ßu
function Component() {
    const [data, setData] = useState(() => expensiveCalculation());
    // Function ch·ªâ ch·∫°y khi mount l·∫ßn ƒë·∫ßu
}
```

**V√≠ d·ª• th·ª±c t·∫ø:**

```jsx
function TodoApp() {
    // ‚ùå ƒê·ªçc localStorage m·ªói render
    const [todos, setTodos] = useState(
        JSON.parse(localStorage.getItem('todos') || '[]')
    );

    // ‚úÖ Ch·ªâ ƒë·ªçc localStorage m·ªôt l·∫ßn
    const [todos, setTodos] = useState(() => {
        const saved = localStorage.getItem('todos');
        return saved ? JSON.parse(saved) : [];
    });

    // ‚úÖ Initial state ph·ª©c t·∫°p
    const [user, setUser] = useState(() => {
        const stored = localStorage.getItem('user');
        if (stored) {
            const parsed = JSON.parse(stored);
            // Validate v√† transform data
            return {
                ...parsed,
                lastLogin: new Date(parsed.lastLogin),
                preferences: parsed.preferences || {},
            };
        }
        return null;
    });
}
```

**Khi n√†o d√πng lazy initialization:**

-   ‚úÖ ƒê·ªçc t·ª´ localStorage/sessionStorage
-   ‚úÖ T√≠nh to√°n ph·ª©c t·∫°p (parsing, computation)
-   ‚úÖ T·∫°o objects/arrays l·ªõn
-   ‚ùå KH√îNG c·∫ßn cho gi√° tr·ªã ƒë∆°n gi·∫£n (0, '', false, [])

---

### **1.4. Functional Updates**

Khi state m·ªõi ph·ª• thu·ªôc v√†o state c≈©, d√πng functional update.

```jsx
function Counter() {
    const [count, setCount] = useState(0);

    // ‚ùå C√≥ th·ªÉ b·ªã stale closure
    const increment = () => {
        setCount(count + 1);
    };

    // ‚ùå KH√îNG ho·∫°t ƒë·ªông nh∆∞ mong ƒë·ª£i
    const incrementTwice = () => {
        setCount(count + 1); // count = 0 ‚Üí 1
        setCount(count + 1); // count v·∫´n = 0 ‚Üí 1 (kh√¥ng ph·∫£i 2!)
    };

    // ‚úÖ ƒê√öNG - Functional update
    const increment = () => {
        setCount((prevCount) => prevCount + 1);
    };

    // ‚úÖ B√¢y gi·ªù increment twice ho·∫°t ƒë·ªông ƒë√∫ng
    const incrementTwice = () => {
        setCount((prev) => prev + 1); // 0 ‚Üí 1
        setCount((prev) => prev + 1); // 1 ‚Üí 2 ‚úÖ
    };

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={increment}>+1</button>
            <button onClick={incrementTwice}>+2</button>
        </div>
    );
}
```

**T·∫°i sao c·∫ßn functional updates:**

```jsx
function Example() {
    const [count, setCount] = useState(0);

    useEffect(() => {
        const interval = setInterval(() => {
            // ‚ùå count lu√¥n l√† 0 (stale closure)
            setCount(count + 1);
        }, 1000);

        return () => clearInterval(interval);
    }, []); // Empty deps - count kh√¥ng update

    // ‚úÖ ƒê√öNG
    useEffect(() => {
        const interval = setInterval(() => {
            setCount((prev) => prev + 1); // Lu√¥n c√≥ gi√° tr·ªã m·ªõi nh·∫•t
        }, 1000);

        return () => clearInterval(interval);
    }, []);

    return <div>Count: {count}</div>;
}
```

**V·ªõi Objects v√† Arrays:**

```jsx
function TodoList() {
    const [todos, setTodos] = useState([]);

    // ‚úÖ Functional update v·ªõi array
    const addTodo = (text) => {
        setTodos((prevTodos) => [
            ...prevTodos,
            { id: Date.now(), text, completed: false },
        ]);
    };

    // ‚úÖ Functional update v·ªõi object
    const [user, setUser] = useState({ name: '', age: 0 });

    const updateAge = (increment) => {
        setUser((prevUser) => ({
            ...prevUser,
            age: prevUser.age + increment,
        }));
    };
}
```

---

### **1.5. State Immutability - T√≠nh B·∫•t Bi·∫øn**

React d·ª±a v√†o reference comparison ƒë·ªÉ detect changes. Ph·∫£i t·∫°o object/array M·ªöI!

#### **T·∫°i sao c·∫ßn immutability?**

```jsx
const [user, setUser] = useState({ name: 'John', age: 30 });

// ‚ùå SAI - Mutation
user.age = 31;
setUser(user); // React: "Object gi·ªëng nhau, kh√¥ng re-render!"

// ‚úÖ ƒê√öNG - T·∫°o object m·ªõi
setUser({ ...user, age: 31 }); // React: "Object kh√°c, re-render!"
```

#### **Immutable Updates - Objects**

```jsx
const [person, setPerson] = useState({
    name: 'John',
    address: {
        city: 'Hanoi',
        street: 'Nguyen Trai',
    },
    hobbies: ['reading', 'coding'],
});

// ‚úÖ Update top-level property
setPerson({ ...person, name: 'Jane' });

// ‚úÖ Update nested property
setPerson({
    ...person,
    address: {
        ...person.address,
        city: 'HCMC',
    },
});

// ‚úÖ Update array trong object
setPerson({
    ...person,
    hobbies: [...person.hobbies, 'gaming'],
});

// ‚úÖ Deep nested update
setPerson({
    ...person,
    address: {
        ...person.address,
        coordinates: {
            ...person.address.coordinates,
            lat: 21.0285,
        },
    },
});
```

#### **Immutable Updates - Arrays**

```jsx
const [items, setItems] = useState([
    { id: 1, name: 'Item 1', tags: ['a', 'b'] },
    { id: 2, name: 'Item 2', tags: ['c', 'd'] },
]);

// ‚úÖ Update item property
setItems(
    items.map((item) => (item.id === 1 ? { ...item, name: 'Updated' } : item))
);

// ‚úÖ Update nested array
setItems(
    items.map((item) =>
        item.id === 1 ? { ...item, tags: [...item.tags, 'new-tag'] } : item
    )
);

// ‚úÖ X√≥a item
setItems(items.filter((item) => item.id !== 1));

// ‚úÖ Insert item t·∫°i v·ªã tr√≠
const insertAtIndex = (array, index, item) => [
    ...array.slice(0, index),
    item,
    ...array.slice(index),
];

setItems(insertAtIndex(items, 1, { id: 3, name: 'New Item' }));
```

#### **Helper Functions cho Immutable Updates**

```jsx
// Helper: Update object property
const updateObject = (obj, updates) => ({
    ...obj,
    ...updates,
});

// Helper: Update nested property
const updateNested = (obj, path, value) => {
    const keys = path.split('.');
    const lastKey = keys.pop();

    const updated = { ...obj };
    let current = updated;

    for (const key of keys) {
        current[key] = { ...current[key] };
        current = current[key];
    }

    current[lastKey] = value;
    return updated;
};

// Usage
setPerson(updateNested(person, 'address.city', 'HCMC'));

// Helper: Toggle item trong array
const toggleItem = (array, id, key) =>
    array.map((item) =>
        item.id === id ? { ...item, [key]: !item[key] } : item
    );

// Usage
setTodos(toggleItem(todos, 1, 'completed'));
```

---

### **1.6. State Best Practices**

#### **1. Nh√≥m related state**

```jsx
// ‚ùå KH√îNG T·ªêT - Qu√° nhi·ªÅu state ri√™ng l·∫ª
function Form() {
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');
    const [email, setEmail] = useState('');
    const [phone, setPhone] = useState('');
    const [address, setAddress] = useState('');
    // ... nhi·ªÅu state kh√°c
}

// ‚úÖ T·ªêT H∆†N - Nh√≥m l·∫°i
function Form() {
    const [formData, setFormData] = useState({
        firstName: '',
        lastName: '',
        email: '',
        phone: '',
        address: '',
    });

    const updateField = (field, value) => {
        setFormData({ ...formData, [field]: value });
    };
}
```

#### **2. Tr√°nh redundant state**

```jsx
// ‚ùå Redundant - fullName c√≥ th·ªÉ t√≠nh t·ª´ firstName v√† lastName
function User() {
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');
    const [fullName, setFullName] = useState(''); // ‚ùå Kh√¥ng c·∫ßn!

    // Ph·∫£i sync fullName m·ªói khi firstName/lastName thay ƒë·ªïi
    useEffect(() => {
        setFullName(`${firstName} ${lastName}`);
    }, [firstName, lastName]);
}

// ‚úÖ Derived state - T√≠nh to√°n tr·ª±c ti·∫øp
function User() {
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');

    const fullName = `${firstName} ${lastName}`; // ‚úÖ ƒê∆°n gi·∫£n h∆°n!
}
```

#### **3. Tr√°nh duplicate state t·ª´ props**

```jsx
// ‚ùå SAI - Copy props v√†o state
function Message({ initialText }) {
    const [text, setText] = useState(initialText);

    // Khi initialText thay ƒë·ªïi, text kh√¥ng update!
    return <div>{text}</div>;
}

// ‚úÖ Option 1: D√πng props tr·ª±c ti·∫øp
function Message({ text }) {
    return <div>{text}</div>;
}

// ‚úÖ Option 2: Controlled component
function Message({ text, onChange }) {
    return <input value={text} onChange={onChange} />;
}

// ‚úÖ Option 3: D√πng key ƒë·ªÉ reset
<Message key={userId} initialText={user.message} />;
```

#### **4. State structure t·ªët**

```jsx
// ‚ùå KH√îNG T·ªêT - Flat structure kh√≥ manage
const [users, setUsers] = useState([...]);
const [selectedUserId, setSelectedUserId] = useState(null);
const [isEditing, setIsEditing] = useState(false);
const [editingUserId, setEditingUserId] = useState(null);

// ‚úÖ T√ìT H∆†N - Normalized structure
const [state, setState] = useState({
  users: {
    byId: {
      '1': { id: '1', name: 'John' },
      '2': { id: '2', name: 'Jane' }
    },
    allIds: ['1', '2']
  },
  ui: {
    selectedId: null,
    isEditing: false,
    editingId: null
  }
});
```

---

## üíª PH·∫¶N 2: CODE DEMO (30-45 ph√∫t)

### **Demo 1: Form v·ªõi Multiple State**

```jsx
function RegistrationForm() {
    // Method 1: Multiple useState
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [agreeTerms, setAgreeTerms] = useState(false);

    // Method 2: Single object state (t·ªët h∆°n)
    const [formData, setFormData] = useState({
        email: '',
        password: '',
        confirmPassword: '',
        agreeTerms: false,
    });

    const [errors, setErrors] = useState({});
    const [isSubmitting, setIsSubmitting] = useState(false);

    const updateField = (field) => (e) => {
        const value =
            e.target.type === 'checkbox' ? e.target.checked : e.target.value;
        setFormData((prev) => ({
            ...prev,
            [field]: value,
        }));
        // Clear error khi user b·∫Øt ƒë·∫ßu s·ª≠a
        if (errors[field]) {
            setErrors((prev) => ({ ...prev, [field]: '' }));
        }
    };

    const validate = () => {
        const newErrors = {};

        if (!formData.email) {
            newErrors.email = 'Email l√† b·∫Øt bu·ªôc';
        } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
            newErrors.email = 'Email kh√¥ng h·ª£p l·ªá';
        }

        if (!formData.password) {
            newErrors.password = 'M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc';
        } else if (formData.password.length < 6) {
            newErrors.password = 'M·∫≠t kh·∫©u ph·∫£i √≠t nh·∫•t 6 k√Ω t·ª±';
        }

        if (formData.password !== formData.confirmPassword) {
            newErrors.confirmPassword = 'M·∫≠t kh·∫©u kh√¥ng kh·ªõp';
        }

        if (!formData.agreeTerms) {
            newErrors.agreeTerms = 'B·∫°n ph·∫£i ƒë·ªìng √Ω v·ªõi ƒëi·ªÅu kho·∫£n';
        }

        return newErrors;
    };

    const handleSubmit = async (e) => {
        e.preventDefault();

        const newErrors = validate();
        if (Object.keys(newErrors).length > 0) {
            setErrors(newErrors);
            return;
        }

        setIsSubmitting(true);
        try {
            // Simulate API call
            await new Promise((resolve) => setTimeout(resolve, 2000));
            console.log('Form submitted:', formData);
            alert('ƒêƒÉng k√Ω th√†nh c√¥ng!');

            // Reset form
            setFormData({
                email: '',
                password: '',
                confirmPassword: '',
                agreeTerms: false,
            });
        } catch (error) {
            setErrors({ submit: 'C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.' });
        } finally {
            setIsSubmitting(false);
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <div>
                <label>Email:</label>
                <input
                    type='email'
                    value={formData.email}
                    onChange={updateField('email')}
                    disabled={isSubmitting}
                />
                {errors.email && <span className='error'>{errors.email}</span>}
            </div>

            <div>
                <label>M·∫≠t kh·∫©u:</label>
                <input
                    type='password'
                    value={formData.password}
                    onChange={updateField('password')}
                    disabled={isSubmitting}
                />
                {errors.password && (
                    <span className='error'>{errors.password}</span>
                )}
            </div>

            <div>
                <label>X√°c nh·∫≠n m·∫≠t kh·∫©u:</label>
                <input
                    type='password'
                    value={formData.confirmPassword}
                    onChange={updateField('confirmPassword')}
                    disabled={isSubmitting}
                />
                {errors.confirmPassword && (
                    <span className='error'>{errors.confirmPassword}</span>
                )}
            </div>

            <div>
                <label>
                    <input
                        type='checkbox'
                        checked={formData.agreeTerms}
                        onChange={updateField('agreeTerms')}
                        disabled={isSubmitting}
                    />
                    T√¥i ƒë·ªìng √Ω v·ªõi ƒëi·ªÅu kho·∫£n s·ª≠ d·ª•ng
                </label>
                {errors.agreeTerms && (
                    <span className='error'>{errors.agreeTerms}</span>
                )}
            </div>

            {errors.submit && <div className='error'>{errors.submit}</div>}

            <button type='submit' disabled={isSubmitting}>
                {isSubmitting ? 'ƒêang x·ª≠ l√Ω...' : 'ƒêƒÉng k√Ω'}
            </button>
        </form>
    );
}
```

### **Demo 2: Shopping Cart**

```jsx
function ShoppingCart() {
    const [cart, setCart] = useState([]);

    // Th√™m s·∫£n ph·∫©m v√†o gi·ªè
    const addToCart = (product) => {
        setCart((prevCart) => {
            const existingItem = prevCart.find(
                (item) => item.id === product.id
            );

            if (existingItem) {
                // TƒÉng quantity n·∫øu ƒë√£ c√≥
                return prevCart.map((item) =>
                    item.id === product.id
                        ? { ...item, quantity: item.quantity + 1 }
                        : item
                );
            }

            // Th√™m m·ªõi
            return [...prevCart, { ...product, quantity: 1 }];
        });
    };

    // X√≥a s·∫£n ph·∫©m
    const removeFromCart = (productId) => {
        setCart((prevCart) => prevCart.filter((item) => item.id !== productId));
    };

    // Update quantity
    const updateQuantity = (productId, newQuantity) => {
        if (newQuantity < 1) {
            removeFromCart(productId);
            return;
        }

        setCart((prevCart) =>
            prevCart.map((item) =>
                item.id === productId
                    ? { ...item, quantity: newQuantity }
                    : item
            )
        );
    };

    // T√≠nh t·ªïng
    const total = cart.reduce(
        (sum, item) => sum + item.price * item.quantity,
        0
    );
    const itemCount = cart.reduce((sum, item) => sum + item.quantity, 0);

    return (
        <div>
            <h2>Gi·ªè h√†ng ({itemCount} s·∫£n ph·∫©m)</h2>

            {cart.length === 0 ? (
                <p>Gi·ªè h√†ng tr·ªëng</p>
            ) : (
                <>
                    <ul>
                        {cart.map((item) => (
                            <li key={item.id}>
                                <span>{item.name}</span>
                                <span>
                                    {item.price.toLocaleString('vi-VN')}ƒë
                                </span>
                                <input
                                    type='number'
                                    value={item.quantity}
                                    onChange={(e) =>
                                        updateQuantity(
                                            item.id,
                                            parseInt(e.target.value) || 0
                                        )
                                    }
                                    min='1'
                                />
                                <button onClick={() => removeFromCart(item.id)}>
                                    X√≥a
                                </button>
                            </li>
                        ))}
                    </ul>

                    <div>
                        <strong>
                            T·ªïng c·ªông: {total.toLocaleString('vi-VN')}ƒë
                        </strong>
                    </div>

                    <button onClick={() => setCart([])}>X√≥a t·∫•t c·∫£</button>
                </>
            )}
        </div>
    );
}
```

---

## üî® PH·∫¶N 3: TH·ª∞C H√ÄNH (60-90 ph√∫t)

### **Exercise 1: Counter N√¢ng Cao**

```jsx
function AdvancedCounter() {
    // TODO:
    // 1. Count state
    // 2. Step size state (c√≥ th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c)
    // 3. History state (l∆∞u c√°c gi√° tr·ªã tr∆∞·ªõc ƒë√≥)
    // 4. Min/max limits
    // 5. C√°c n√∫t: +, -, Reset, Undo, Redo
    // 6. Hi·ªÉn th·ªã history

    return <div>{/* Your code */}</div>;
}
```

<details>
<summary><strong>üí° Nh·∫•n ƒë·ªÉ xem l·ªùi gi·∫£i</strong></summary>

```jsx
import { useState, type ChangeEvent } from 'react';

// TYPE DEFINITIONS
type Timeline = {
    past: number[],
    present: number,
    future: number[],
};

type Limits = {
    min: number,
    max: number,
};

// CONSTANTS
const INITIAL_COUNT = 0;
const INITIAL_STEP = 1;
const DEFAULT_LIMITS: Limits = { min: -10, max: 10 };

// HELPER FUNCTIONS

/**
 * Gi·ªõi h·∫°n gi√° tr·ªã trong kho·∫£ng min-max
 * T·∫†I SAO: ƒê·∫£m b·∫£o counter lu√¥n trong ph·∫°m vi cho ph√©p
 */
function clamp(value: number, min: number, max: number): number {
    return Math.min(Math.max(value, min), max);
}

/**
 * Validate v√† parse step input t·ª´ user
 * T·∫†I SAO: NgƒÉn step = 0 ho·∫∑c √¢m l√†m h·ªèng logic counter
 * EDGE CASE: Tr·∫£ v·ªÅ 1 n·∫øu input kh√¥ng h·ª£p l·ªá
 */
function parseStep(value: string): number {
    const parsed = parseInt(value, 10);
    return isNaN(parsed) || parsed <= 0 ? 1 : parsed;
}

// MAIN COMPONENT
function AdvancedCounter() {
    // STATE: Timeline cho ch·ª©c nƒÉng undo/redo
    const [timeline, setTimeline] =
        useState <
        Timeline >
        {
            past: [],
            present: INITIAL_COUNT,
            future: [],
        };

    // STATE: Step size (t√°ch ri√™ng kh·ªèi timeline - kh√¥ng c·∫ßn undo)
    const [step, setStep] = useState < number > INITIAL_STEP;

    // STATE: Gi·ªõi h·∫°n min/max (t√°ch ri√™ng kh·ªèi timeline)
    const [limits, setLimits] = useState < Limits > DEFAULT_LIMITS;

    // DERIVED STATE: Ki·ªÉm tra c√≥ th·ªÉ undo/redo kh√¥ng
    const canUndo = timeline.past.length > 0;
    const canRedo = timeline.future.length > 0;

    /**
     * C·∫≠p nh·∫≠t counter v·ªõi gi√° tr·ªã m·ªõi
     * T·∫†I SAO: T·∫≠p trung logic update timeline v√†o 1 ch·ªó
     * QUY T·∫ÆC: Action m·ªõi s·∫Ω xo√° future stack (chu·∫©n undo/redo)
     */
    const updateCount = (newValue: number): void => {
        const clampedValue = clamp(newValue, limits.min, limits.max);

        setTimeline((prev) => ({
            past: [...prev.past, prev.present],
            present: clampedValue,
            future: [], // QUY T·∫ÆC: Action m·ªõi xo√° redo stack
        }));
    };

    // HANDLERS
    const handleIncrement = (): void => {
        updateCount(timeline.present + step);
    };

    const handleDecrement = (): void => {
        updateCount(timeline.present - step);
    };

    /**
     * Reset v·ªÅ gi√° tr·ªã ban ƒë·∫ßu
     * EDGE CASE: Reset ƒë∆∞·ª£c coi l√† action m·ªõi (c√≥ th·ªÉ undo)
     */
    const handleReset = (): void => {
        updateCount(INITIAL_COUNT);
    };

    /**
     * Undo: Chuy·ªÉn present sang future, l·∫•y gi√° tr·ªã cu·ªëi t·ª´ past
     * EDGE CASE: Disabled khi past r·ªóng
     * EDGE CASE: Ph·∫£i clamp gi√° tr·ªã t·ª´ past n·∫øu v∆∞·ª£t limits hi·ªán t·∫°i
     */
    const handleUndo = (): void => {
        if (!canUndo) return;

        const previousValue = timeline.past[timeline.past.length - 1];
        const clampedValue = clamp(previousValue, limits.min, limits.max);

        setTimeline((prev) => ({
            past: prev.past.slice(0, -1),
            present: clampedValue,
            future: [prev.present, ...prev.future],
        }));
    };

    /**
     * Redo: Chuy·ªÉn present sang past, l·∫•y gi√° tr·ªã ƒë·∫ßu t·ª´ future
     * EDGE CASE: Disabled khi future r·ªóng
     * EDGE CASE: Ph·∫£i clamp gi√° tr·ªã t·ª´ future n·∫øu v∆∞·ª£t limits hi·ªán t·∫°i
     */
    const handleRedo = (): void => {
        if (!canRedo) return;

        const nextValue = timeline.future[0];
        const clampedValue = clamp(nextValue, limits.min, limits.max);

        setTimeline((prev) => ({
            past: [...prev.past, prev.present],
            present: clampedValue,
            future: prev.future.slice(1),
        }));
    };

    const handleStepChange = (e: ChangeEvent<HTMLInputElement>): void => {
        setStep(parseStep(e.target.value));
    };

    const handleMinChange = (e: ChangeEvent<HTMLInputElement>): void => {
        const newMin = parseInt(e.target.value, 10);
        if (!isNaN(newMin)) {
            setLimits((prev) => ({ ...prev, min: newMin }));
            // EDGE CASE: Re-clamp n·∫øu gi√° tr·ªã hi·ªán t·∫°i v∆∞·ª£t gi·ªõi h·∫°n m·ªõi
            const clamped = clamp(timeline.present, newMin, limits.max);
            if (clamped !== timeline.present) {
                updateCount(clamped);
            }
        }
    };

    const handleMaxChange = (e: ChangeEvent<HTMLInputElement>): void => {
        const newMax = parseInt(e.target.value, 10);
        if (!isNaN(newMax)) {
            setLimits((prev) => ({ ...prev, max: newMax }));
            // EDGE CASE: Re-clamp n·∫øu gi√° tr·ªã hi·ªán t·∫°i v∆∞·ª£t gi·ªõi h·∫°n m·ªõi
            const clamped = clamp(timeline.present, limits.min, newMax);
            if (clamped !== timeline.present) {
                updateCount(clamped);
            }
        }
    };

    return (
        <div className='counter'>
            <div className='counter__container'>
                {/* HEADER */}
                <h1 className='counter__title'>Advanced Counter</h1>

                {/* HI·ªÇN TH·ªä GI√Å TR·ªä HI·ªÜN T·∫†I */}
                <div className='counter__display'>
                    <div className='counter__display-label'>Current Count</div>
                    <div className='counter__display-value'>
                        {timeline.present}
                    </div>
                </div>

                {/* CONTROLS */}
                <div className='counter__controls'>
                    {/* INCREMENT / DECREMENT */}
                    <div className='counter__actions'>
                        <button
                            onClick={handleDecrement}
                            className='counter__button counter__button--decrement'
                            disabled={timeline.present <= limits.min}
                        >
                            - {step}
                        </button>
                        <button
                            onClick={handleIncrement}
                            className='counter__button counter__button--increment'
                            disabled={timeline.present >= limits.max}
                        >
                            + {step}
                        </button>
                    </div>

                    {/* UNDO / REDO / RESET */}
                    <div className='counter__actions'>
                        <button
                            onClick={handleUndo}
                            disabled={!canUndo}
                            className='counter__button counter__button--undo'
                        >
                            ‚Ü∂ Undo
                        </button>
                        <button
                            onClick={handleReset}
                            className='counter__button counter__button--reset'
                        >
                            Reset
                        </button>
                        <button
                            onClick={handleRedo}
                            disabled={!canRedo}
                            className='counter__button counter__button--redo'
                        >
                            ‚Ü∑ Redo
                        </button>
                    </div>
                </div>

                {/* SETTINGS */}
                <div className='counter__settings'>
                    <div className='counter__setting'>
                        <label className='counter__setting-label'>Step:</label>
                        <input
                            type='number'
                            value={step}
                            onChange={handleStepChange}
                            min='1'
                            className='counter__setting-input'
                        />
                    </div>
                    <div className='counter__setting'>
                        <label className='counter__setting-label'>Min:</label>
                        <input
                            type='number'
                            value={limits.min}
                            onChange={handleMinChange}
                            className='counter__setting-input'
                        />
                    </div>
                    <div className='counter__setting'>
                        <label className='counter__setting-label'>Max:</label>
                        <input
                            type='number'
                            value={limits.max}
                            onChange={handleMaxChange}
                            className='counter__setting-input'
                        />
                    </div>
                </div>

                {/* HI·ªÇN TH·ªä HISTORY */}
                <div className='counter__history'>
                    <h3 className='counter__history-title'>History</h3>
                    <div className='counter__history-list'>
                        {timeline.past.length === 0 && (
                            <span className='counter__history-empty'>
                                No history yet
                            </span>
                        )}
                        {timeline.past.map((value, index) => (
                            <span key={index} className='counter__history-item'>
                                {value}
                            </span>
                        ))}
                        {/* Gi√° tr·ªã hi·ªán t·∫°i ƒë∆∞·ª£c highlight */}
                        <span className='counter__history-item counter__history-item--current'>
                            {timeline.present}
                        </span>
                    </div>
                </div>

                {/* INFO */}
                <div className='counter__info'>
                    <p className='counter__info-text'>
                        Range: {limits.min} to {limits.max}
                    </p>
                    <p className='counter__info-text'>
                        History: {timeline.past.length} | Future:{' '}
                        {timeline.future.length}
                    </p>
                </div>
            </div>
        </div>
    );
}

export default AdvancedCounter;
```

**Unit Test ‚Äì AdvancedCounter.test.tsx**

```ts
import '@testing-library/jest-dom';
import { fireEvent, render, screen } from '@testing-library/react';
import AdvancedCounter from './AdvancedCounter';

// Helper function ƒë·ªÉ l·∫•y gi√° tr·ªã counter ch√≠nh (kh√¥ng ph·∫£i trong history)
const getCounterValue = (): HTMLElement => {
    return screen.getByText('Current Count').nextElementSibling as HTMLElement;
};

describe('AdvancedCounter', () => {
    describe('Basic increment/decrement', () => {
        test('should start at 0', () => {
            render(<AdvancedCounter />);
            expect(getCounterValue()).toHaveTextContent('0');
        });

        test('should increment by step size', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');

            fireEvent.click(incrementBtn);
            expect(getCounterValue()).toHaveTextContent('1');

            fireEvent.click(incrementBtn);
            expect(getCounterValue()).toHaveTextContent('2');
        });

        test('should decrement by step size', () => {
            render(<AdvancedCounter />);
            const decrementBtn = screen.getByText('- 1');

            fireEvent.click(decrementBtn);
            expect(getCounterValue()).toHaveTextContent('-1');
        });
    });

    describe('Step size modification', () => {
        test('should change step size and increment accordingly', () => {
            render(<AdvancedCounter />);
            const stepInput = screen.getByDisplayValue('1');

            // Thay ƒë·ªïi step th√†nh 5
            fireEvent.change(stepInput, { target: { value: '5' } });

            // N√∫t increment b√¢y gi·ªù ph·∫£i hi·ªÉn th·ªã +5
            expect(screen.getByText('+ 5')).toBeInTheDocument();

            // Click s·∫Ω c·ªông 5
            const incrementBtn = screen.getByText('+ 5');
            fireEvent.click(incrementBtn);
            expect(getCounterValue()).toHaveTextContent('5');
        });

        test('should handle invalid step input by defaulting to 1', () => {
            render(<AdvancedCounter />);
            const stepInput = screen.getByDisplayValue('1');

            // Th·ª≠ input kh√¥ng h·ª£p l·ªá: 0
            fireEvent.change(stepInput, { target: { value: '0' } });
            expect(screen.getByText('+ 1')).toBeInTheDocument();

            // Th·ª≠ input kh√¥ng h·ª£p l·ªá: s·ªë √¢m
            fireEvent.change(stepInput, { target: { value: '-5' } });
            expect(screen.getByText('+ 1')).toBeInTheDocument();
        });

        test('should handle non-numeric step input', () => {
            render(<AdvancedCounter />);
            const stepInput = screen.getByDisplayValue('1');

            // Th·ª≠ input ch·ªØ
            fireEvent.change(stepInput, { target: { value: 'abc' } });
            expect(screen.getByText('+ 1')).toBeInTheDocument();
        });
    });

    describe('Min/Max limits', () => {
        test('should clamp value at max limit', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');

            // Click 15 l·∫ßn (max l√† 10)
            for (let i = 0; i < 15; i++) {
                fireEvent.click(incrementBtn);
            }

            // Ph·∫£i d·ª´ng ·ªü 10
            expect(getCounterValue()).toHaveTextContent('10');
        });

        test('should clamp value at min limit', () => {
            render(<AdvancedCounter />);
            const decrementBtn = screen.getByText('- 1');

            // Click 15 l·∫ßn (min l√† -10)
            for (let i = 0; i < 15; i++) {
                fireEvent.click(decrementBtn);
            }

            // Ph·∫£i d·ª´ng ·ªü -10
            expect(getCounterValue()).toHaveTextContent('-10');
        });

        test('should disable increment button at max', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');

            // ƒêi ƒë·∫øn max
            for (let i = 0; i < 10; i++) {
                fireEvent.click(incrementBtn);
            }

            expect(incrementBtn).toBeDisabled();
        });

        test('should disable decrement button at min', () => {
            render(<AdvancedCounter />);
            const decrementBtn = screen.getByText('- 1');

            // ƒêi ƒë·∫øn min
            for (let i = 0; i < 10; i++) {
                fireEvent.click(decrementBtn);
            }

            expect(decrementBtn).toBeDisabled();
        });

        test('should enable increment button when below max', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');

            // ƒêi ƒë·∫øn max
            for (let i = 0; i < 10; i++) {
                fireEvent.click(incrementBtn);
            }

            expect(incrementBtn).toBeDisabled();

            // Undo v·ªÅ 9
            const undoBtn = screen.getByText('‚Ü∂ Undo');
            fireEvent.click(undoBtn);

            // Button ph·∫£i enable l·∫°i
            expect(incrementBtn).not.toBeDisabled();
        });

        test('should enable decrement button when above min', () => {
            render(<AdvancedCounter />);
            const decrementBtn = screen.getByText('- 1');

            // ƒêi ƒë·∫øn min
            for (let i = 0; i < 10; i++) {
                fireEvent.click(decrementBtn);
            }

            expect(decrementBtn).toBeDisabled();

            // Undo v·ªÅ -9
            const undoBtn = screen.getByText('‚Ü∂ Undo');
            fireEvent.click(undoBtn);

            // Button ph·∫£i enable l·∫°i
            expect(decrementBtn).not.toBeDisabled();
        });
    });

    describe('Undo/Redo functionality', () => {
        test('should undo to previous value', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(incrementBtn); // 1 -> 2

            expect(getCounterValue()).toHaveTextContent('2');

            fireEvent.click(undoBtn); // 2 -> 1
            expect(getCounterValue()).toHaveTextContent('1');
        });

        test('should undo multiple times', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(incrementBtn); // 1 -> 2
            fireEvent.click(incrementBtn); // 2 -> 3

            fireEvent.click(undoBtn); // 3 -> 2
            fireEvent.click(undoBtn); // 2 -> 1
            fireEvent.click(undoBtn); // 1 -> 0

            expect(getCounterValue()).toHaveTextContent('0');
        });

        test('should redo after undo', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');
            const redoBtn = screen.getByText('‚Ü∑ Redo');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(undoBtn); // 1 -> 0
            fireEvent.click(redoBtn); // 0 -> 1

            expect(getCounterValue()).toHaveTextContent('1');
        });

        test('should redo multiple times', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');
            const redoBtn = screen.getByText('‚Ü∑ Redo');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(incrementBtn); // 1 -> 2
            fireEvent.click(incrementBtn); // 2 -> 3

            fireEvent.click(undoBtn); // 3 -> 2
            fireEvent.click(undoBtn); // 2 -> 1

            fireEvent.click(redoBtn); // 1 -> 2
            fireEvent.click(redoBtn); // 2 -> 3

            expect(getCounterValue()).toHaveTextContent('3');
        });

        test('should disable undo when no history', () => {
            render(<AdvancedCounter />);
            const undoBtn = screen.getByText('‚Ü∂ Undo');

            expect(undoBtn).toBeDisabled();
        });

        test('should enable undo after first action', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');

            expect(undoBtn).toBeDisabled();

            fireEvent.click(incrementBtn);

            expect(undoBtn).not.toBeDisabled();
        });

        test('should disable redo when no future', () => {
            render(<AdvancedCounter />);
            const redoBtn = screen.getByText('‚Ü∑ Redo');

            expect(redoBtn).toBeDisabled();
        });

        test('should enable redo after undo', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');
            const redoBtn = screen.getByText('‚Ü∑ Redo');

            fireEvent.click(incrementBtn);

            expect(redoBtn).toBeDisabled();

            fireEvent.click(undoBtn);

            expect(redoBtn).not.toBeDisabled();
        });

        test('should clear redo stack on new action', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const decrementBtn = screen.getByText('- 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');
            const redoBtn = screen.getByText('‚Ü∑ Redo');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(incrementBtn); // 1 -> 2
            fireEvent.click(undoBtn); // 2 -> 1 (redo available)

            expect(redoBtn).not.toBeDisabled();

            fireEvent.click(decrementBtn); // 1 -> 0 (ph·∫£i clear redo)

            expect(redoBtn).toBeDisabled();
        });

        test('should maintain correct undo/redo with mixed operations', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const decrementBtn = screen.getByText('- 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');
            const redoBtn = screen.getByText('‚Ü∑ Redo');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(incrementBtn); // 1 -> 2
            fireEvent.click(decrementBtn); // 2 -> 1

            fireEvent.click(undoBtn); // 1 -> 2
            expect(getCounterValue()).toHaveTextContent('2');

            fireEvent.click(undoBtn); // 2 -> 1
            expect(getCounterValue()).toHaveTextContent('1');

            fireEvent.click(redoBtn); // 1 -> 2
            expect(getCounterValue()).toHaveTextContent('2');
        });
    });

    describe('Reset functionality', () => {
        test('should reset to initial value (0)', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const resetBtn = screen.getByText('Reset');

            fireEvent.click(incrementBtn);
            fireEvent.click(incrementBtn);
            expect(getCounterValue()).toHaveTextContent('2');

            fireEvent.click(resetBtn);
            expect(getCounterValue()).toHaveTextContent('0');
        });

        test('should reset from negative values', () => {
            render(<AdvancedCounter />);
            const decrementBtn = screen.getByText('- 1');
            const resetBtn = screen.getByText('Reset');

            fireEvent.click(decrementBtn);
            fireEvent.click(decrementBtn);
            expect(getCounterValue()).toHaveTextContent('-2');

            fireEvent.click(resetBtn);
            expect(getCounterValue()).toHaveTextContent('0');
        });

        test('should allow undo after reset', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const resetBtn = screen.getByText('Reset');
            const undoBtn = screen.getByText('‚Ü∂ Undo');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(resetBtn); // 1 -> 0
            fireEvent.click(undoBtn); // 0 -> 1

            expect(getCounterValue()).toHaveTextContent('1');
        });

        test('should clear redo stack after reset', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const resetBtn = screen.getByText('Reset');
            const undoBtn = screen.getByText('‚Ü∂ Undo');
            const redoBtn = screen.getByText('‚Ü∑ Redo');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(undoBtn); // 1 -> 0

            expect(redoBtn).not.toBeDisabled();

            fireEvent.click(resetBtn); // Reset (clears redo)

            expect(redoBtn).toBeDisabled();
        });
    });

    describe('History display', () => {
        test('should show "No history yet" initially', () => {
            render(<AdvancedCounter />);
            expect(screen.getByText('No history yet')).toBeInTheDocument();
        });

        test('should display past values in history', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(incrementBtn); // 1 -> 2

            // History ph·∫£i hi·ªÉn th·ªã: 0, 1, [2 l√† current]
            const historySection = screen.getByText('History').parentElement;
            expect(historySection).toHaveTextContent('0');
            expect(historySection).toHaveTextContent('1');
        });

        test('should hide "No history yet" after first action', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');

            expect(screen.getByText('No history yet')).toBeInTheDocument();

            fireEvent.click(incrementBtn);

            expect(
                screen.queryByText('No history yet')
            ).not.toBeInTheDocument();
        });

        test('should update history on each action', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const decrementBtn = screen.getByText('- 1');

            fireEvent.click(incrementBtn); // 0 -> 1
            fireEvent.click(incrementBtn); // 1 -> 2
            fireEvent.click(decrementBtn); // 2 -> 1

            const historySection = screen.getByText('History').parentElement;
            expect(historySection).toHaveTextContent('0');
            expect(historySection).toHaveTextContent('2');
        });
    });

    describe('Edge cases with limit changes', () => {
        test('should re-clamp when max is reduced below current value', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const maxInput = screen.getByDisplayValue('10');

            // ƒêi ƒë·∫øn 5
            for (let i = 0; i < 5; i++) {
                fireEvent.click(incrementBtn);
            }
            expect(getCounterValue()).toHaveTextContent('5');

            // ƒê·ªïi max th√†nh 3 (ph·∫£i clamp 5 -> 3)
            fireEvent.change(maxInput, { target: { value: '3' } });
            expect(getCounterValue()).toHaveTextContent('3');
        });

        test('should re-clamp when min is increased above current value', () => {
            render(<AdvancedCounter />);
            const decrementBtn = screen.getByText('- 1');
            const minInput = screen.getByDisplayValue('-10');

            // ƒêi ƒë·∫øn -5
            for (let i = 0; i < 5; i++) {
                fireEvent.click(decrementBtn);
            }
            expect(getCounterValue()).toHaveTextContent('-5');

            // ƒê·ªïi min th√†nh -3 (ph·∫£i clamp -5 -> -3)
            fireEvent.change(minInput, { target: { value: '-3' } });
            expect(getCounterValue()).toHaveTextContent('-3');
        });

        test('should not change value when limits still contain current value', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const maxInput = screen.getByDisplayValue('10');

            // ƒêi ƒë·∫øn 5
            for (let i = 0; i < 5; i++) {
                fireEvent.click(incrementBtn);
            }
            expect(getCounterValue()).toHaveTextContent('5');

            // ƒê·ªïi max th√†nh 8 (5 v·∫´n trong range, kh√¥ng ƒë·ªïi)
            fireEvent.change(maxInput, { target: { value: '8' } });
            expect(getCounterValue()).toHaveTextContent('5');
        });

        test('should handle negative min/max values', () => {
            render(<AdvancedCounter />);
            const minInput = screen.getByDisplayValue('-10');
            const maxInput = screen.getByDisplayValue('10');

            // Set range t·ª´ -50 ƒë·∫øn -10
            fireEvent.change(minInput, { target: { value: '-50' } });
            fireEvent.change(maxInput, { target: { value: '-10' } });

            // Current value (0) ph·∫£i clamp v·ªÅ -10
            expect(getCounterValue()).toHaveTextContent('-10');
        });
    });

    describe('Info display', () => {
        test('should display correct range', () => {
            render(<AdvancedCounter />);
            expect(screen.getByText('Range: -10 to 10')).toBeInTheDocument();
        });

        test('should update range display when limits change', () => {
            render(<AdvancedCounter />);
            const minInput = screen.getByDisplayValue('-10');
            const maxInput = screen.getByDisplayValue('10');

            fireEvent.change(minInput, { target: { value: '-20' } });
            fireEvent.change(maxInput, { target: { value: '30' } });

            expect(screen.getByText('Range: -20 to 30')).toBeInTheDocument();
        });

        test('should display correct history and future counts', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');

            // Ban ƒë·∫ßu: History: 0 | Future: 0
            expect(
                screen.getByText(/History: 0 \| Future: 0/)
            ).toBeInTheDocument();

            fireEvent.click(incrementBtn);
            fireEvent.click(incrementBtn);

            // History: 2 | Future: 0
            expect(
                screen.getByText(/History: 2 \| Future: 0/)
            ).toBeInTheDocument();

            fireEvent.click(undoBtn);

            // History: 1 | Future: 1
            expect(
                screen.getByText(/History: 1 \| Future: 1/)
            ).toBeInTheDocument();
        });
    });

    describe('Integration tests', () => {
        test('should handle complex workflow correctly', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const undoBtn = screen.getByText('‚Ü∂ Undo');
            const redoBtn = screen.getByText('‚Ü∑ Redo');
            const resetBtn = screen.getByText('Reset');
            const stepInput = screen.getByDisplayValue('1');

            // Workflow: increment -> change step -> increment -> undo -> redo -> reset
            fireEvent.click(incrementBtn); // 0 -> 1

            fireEvent.change(stepInput, { target: { value: '3' } });
            const newIncrementBtn = screen.getByText('+ 3');
            fireEvent.click(newIncrementBtn); // 1 -> 4

            expect(getCounterValue()).toHaveTextContent('4');

            fireEvent.click(undoBtn); // 4 -> 1
            expect(getCounterValue()).toHaveTextContent('1');

            fireEvent.click(redoBtn); // 1 -> 4
            expect(getCounterValue()).toHaveTextContent('4');

            fireEvent.click(resetBtn); // 4 -> 0
            expect(getCounterValue()).toHaveTextContent('0');
        });

        test('should handle edge case workflow with limits', () => {
            render(<AdvancedCounter />);
            const incrementBtn = screen.getByText('+ 1');
            const maxInput = screen.getByDisplayValue('10');
            const undoBtn = screen.getByText('‚Ü∂ Undo');

            // Go to 8
            for (let i = 0; i < 8; i++) {
                fireEvent.click(incrementBtn);
            }
            expect(getCounterValue()).toHaveTextContent('8');

            // Reduce max to 5
            fireEvent.change(maxInput, { target: { value: '5' } });
            // Counter ph·∫£i clamp v·ªÅ 5
            expect(getCounterValue()).toHaveTextContent('5');

            // B√¢y gi·ªù th·ª≠ decrement (ph·∫£i ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng)
            const decrementBtn = screen.getByText('- 1');
            fireEvent.click(decrementBtn);
            expect(getCounterValue()).toHaveTextContent('4');

            // Undo v·ªÅ 5
            fireEvent.click(undoBtn);
            expect(getCounterValue()).toHaveTextContent('5');

            // Undo l·∫°i l·∫ßn n·ªØa - v·ªÅ 8 nh∆∞ng ph·∫£i clamp v·ªÅ 5 (v√¨ max = 5)
            fireEvent.click(undoBtn);
            expect(getCounterValue()).toHaveTextContent('5');
        });
    });
});
```

</details>

### **Exercise 2: Todo App Ho√†n Ch·ªânh**

```jsx
function TodoApp() {
    // TODO:
    // 1. Todos array state v·ªõi: id, text, completed, priority, createdAt
    // 2. Input state
    // 3. Filter state (all/active/completed)
    // 4. Sort state (date/priority/alphabetical)
    // 5. Ch·ª©c nƒÉng:
    //    - Th√™m todo
    //    - X√≥a todo
    //    - Toggle completed
    //    - Edit todo (inline editing)
    //    - Set priority (low/medium/high)
    //    - Filter v√† sort
    //    - Clear completed
    //    - Toggle all
    // 6. Save v√†o localStorage
    // 7. Stats: total, active, completed

    return <div>{/* Your code */}</div>;
}
```

<details>
<summary><strong>üí° Nh·∫•n ƒë·ªÉ xem l·ªùi gi·∫£i</strong></summary>

```jsx
import { useEffect, useMemo, useState } from 'react';

/* =======================
   Types
======================= */
type Priority = 'low' | 'medium' | 'high';

type Todo = {
  id: string;
  text: string;
  completed: boolean;
  priority: Priority;
  createdAt: number;
};

type Filter = 'all' | 'active' | 'completed';
type Sort = 'date' | 'priority' | 'alphabetical';

/* =======================
   Constants
======================= */
const STORAGE_KEY = 'todo_app_v1';
const PRIORITY_ORDER: Priority[] = ['low', 'medium', 'high'];

/* =======================
   Utils
======================= */
// WHY: isolate creation logic ‚Üí d·ªÖ test, d·ªÖ thay ƒë·ªïi default
const createTodo = (text: string): Todo => ({
  id: crypto.randomUUID(),
  text,
  completed: false,
  priority: 'low', // ‚úÖ default priority
  createdAt: Date.now(),
});

const formatDate = (timestamp: number): string =>
  new Date(timestamp).toLocaleString();

/* =======================
   Component
======================= */
export default function TodoApp() {
  /* ---------- State ---------- */
  const [todos, setTodos] = useState<Todo[]>(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      return raw ? (JSON.parse(raw) as Todo[]) : [];
    } catch {
      return [];
    }
  });

  const [input, setInput] = useState('');
  const [filter, setFilter] = useState<Filter>('all');
  const [sort, setSort] = useState<Sort>('date');

  // Inline edit state
  const [editId, setEditId] = useState<string | null>(null);
  const [editText, setEditText] = useState('');
  const [editPriority, setEditPriority] = useState<Priority>('low');

  /* ---------- Effects ---------- */
  // Sync todos ‚Üí localStorage on every mutation
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(todos));
  }, [todos]);

  /* ---------- Derived State ---------- */
  const stats = useMemo(() => {
    const total = todos.length;
    const completed = todos.filter(t => t.completed).length;

    return {
      total,
      completed,
      active: total - completed,
    };
  }, [todos]);

  const visibleTodos = useMemo(() => {
    let result = [...todos];

    // Filter
    if (filter === 'active') {
      result = result.filter(t => !t.completed);
    }
    if (filter === 'completed') {
      result = result.filter(t => t.completed);
    }

    // Sort
    switch (sort) {
      case 'alphabetical':
        result.sort((a, b) => a.text.localeCompare(b.text));
        break;
      case 'priority':
        result.sort(
          (a, b) =>
            PRIORITY_ORDER.indexOf(b.priority) -
            PRIORITY_ORDER.indexOf(a.priority)
        );
        break;
      case 'date':
      default:
        result.sort((a, b) => b.createdAt - a.createdAt);
    }

    return result;
  }, [todos, filter, sort]);

  /* ---------- Handlers ---------- */
  const addTodo = () => {
    if (!input.trim()) return;

    setTodos(prev => [...prev, createTodo(input.trim())]);
    setInput('');
  };

  const toggleTodo = (id: string) => {
    setTodos(prev =>
      prev.map(todo =>
        todo.id === id
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };

  const deleteTodo = (id: string) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };

  const toggleAll = () => {
    // WHY: derived state ‚Üí kh√¥ng l∆∞u state ph·ª•
    const allCompleted = todos.every(todo => todo.completed);

    setTodos(prev =>
      prev.map(todo => ({ ...todo, completed: !allCompleted }))
    );
  };

  const clearCompleted = () => {
    setTodos(prev => prev.filter(todo => !todo.completed));
  };

  /* ---------- Inline Edit ---------- */
  const startEdit = (todo: Todo) => {
    setEditId(todo.id);
    setEditText(todo.text);
    setEditPriority(todo.priority);
  };

  const commitEdit = () => {
    if (!editId) return;

    setTodos(prev =>
      prev.map(todo =>
        todo.id === editId
          ? {
              ...todo,
              text: editText.trim(),
              priority: editPriority,
            }
          : todo
      )
    );

    setEditId(null);
    setEditText('');
    setEditPriority('low');
  };

  /* ---------- Render ---------- */
  return (
    <div className="todo-app">
      <h1 className="todo-app__title">Todo App</h1>

      {/* Input */}
      <div className="todo-app__input">
        <input
          value={input}
          onChange={e => setInput(e.target.value)}
          onKeyDown={e => e.key === 'Enter' && addTodo()}
          placeholder="Add new todo"
        />
        <button onClick={addTodo}>Add</button>
      </div>

      {/* Controls */}
      <div className="todo-app__controls">
        <button onClick={toggleAll}>Toggle All</button>
        <button onClick={clearCompleted}>Clear Completed</button>
      </div>

      {/* List */}
      <ul className="todo-list">
        {visibleTodos.map(todo => (
          <li key={todo.id} className="todo-item">
            <span className="todo-item__id">{todo.id}</span>

            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />

            {editId === todo.id ? (
              <>
                <input
                  className="todo-item__edit-text"
                  value={editText}
                  onChange={e => setEditText(e.target.value)}
                  onBlur={commitEdit}
                  onKeyDown={e => e.key === 'Enter' && commitEdit()}
                  autoFocus
                />

                <select
                  className="todo-item__edit-priority"
                  value={editPriority}
                  onChange={e =>
                    setEditPriority(e.target.value as Priority)
                  }
                >
                  <option value="low">Low</option>
                  <option value="medium">Medium</option>
                  <option value="high">High</option>
                </select>
              </>
            ) : (
              <>
                <span
                  className={`todo-item__text ${
                    todo.completed ? 'todo-item__text--completed' : ''
                  }`}
                >
                  {todo.text}
                </span>

                <span className="todo-item__priority">
                  {todo.priority}
                </span>

                <span className="todo-item__date">
                  {formatDate(todo.createdAt)}
                </span>
              </>
            )}

            <button onClick={() => startEdit(todo)}>Edit</button>
            <button onClick={() => deleteTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>

      {/* Stats */}
      <footer className="todo-app__stats">
        Total: {stats.total} | Active: {stats.active} | Completed:{' '}
        {stats.completed}
      </footer>
    </div>
  );
}

```

**Unit Test ‚Äì TodoApp.test.tsx**

```ts
import { describe, expect, it, beforeEach, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import TodoApp from './TodoApp';

/* =======================
   Helpers
======================= */
const addTodo = (text: string) => {
    const input = screen.getByPlaceholderText(/add new todo/i);
    fireEvent.change(input, { target: { value: text } });
    fireEvent.keyDown(input, { key: 'Enter', code: 'Enter' });
};

/* =======================
   Tests
======================= */
describe('TodoApp', () => {
    beforeEach(() => {
        // Clear localStorage before each test
        localStorage.clear();
    });

    it('adds a new todo with default priority = low', () => {
        render(<TodoApp />);

        addTodo('Learn React');

        expect(screen.getByText('Learn React')).toBeInTheDocument();
        expect(screen.getByText('low')).toBeInTheDocument();
    });

    it('toggles completed state', () => {
        render(<TodoApp />);

        addTodo('Task 1');

        const checkbox = screen.getByRole('checkbox');
        fireEvent.click(checkbox);

        expect(screen.getByText('Task 1')).toHaveClass(
            'todo-item__text--completed'
        );
    });

    it('edits todo text and priority', () => {
        render(<TodoApp />);

        addTodo('Old Task');

        fireEvent.click(screen.getByText('Edit'));

        const input = screen.getByDisplayValue('Old Task');
        fireEvent.change(input, { target: { value: 'New Task' } });

        const select = screen.getByDisplayValue('low');
        fireEvent.change(select, { target: { value: 'high' } });

        fireEvent.blur(input);

        expect(screen.getByText('New Task')).toBeInTheDocument();
        expect(screen.getByText('high')).toBeInTheDocument();
    });

    it('toggle all completes all todos when not all completed', () => {
        render(<TodoApp />);

        addTodo('Task A');
        addTodo('Task B');

        fireEvent.click(screen.getByText('Toggle All'));

        const checkboxes = screen.getAllByRole('checkbox');
        checkboxes.forEach((cb) => expect(cb).toBeChecked());
    });

    it('toggle all un-completes all todos when all completed', () => {
        render(<TodoApp />);

        addTodo('Task A');
        addTodo('Task B');

        fireEvent.click(screen.getByText('Toggle All'));
        fireEvent.click(screen.getByText('Toggle All'));

        const checkboxes = screen.getAllByRole('checkbox');
        checkboxes.forEach((cb) => expect(cb).not.toBeChecked());
    });

    it('clears completed todos', () => {
        render(<TodoApp />);

        addTodo('Task 1');
        addTodo('Task 2');

        const checkboxes = screen.getAllByRole('checkbox');
        fireEvent.click(checkboxes[0]);

        fireEvent.click(screen.getByText('Clear Completed'));

        expect(screen.queryByText('Task 1')).not.toBeInTheDocument();
        expect(screen.getByText('Task 2')).toBeInTheDocument();
    });

    it('updates stats correctly', () => {
        render(<TodoApp />);

        addTodo('Task 1');
        addTodo('Task 2');

        fireEvent.click(screen.getAllByRole('checkbox')[0]);

        expect(screen.getByText(/total: 2/i)).toBeInTheDocument();
        expect(screen.getByText(/active: 1/i)).toBeInTheDocument();
        expect(screen.getByText(/completed: 1/i)).toBeInTheDocument();
    });

    it('persists todos to localStorage', () => {
        render(<TodoApp />);

        addTodo('Persist me');

        const stored = JSON.parse(localStorage.getItem('todo_app_v1') ?? '[]');

        expect(stored).toHaveLength(1);
        expect(stored[0].text).toBe('Persist me');
    });
});
```

</details>

### **Exercise 3: Multi-Step Form**

```jsx
function MultiStepForm() {
    // TODO:
    // 1. Current step state (1, 2, 3)
    // 2. Form data state cho m·ªói step:
    //    Step 1: Personal info (name, email, phone)
    //    Step 2: Address (street, city, postal code)
    //    Step 3: Payment (card number, expiry, cvv)
    // 3. Errors state cho m·ªói step
    // 4. Validation cho m·ªói step
    // 5. N√∫t: Next, Previous, Submit
    // 6. Progress bar
    // 7. Review t·∫•t c·∫£ data ·ªü step cu·ªëi
    // 8. Kh√¥ng cho next n·∫øu step hi·ªán t·∫°i invalid

    return <div>{/* Your code */}</div>;
}
```

### **Exercise 4: Quiz App**

```jsx
const quizData = [
    {
        id: 1,
        question: 'React ƒë∆∞·ª£c t·∫°o b·ªüi?',
        options: ['Google', 'Facebook', 'Microsoft', 'Apple'],
        correctAnswer: 1,
    },
    // More questions...
];

function QuizApp() {
    // TODO:
    // 1. Current question index state
    // 2. Selected answers state (array)
    // 3. Show result state (boolean)
    // 4. Time remaining state (optional - countdown timer)
    // 5. Ch·ª©c nƒÉng:
    //    - Select answer
    //    - Next question
    //    - Previous question
    //    - Submit quiz
    //    - Show score
    //    - Restart quiz
    // 6. Highlight correct/incorrect answers khi submit
    // 7. Progress indicator
    // 8. Prevent changing answer after submit

    return <div>{/* Your code */}</div>;
}
```

### **Exercise 5: Expense Tracker (Challenge)**

```jsx
function ExpenseTracker() {
    // TODO:
    // 1. Expenses array state: { id, description, amount, category, date }
    // 2. Categories: ['ƒÇn u·ªëng', 'Di chuy·ªÉn', 'Gi·∫£i tr√≠', 'Mua s·∫Øm', 'Kh√°c']
    // 3. Filter state: { category, dateRange, minAmount, maxAmount }
    // 4. Form state cho add/edit expense
    // 5. Ch·ª©c nƒÉng:
    //    - Add expense
    //    - Edit expense
    //    - Delete expense
    //    - Filter by category
    //    - Filter by date range
    //    - Filter by amount range
    //    - Search by description
    // 6. Th·ªëng k√™:
    //    - T·ªïng chi ti√™u
    //    - Chi ti√™u theo category (pie chart ho·∫∑c bars)
    //    - Chi ti√™u theo th√°ng
    //    - Category chi nhi·ªÅu nh·∫•t
    // 7. Sort options: date, amount, category
    // 8. Export data (JSON)
    // 9. Import data
    // 10. LocalStorage persistence

    const [expenses, setExpenses] = useState(() => {
        const saved = localStorage.getItem('expenses');
        return saved ? JSON.parse(saved) : [];
    });

    const [formData, setFormData] = useState({
        description: '',
        amount: '',
        category: 'ƒÇn u·ªëng',
        date: new Date().toISOString().split('T')[0],
    });

    const [filters, setFilters] = useState({
        category: 'all',
        searchTerm: '',
        dateFrom: '',
        dateTo: '',
        minAmount: '',
        maxAmount: '',
    });

    const [editingId, setEditingId] = useState(null);

    // TODO: Implement c√°c functions:
    // - addExpense
    // - updateExpense
    // - deleteExpense
    // - getFilteredExpenses
    // - getStatistics
    // - exportData
    // - importData

    return (
        <div className='expense-tracker'>
            <h1>Qu·∫£n L√Ω Chi Ti√™u</h1>

            {/* Add/Edit Form */}
            <div className='expense-form'>{/* Your form code */}</div>

            {/* Filters */}
            <div className='filters'>{/* Your filters code */}</div>

            {/* Statistics */}
            <div className='statistics'>{/* Your statistics code */}</div>

            {/* Expense List */}
            <div className='expense-list'>{/* Your list code */}</div>
        </div>
    );
}
```

---

## ‚úÖ PH·∫¶N 4: REVIEW & CHECKLIST (15-30 ph√∫t)

### **useState Basics:**

-   [ ] Syntax: `const [state, setState] = useState(initialValue)`
-   [ ] Naming convention: `[thing, setThing]`
-   [ ] Hooks ph·∫£i ·ªü top level
-   [ ] Kh√¥ng ƒë∆∞·ª£c trong if/loop/nested function

### **State Types:**

-   [ ] Primitives: number, string, boolean
-   [ ] Objects: d√πng spread `{...obj, key: value}`
-   [ ] Arrays: d√πng spread `[...arr, item]` ho·∫∑c methods nh∆∞ `map`, `filter`
-   [ ] Tr√°nh mutating methods: `push`, `pop`, `splice`, `sort`

### **Lazy Initialization:**

-   [ ] D√πng function: `useState(() => expensiveCalculation())`
-   [ ] Ch·ªâ ch·∫°y m·ªôt l·∫ßn khi mount
-   [ ] D√πng cho localStorage, t√≠nh to√°n ph·ª©c t·∫°p

### **Functional Updates:**

-   [ ] Syntax: `setState(prev => newValue)`
-   [ ] D√πng khi state m·ªõi ph·ª• thu·ªôc state c≈©
-   [ ] Tr√°nh stale closure trong useEffect/timers

### **Immutability:**

-   [ ] KH√îNG mutate state tr·ª±c ti·∫øp
-   [ ] Lu√¥n t·∫°o object/array M·ªöI
-   [ ] D√πng spread operator
-   [ ] React so s√°nh b·∫±ng reference

### **Best Practices:**

-   [ ] Nh√≥m related state
-   [ ] Tr√°nh redundant state (derived state)
-   [ ] Tr√°nh duplicate props v√†o state
-   [ ] Structure state t·ªët (flat ho·∫∑c normalized)

### **Common Mistakes:**

```jsx
// ‚ùå Mutate state tr·ª±c ti·∫øp
user.name = 'New'; // NEVER!
setUser(user);

// ‚ùå Kh√¥ng d√πng functional update
setCount(count + 1);
setCount(count + 1); // V·∫´n ch·ªâ +1, kh√¥ng ph·∫£i +2

// ‚ùå Hooks trong ƒëi·ªÅu ki·ªán
if (condition) {
    const [state, setState] = useState(0); // Error!
}

// ‚ùå Array mutation
todos.push(newTodo); // NEVER!
setTodos(todos);

// ‚ùå Redundant state
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const [fullName, setFullName] = useState(''); // Kh√¥ng c·∫ßn!

// ‚úÖ ƒê√öNG
setUser({ ...user, name: 'New' });

setCount((prev) => prev + 1);
setCount((prev) => prev + 1); // ƒê√∫ng +2

// Top level
const [state, setState] = useState(0);

setTodos([...todos, newTodo]);

// Derived state
const fullName = `${firstName} ${lastName}`;
```

---

## üéØ HOMEWORK

### **1. Notes App**

T·∫°o ·ª©ng d·ª•ng ghi ch√∫:

-   CRUD operations (Create, Read, Update, Delete)
-   Categories/Tags
-   Search functionality
-   Rich text formatting (optional)
-   Pin/Favorite notes
-   Sort by: date, title, modified
-   LocalStorage persistence
-   Export/Import notes

### **2. Budget Planner**

Qu·∫£n l√Ω ng√¢n s√°ch c√° nh√¢n:

```jsx
// State structure
{
  income: { amount, source, date },
  expenses: [{ amount, category, date, recurring }],
  budget: { category: limit },
  savings: { goal, current, deadline }
}

// Features:
// - Set income
// - Add/edit/delete expenses
// - Set budget limits per category
// - Alerts khi v∆∞·ª£t budget
// - Savings goal tracker
// - Monthly/yearly reports
// - Recurring expenses
```

### **3. Habit Tracker**

Theo d√µi th√≥i quen h√†ng ng√†y:

```jsx
// State structure
{
    habits: [
        {
            id,
            name,
            goal, // 'daily', 'weekly', s·ªë l·∫ßn
            streak,
            history: { date: completed },
        },
    ];
}

// Features:
// - Add/edit/delete habits
// - Mark as completed
// - Current streak
// - Best streak
// - Calendar view
// - Statistics
// - Reminders (optional)
```

### **4. Recipe Book**

S·ªï c√¥ng th·ª©c n·∫•u ƒÉn:

```jsx
// State structure
{
  recipes: [
    {
      id,
      title,
      ingredients: [{ name, amount, unit }],
      steps: [],
      prepTime,
      cookTime,
      servings,
      difficulty,
      category,
      tags,
      image,
      rating,
      notes
    }
  ],
  shoppingList: []
}

// Features:
// - Add/edit/delete recipes
// - Search and filter
// - Scale servings
// - Add to shopping list
// - Rate recipes
// - Categories and tags
// - Favorite recipes
```

### **5. Pomodoro Timer v·ªõi Stats (Challenge)**

Timer l√†m vi·ªác v·ªõi th·ªëng k√™:

```jsx
// State structure
{
  timer: {
    minutes,
    seconds,
    isRunning,
    mode // 'work', 'shortBreak', 'longBreak'
  },
  settings: {
    workDuration,
    shortBreakDuration,
    longBreakDuration,
    sessionsUntilLongBreak
  },
  sessions: [
    {
      date,
      completedPomodoros,
      totalFocusTime,
      tasks: [{ name, pomodoros }]
    }
  ],
  currentTask: { name, estimatedPomodoros, completed }
}

// Features:
// - Customizable durations
// - Auto-switch between work/break
// - Task list v·ªõi pomodoro estimates
// - Daily/weekly statistics
// - Focus time trends
// - Browser notifications
// - Sound alerts
// - Background work tracking
```

---

## üìö ƒê·ªçc Th√™m

### **Official Docs:**

-   [React - useState](https://react.dev/reference/react/useState)
-   [React - State as a Snapshot](https://react.dev/learn/state-as-a-snapshot)
-   [React - Queueing State Updates](https://react.dev/learn/queueing-a-series-of-state-updates)
-   [React - Updating Objects in State](https://react.dev/learn/updating-objects-in-state)
-   [React - Updating Arrays in State](https://react.dev/learn/updating-arrays-in-state)

### **Advanced Topics:**

-   [Kent C. Dodds - Don't Sync State. Derive It!](https://kentcdodds.com/blog/dont-sync-state-derive-it)
-   [Dan Abramov - A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

---

## üìù Key Takeaways

1. **useState = State Management c∆° b·∫£n nh·∫•t** trong React hooks
2. **Immutability is KEY** - Lu√¥n t·∫°o object/array m·ªõi
3. **Functional Updates** - D√πng khi state m·ªõi ph·ª• thu·ªôc state c≈©
4. **Lazy Initialization** - Optimize performance cho initial state ph·ª©c t·∫°p
5. **State Structure** - Thi·∫øt k·∫ø t·ªët gi√∫p code d·ªÖ maintain
6. **Avoid Redundancy** - Derive state thay v√¨ duplicate
7. **Batching** - React t·ª± ƒë·ªông batch multiple setState calls

---

## üîç Debug Tips

### **1. State kh√¥ng update:**

```jsx
// Check: C√≥ mutate tr·ª±c ti·∫øp kh√¥ng?
user.name = 'New'; // ‚ùå
setUser(user); // Kh√¥ng trigger re-render

// Fix:
setUser({ ...user, name: 'New' }); // ‚úÖ
```

### **2. Stale closure:**

```jsx
// Problem:
useEffect(() => {
    setInterval(() => {
        setCount(count + 1); // count lu√¥n l√† gi√° tr·ªã ban ƒë·∫ßu
    }, 1000);
}, []); // Empty deps

// Fix:
useEffect(() => {
    setInterval(() => {
        setCount((prev) => prev + 1); // ‚úÖ Functional update
    }, 1000);
}, []);
```

### **3. useState kh√¥ng ch·∫°y lazy init:**

```jsx
// Wrong:
useState(expensiveFunction()); // Ch·∫°y m·ªói render

// Right:
useState(() => expensiveFunction()); // Ch·ªâ ch·∫°y l·∫ßn ƒë·∫ßu
```

---

## üí° Pro Tips

1. **DevTools**: D√πng React DevTools ƒë·ªÉ inspect state changes
2. **Immer**: Th∆∞ vi·ªán gi√∫p vi·∫øt immutable updates d·ªÖ h∆°n
3. **TypeScript**: Type safety cho state r·∫•t h·ªØu √≠ch
4. **Console.log**: Log state ƒë·ªÉ debug, nh∆∞ng nh·ªõ x√≥a sau khi xong
5. **Small Components**: T√°ch component nh·ªè = state d·ªÖ qu·∫£n l√Ω h∆°n

---

## üéÆ Quick Quiz

Tr∆∞·ªõc khi qua ng√†y 7, test ki·∫øn th·ª©c:

1. T·∫°i sao ph·∫£i d√πng spread operator khi update object/array state?
2. Khi n√†o d√πng functional update `setState(prev => ...)`?
3. Khi n√†o c·∫ßn lazy initialization?
4. Array methods n√†o an to√†n cho setState? (map, filter, slice...)
5. L√†m sao update nested object trong state?

**ƒê√°p √°n:**

1. React so s√°nh b·∫±ng reference. C√πng reference = kh√¥ng re-render.
2. Khi state m·ªõi ph·ª• thu·ªôc state c≈©, ho·∫∑c trong useEffect/timer.
3. Khi initial state t·ªën t√†i nguy√™n: localStorage, parsing, computation.
4. Non-mutating methods: map, filter, slice, concat, spread
5. D√πng nested spread: `{ ...obj, nested: { ...obj.nested, key: value } }`

---

**üöÄ Ng√†y mai (Ng√†y 7):** useReducer - Complex State Logic! Khi useState kh√¥ng ƒë·ªß m·∫°nh! üí™
