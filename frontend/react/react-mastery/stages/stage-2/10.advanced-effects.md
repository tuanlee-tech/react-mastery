# üìÖ NG√ÄY 10: Advanced Effects & Best Practices

## üéØ M·ª•c ti√™u h√¥m nay

- useLayoutEffect deep dive
- useInsertionEffect (React 18+)
- Effect best practices v√† anti-patterns
- Custom hooks v·ªõi effects
- Optimization techniques
- When NOT to use effects
- Testing effects

---

## üìö PH·∫¶N 1: L√ù THUY·∫æT (30-45 ph√∫t)

### **1.1. useLayoutEffect Deep Dive**

#### **Execution Timeline**

```jsx
// Timeline comparison:

// useEffect (Async):
// 1. React updates DOM
// 2. Browser paints screen
// 3. useEffect runs
// ‚Üí User c√≥ th·ªÉ th·∫•y intermediate state (flicker)

// useLayoutEffect (Sync):
// 1. React updates DOM
// 2. useLayoutEffect runs (blocking)
// 3. Browser paints screen
// ‚Üí User kh√¥ng th·∫•y intermediate state
```

#### **Visual Comparison**

```jsx
// ‚ùå useEffect - C√≥ th·ªÉ th·∫•y flicker
function Tooltip() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const ref = useRef(null);

  useEffect(() => {
    // 1. Component render v·ªõi position { x: 0, y: 0 }
    // 2. Browser paint tooltip ·ªü (0, 0)
    // 3. Measure v√† update position
    // 4. Browser re-paint ·ªü position m·ªõi
    // ‚Üí User th·∫•y tooltip nh·∫£y!

    const rect = ref.current.getBoundingClientRect();
    setPosition({
      x: rect.left + rect.width / 2,
      y: rect.top - 10,
    });
  }, []);

  return (
    <div
      ref={ref}
      style={{ position: "absolute", left: position.x, top: position.y }}
    >
      Tooltip
    </div>
  );
}

// ‚úÖ useLayoutEffect - Smooth
function Tooltip() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const ref = useRef(null);

  useLayoutEffect(() => {
    // 1. Component render v·ªõi position { x: 0, y: 0 }
    // 2. Measure v√† update position (before paint)
    // 3. Browser paint m·ªôt l·∫ßn v·ªõi position ƒë√∫ng
    // ‚Üí User kh√¥ng th·∫•y nh·∫£y!

    const rect = ref.current.getBoundingClientRect();
    setPosition({
      x: rect.left + rect.width / 2,
      y: rect.top - 10,
    });
  }, []);

  return (
    <div
      ref={ref}
      style={{ position: "absolute", left: position.x, top: position.y }}
    >
      Tooltip
    </div>
  );
}
```

#### **Use Cases cho useLayoutEffect**

**1. DOM Measurements**

```jsx
function AutoResizeTextarea() {
  const textareaRef = useRef(null);

  useLayoutEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      // Reset height ƒë·ªÉ measure scrollHeight ch√≠nh x√°c
      textarea.style.height = "0px";
      const scrollHeight = textarea.scrollHeight;
      textarea.style.height = scrollHeight + "px";
    }
  }); // Ch·∫°y m·ªói render ƒë·ªÉ auto-resize

  return <textarea ref={textareaRef} />;
}
```

**2. Scroll Position**

```jsx
function ChatMessages({ messages }) {
  const messagesEndRef = useRef(null);

  useLayoutEffect(() => {
    // Scroll tr∆∞·ªõc khi paint ƒë·ªÉ kh√¥ng th·∫•y jump
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  return (
    <div className="messages">
      {messages.map((msg) => (
        <div key={msg.id}>{msg.text}</div>
      ))}
      <div ref={messagesEndRef} />
    </div>
  );
}
```

**3. Animation Setup**

```jsx
function AnimatedComponent({ isVisible }) {
  const elementRef = useRef(null);

  useLayoutEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    if (isVisible) {
      // Set initial state tr∆∞·ªõc khi animate
      element.style.opacity = "0";
      element.style.transform = "translateY(-20px)";

      // Trigger animation
      requestAnimationFrame(() => {
        element.style.transition = "all 0.3s";
        element.style.opacity = "1";
        element.style.transform = "translateY(0)";
      });
    }
  }, [isVisible]);

  return <div ref={elementRef}>Content</div>;
}
```

**4. Focus Management**

```jsx
function Modal({ isOpen }) {
  const firstFocusableRef = useRef(null);
  const lastFocusableRef = useRef(null);
  const previousActiveElement = useRef(null);

  useLayoutEffect(() => {
    if (isOpen) {
      // L∆∞u element ƒëang focus
      previousActiveElement.current = document.activeElement;

      // Focus v√†o element ƒë·∫ßu ti√™n
      firstFocusableRef.current?.focus();
    } else {
      // Restore focus khi ƒë√≥ng
      previousActiveElement.current?.focus();
    }
  }, [isOpen]);

  // Trap focus trong modal
  const handleKeyDown = (e) => {
    if (e.key === "Tab") {
      if (e.shiftKey) {
        // Shift+Tab: quay v·ªÅ cu·ªëi n·∫øu ƒëang ·ªü ƒë·∫ßu
        if (document.activeElement === firstFocusableRef.current) {
          e.preventDefault();
          lastFocusableRef.current?.focus();
        }
      } else {
        // Tab: quay v·ªÅ ƒë·∫ßu n·∫øu ƒëang ·ªü cu·ªëi
        if (document.activeElement === lastFocusableRef.current) {
          e.preventDefault();
          firstFocusableRef.current?.focus();
        }
      }
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal" onKeyDown={handleKeyDown}>
      <button ref={firstFocusableRef}>First</button>
      {/* Modal content */}
      <button ref={lastFocusableRef}>Last</button>
    </div>
  );
}
```

#### **‚ö†Ô∏è Performance Considerations**

```jsx
// ‚ùå BAD - Blocking operation
function ExpensiveComponent() {
  useLayoutEffect(() => {
    // Heavy computation (blocks paint)
    for (let i = 0; i < 1000000; i++) {
      // expensive work
    }
  }, []);
  // ‚Üí UI b·ªã freeze!
}

// ‚úÖ GOOD - Light operations only
function GoodComponent() {
  useLayoutEffect(() => {
    const rect = element.getBoundingClientRect(); // Fast
    setPosition(rect);
  }, []);
}

// ‚úÖ Move heavy work to useEffect
function BetterComponent() {
  useLayoutEffect(() => {
    const rect = element.getBoundingClientRect();
    setPosition(rect);
  }, []);

  useEffect(() => {
    // Heavy work doesn't block paint
    processData();
  }, []);
}
```

---

### **1.2. useInsertionEffect (React 18+)**

useInsertionEffect l√† hook ƒë·∫∑c bi·ªát cho CSS-in-JS libraries.

#### **Execution Order**

```jsx
// Execution order:
// 1. useInsertionEffect
// 2. useLayoutEffect
// 3. Browser paint
// 4. useEffect

function Component() {
  useInsertionEffect(() => {
    console.log("1. useInsertionEffect");
  });

  useLayoutEffect(() => {
    console.log("2. useLayoutEffect");
  });

  useEffect(() => {
    console.log("3. useEffect");
  });

  return <div>Component</div>;
}
```

#### **Use Case: CSS-in-JS**

```jsx
// Simplified example of CSS-in-JS library usage

let isInserted = new Map();

function useCSS(rule) {
  useInsertionEffect(() => {
    // Inject CSS tr∆∞·ªõc khi DOM ƒë∆∞·ª£c painted
    if (!isInserted.has(rule)) {
      isInserted.set(rule, true);
      const style = document.createElement("style");
      style.textContent = rule;
      document.head.appendChild(style);
    }
  });
}

function StyledButton() {
  useCSS(`
    .styled-button {
      background: blue;
      color: white;
      padding: 10px 20px;
    }
  `);

  return <button className="styled-button">Click me</button>;
}

// ‚ö†Ô∏è KH√îNG d√πng cho app logic th√¥ng th∆∞·ªùng!
// Ch·ªâ d√πng trong CSS-in-JS libraries
```

#### **Khi n√†o KH√îNG d√πng useInsertionEffect**

```jsx
// ‚ùå WRONG - Regular side effects
function Component() {
  useInsertionEffect(() => {
    fetch("/api/data"); // ‚ùå Use useEffect instead
  }, []);
}

// ‚ùå WRONG - State updates
function Component() {
  const [data, setData] = useState(null);

  useInsertionEffect(() => {
    setData(newData); // ‚ùå Use useEffect instead
  }, []);
}

// ‚ùå WRONG - Event listeners
function Component() {
  useInsertionEffect(() => {
    window.addEventListener("resize", handleResize); // ‚ùå Use useEffect
  }, []);
}

// ‚úÖ ONLY for CSS injection
function useTheme(theme) {
  useInsertionEffect(() => {
    const style = document.createElement("style");
    style.textContent = generateThemeCSS(theme);
    document.head.appendChild(style);

    return () => style.remove();
  }, [theme]);
}
```

**Summary:**

- 99.9% th·ªùi gian: d√πng **useEffect**
- C·∫ßn DOM measurement/sync updates: d√πng **useLayoutEffect**
- Building CSS-in-JS library: d√πng **useInsertionEffect**

---

### **1.3. You Might Not Need an Effect**

Nhi·ªÅu tr∆∞·ªùng h·ª£p KH√îNG c·∫ßn useEffect!

#### **‚ùå Anti-pattern 1: Updating state based on props/state**

```jsx
// ‚ùå BAD - Redundant effect
function Component({ firstName, lastName }) {
  const [fullName, setFullName] = useState("");

  useEffect(() => {
    setFullName(`${firstName} ${lastName}`);
  }, [firstName, lastName]);

  return <div>{fullName}</div>;
}

// ‚úÖ GOOD - Derived state
function Component({ firstName, lastName }) {
  const fullName = `${firstName} ${lastName}`;
  return <div>{fullName}</div>;
}

// ‚úÖ GOOD - With memoization n·∫øu expensive
function Component({ firstName, lastName }) {
  const fullName = useMemo(
    () => computeExpensiveFullName(firstName, lastName),
    [firstName, lastName]
  );
  return <div>{fullName}</div>;
}
```

#### **‚ùå Anti-pattern 2: Resetting state khi props thay ƒë·ªïi**

```jsx
// ‚ùå BAD - Effect ƒë·ªÉ reset state
function UserProfile({ userId }) {
  const [profile, setProfile] = useState(null);

  useEffect(() => {
    setProfile(null); // Reset when userId changes
  }, [userId]);

  useEffect(() => {
    fetchProfile(userId).then(setProfile);
  }, [userId]);

  return <div>{profile?.name}</div>;
}

// ‚úÖ GOOD - Use key prop
function App() {
  const [userId, setUserId] = useState(1);

  return (
    <UserProfile
      key={userId} // Re-mount component when userId changes
      userId={userId}
    />
  );
}

function UserProfile({ userId }) {
  const [profile, setProfile] = useState(null);

  useEffect(() => {
    fetchProfile(userId).then(setProfile);
  }, [userId]);

  return <div>{profile?.name}</div>;
}
```

#### **‚ùå Anti-pattern 3: Adjusting state trong effect**

```jsx
// ‚ùå BAD - Double render
function List({ items }) {
  const [selection, setSelection] = useState([]);

  useEffect(() => {
    // Remove invalid selections
    setSelection((sel) =>
      sel.filter((id) => items.some((item) => item.id === id))
    );
  }, [items]);
}

// ‚úÖ GOOD - Adjust during render
function List({ items }) {
  const [selection, setSelection] = useState([]);

  // Adjust selection immediately
  const validSelection = selection.filter((id) =>
    items.some((item) => item.id === id)
  );

  return <div>{/* use validSelection */}</div>;
}
```

#### **‚ùå Anti-pattern 4: Notify parent v·ªÅ state change**

```jsx
// ‚ùå BAD
function Child({ onChange }) {
  const [value, setValue] = useState("");

  useEffect(() => {
    onChange(value); // Notify parent
  }, [value, onChange]);

  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}

// ‚úÖ GOOD - Notify trong event handler
function Child({ onChange }) {
  const [value, setValue] = useState("");

  const handleChange = (e) => {
    const newValue = e.target.value;
    setValue(newValue);
    onChange(newValue); // Notify immediately
  };

  return <input value={value} onChange={handleChange} />;
}

// ‚úÖ BETTER - Controlled component
function Parent() {
  const [value, setValue] = useState("");
  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}
```

#### **‚ùå Anti-pattern 5: Sending POST request on mount**

```jsx
// ‚ùå BAD - Effect fires twice in Strict Mode
function Component() {
  useEffect(() => {
    fetch("/api/log", { method: "POST" }); // Sent twice!
  }, []);
}

// ‚úÖ GOOD - Send in event handler
function Component() {
  const handleClick = () => {
    fetch("/api/log", { method: "POST" });
  };

  return <button onClick={handleClick}>Log</button>;
}

// ‚úÖ GOOD - If must send on mount, add flag
function Component() {
  const hasSentRef = useRef(false);

  useEffect(() => {
    if (!hasSentRef.current) {
      hasSentRef.current = true;
      fetch("/api/log", { method: "POST" });
    }
  }, []);
}
```

#### **‚úÖ When TO use effects:**

```jsx
// ‚úÖ Synchronizing with external systems
useEffect(() => {
  const connection = chatRoom.connect();
  return () => connection.disconnect();
}, [chatRoom]);

// ‚úÖ Fetching data
useEffect(() => {
  fetchData(id).then(setData);
}, [id]);

// ‚úÖ Setting up subscriptions
useEffect(() => {
  const sub = observable.subscribe(handleData);
  return () => sub.unsubscribe();
}, []);

// ‚úÖ Analytics/logging
useEffect(() => {
  analytics.track("page_view", { page: location.pathname });
}, [location.pathname]);
```

---

### **1.4. Custom Hooks v·ªõi Effects**

Extract effect logic v√†o custom hooks cho reusability.

#### **Pattern 1: Data Fetching Hook**

```jsx
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let ignore = false;

    setLoading(true);
    setError(null);

    fetch(url)
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch");
        return res.json();
      })
      .then((data) => {
        if (!ignore) {
          setData(data);
          setLoading(false);
        }
      })
      .catch((err) => {
        if (!ignore) {
          setError(err.message);
          setLoading(false);
        }
      });

    return () => {
      ignore = true;
    };
  }, [url]);

  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useFetch(`/api/users/${userId}`);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  return <div>{user.name}</div>;
}
```

#### **Pattern 2: Window Event Listener Hook**

```jsx
function useWindowEvent(event, handler) {
  useEffect(() => {
    window.addEventListener(event, handler);
    return () => window.removeEventListener(event, handler);
  }, [event, handler]);
}

// Usage
function Component() {
  const [size, setSize] = useState({ width: 0, height: 0 });

  useWindowEvent("resize", () => {
    setSize({
      width: window.innerWidth,
      height: window.innerHeight,
    });
  });

  return <div>Width: {size.width}</div>;
}
```

#### **Pattern 3: Interval Hook**

```jsx
function useInterval(callback, delay) {
  const savedCallback = useRef(callback);

  // Update ref n·∫øu callback thay ƒë·ªïi
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // Setup interval
  useEffect(() => {
    if (delay === null) return;

    const tick = () => {
      savedCallback.current();
    };

    const id = setInterval(tick, delay);
    return () => clearInterval(id);
  }, [delay]);
}

// Usage
function Timer() {
  const [count, setCount] = useState(0);
  const [delay, setDelay] = useState(1000);

  useInterval(() => {
    setCount((c) => c + 1);
  }, delay);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setDelay(500)}>Faster</button>
      <button onClick={() => setDelay(1000)}>Normal</button>
      <button onClick={() => setDelay(null)}>Stop</button>
    </div>
  );
}
```

#### **Pattern 4: LocalStorage Sync Hook**

```jsx
function useLocalStorage(key, initialValue) {
  // Lazy initialization t·ª´ localStorage
  const [value, setValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // Sync v·ªõi localStorage khi value thay ƒë·ªïi
  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  }, [key, value]);

  return [value, setValue];
}

// Usage
function TodoApp() {
  const [todos, setTodos] = useLocalStorage("todos", []);
  // todos t·ª± ƒë·ªông sync v·ªõi localStorage!
}
```

#### **Pattern 5: Debounce Hook**

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Usage
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // Fetch search results
      fetchResults(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
  );
}
```

#### **Pattern 6: Previous Value Hook**

```jsx
function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

// Usage
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

#### **Pattern 7: Online Status Hook**

```jsx
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, []);

  return isOnline;
}

// Usage
function App() {
  const isOnline = useOnlineStatus();

  return (
    <div>
      {isOnline ? (
        <span className="status-online">üü¢ Online</span>
      ) : (
        <span className="status-offline">üî¥ Offline</span>
      )}
    </div>
  );
}
```

---

### **1.5. Effect Optimization Techniques**

#### **1. Memoize Dependencies**

```jsx
// ‚ùå BAD - Object recreated m·ªói render
function Component() {
  const options = { method: "GET", headers: {} };

  useEffect(() => {
    fetch("/api/data", options); // options thay ƒë·ªïi m·ªói render!
  }, [options]);
}

// ‚úÖ GOOD - Memoize object
function Component() {
  const options = useMemo(() => ({ method: "GET", headers: {} }), []);

  useEffect(() => {
    fetch("/api/data", options);
  }, [options]);
}

// ‚úÖ BETTER - Move inside effect
function Component() {
  useEffect(() => {
    const options = { method: "GET", headers: {} };
    fetch("/api/data", options);
  }, []); // No dependencies!
}
```

#### **2. Split Effects**

```jsx
// ‚ùå BAD - Combined effects
function Component({ userId, theme }) {
  useEffect(() => {
    // Fetch user
    fetchUser(userId).then(setUser);

    // Apply theme
    document.body.className = theme;
  }, [userId, theme]); // Re-fetch user khi theme thay ƒë·ªïi!
}

// ‚úÖ GOOD - Separate effects
function Component({ userId, theme }) {
  // Effect 1: Fetch user
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);

  // Effect 2: Apply theme
  useEffect(() => {
    document.body.className = theme;
  }, [theme]);
}
```

#### **3. Conditional Effects**

```jsx
// ‚ùå BAD - Effect ch·∫°y kh√¥ng c·∫ßn thi·∫øt
function Component({ shouldFetch, userId }) {
  useEffect(() => {
    if (shouldFetch) {
      fetchUser(userId);
    }
  }, [shouldFetch, userId]); // Re-run khi userId thay ƒë·ªïi ngay c·∫£ khi !shouldFetch
}

// ‚úÖ GOOD - Early return
function Component({ shouldFetch, userId }) {
  useEffect(() => {
    if (!shouldFetch) return;

    fetchUser(userId);
  }, [shouldFetch, userId]);
}

// ‚úÖ BETTER - Separate effect
function Component({ shouldFetch, userId }) {
  useEffect(() => {
    if (shouldFetch) {
      fetchUser(userId);
    }
  }, [shouldFetch && userId]); // Only re-run when both true AND userId changes
}
```

#### **4. Refs ƒë·ªÉ Skip Effects**

```jsx
// Skip first render
function Component({ value }) {
  const isFirstRender = useRef(true);

  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }

    // Only run on subsequent renders
    console.log("Value changed:", value);
  }, [value]);
}

// Run only once despite deps
function Component({ config }) {
  const hasRun = useRef(false);

  useEffect(() => {
    if (hasRun.current) return;
    hasRun.current = true;

    initializeApp(config);
  }, [config]); // ESLint happy, but only runs once
}
```

---

### **1.6. Testing Effects**

#### **Testing with React Testing Library**

```jsx
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

// Component to test
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    setLoading(true);
    fetch(`/api/users/${userId}`)
      .then((res) => res.json())
      .then((data) => {
        setUser(data);
        setLoading(false);
      });
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>{user.name}</div>;
}

// Tests
describe("UserProfile", () => {
  test("fetches and displays user", async () => {
    // Mock fetch
    global.fetch = jest.fn(() =>
      Promise.resolve({
        json: () => Promise.resolve({ name: "John Doe" }),
      })
    );

    render(<UserProfile userId={1} />);

    // Initially loading
    expect(screen.getByText("Loading...")).toBeInTheDocument();

    // Wait for user to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
    });

    expect(fetch).toHaveBeenCalledWith("/api/users/1");
  });

  test("refetches when userId changes", async () => {
    global.fetch = jest.fn(() =>
      Promise.resolve({
        json: () => Promise.resolve({ name: "John Doe" }),
      })
    );

    const { rerender } = render(<UserProfile userId={1} />);

    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
    });

    // Change userId
    global.fetch.mockImplementationOnce(() =>
      Promise.resolve({
        json: () => Promise.resolve({ name: "Jane Smith" }),
      })
    );

    rerender(<UserProfile userId={2} />);

    await waitFor(() => {
      expect(screen.getByText("Jane Smith")).toBeInTheDocument();
    });

    expect(fetch).toHaveBeenCalledTimes(2);
    expect(fetch).toHaveBeenLastCalledWith("/api/users/2");
  });
});
```

#### **Testing Cleanup**

```jsx
test("cleans up on unmount", () => {
  const mockCleanup = jest.fn();

  function Component() {
    useEffect(() => {
      return mockCleanup;
    }, []);
    return <div>Component</div>;
  }

  const { unmount } = render(<Component />);

  expect(mockCleanup).not.toHaveBeenCalled();

  unmount();

  expect(mockCleanup).toHaveBeenCalledTimes(1);
});
```

#### **Testing Custom Hooks**

```jsx
import { renderHook, waitFor } from "@testing-library/react";

// Custom hook
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    setLoading(true);
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      });
  }, [url]);

  return { data, loading };
}

// Test
test("useFetch fetches data", async () => {
  global.fetch = jest.fn(() =>
    Promise.resolve({
      json: () => Promise.resolve({ result: "success" }),
    })
  );

  const { result } = renderHook(() => useFetch("/api/data"));

  expect(result.current.loading).toBe(true);
  expect(result.current.data).toBe(null);

  await waitFor(() => {
    expect(result.current.loading).toBe(false);
  });

  expect(result.current.data).toEqual({ result: "success" });
});

test("useFetch refetches on URL change", async () => {
  global.fetch = jest.fn(() =>
    Promise.resolve({
      json: () => Promise.resolve({ result: "success" }),
    })
  );

  const { result, rerender } = renderHook(({ url }) => useFetch(url), {
    initialProps: { url: "/api/data/1" },
  });

  await waitFor(() => {
    expect(result.current.loading).toBe(false);
  });

  // Change URL
  rerender({ url: "/api/data/2" });

  expect(result.current.loading).toBe(true);

  await waitFor(() => {
    expect(result.current.loading).toBe(false);
  });

  expect(fetch).toHaveBeenCalledTimes(2);
});
```

---

## üíª PH·∫¶N 2: CODE DEMO (30-45 ph√∫t)

### **Demo 1: Dropdown v·ªõi useLayoutEffect**

```jsx
function Dropdown({ trigger, children }) {
  const [isOpen, setIsOpen] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const triggerRef = useRef(null);
  const dropdownRef = useRef(null);

  // Position dropdown tr∆∞·ªõc khi paint
  useLayoutEffect(() => {
    if (!isOpen || !triggerRef.current || !dropdownRef.current) return;

    const triggerRect = triggerRef.current.getBoundingClientRect();
    const dropdownRect = dropdownRef.current.getBoundingClientRect();

    let top = triggerRect.bottom + 5;
    let left = triggerRect.left;

    // Adjust n·∫øu v∆∞·ª£t ra ngo√†i viewport
    if (left + dropdownRect.width > window.innerWidth) {
      left = window.innerWidth - dropdownRect.width - 10;
    }

    if (top + dropdownRect.height > window.innerHeight) {
      top = triggerRect.top - dropdownRect.height - 5;
    }

    setPosition({ top, left });
  }, [isOpen]);

  // Close on outside click
  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (e) => {
      if (
        triggerRef.current &&
        !triggerRef.current.contains(e.target) &&
        dropdownRef.current &&
        !dropdownRef.current.contains(e.target)
      ) {
        setIsOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [isOpen]);

  // Close on Escape
  useEffect(() => {
    if (!isOpen) return;

    const handleEscape = (e) => {
      if (e.key === "Escape") {
        setIsOpen(false);
      }
    };

    document.addEventListener("keydown", handleEscape);
    return () => document.removeEventListener("keydown", handleEscape);
  }, [isOpen]);

  return (
    <div className="dropdown">
      <div ref={triggerRef} onClick={() => setIsOpen(!isOpen)}>
        {trigger}
      </div>

      {isOpen && (
        <div
          ref={dropdownRef}
          className="dropdown-menu"
          style={{
            position: "fixed",
            top: `${position.top}px`,
            left: `${position.left}px`,
            zIndex: 1000,
          }}
        >
          {children}
        </div>
      )}
    </div>
  );
}

// Usage
function App() {
  return (
    <div style={{ padding: "100px" }}>
      <Dropdown trigger={<button>M·ªü Menu</button>}>
        <div
          style={{
            background: "white",
            border: "1px solid #ccc",
            borderRadius: "4px",
          }}
        >
          <div className="dropdown-item" onClick={() => console.log("Profile")}>
            üë§ Profile
          </div>
          <div
            className="dropdown-item"
            onClick={() => console.log("Settings")}
          >
            ‚öôÔ∏è Settings
          </div>
          <div className="dropdown-item" onClick={() => console.log("Logout")}>
            üö™ Logout
          </div>
        </div>
      </Dropdown>
    </div>
  );
}
```

### **Demo 2: Custom Hooks Library**

```jsx
// useWindowSize.js
function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return size;
}

// useMediaQuery.js
function useMediaQuery(query) {
  const [matches, setMatches] = useState(() => {
    return window.matchMedia(query).matches;
  });

  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    const handleChange = (e) => setMatches(e.matches);

    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, [query]);

  return matches;
}

// useOnScreen.js - Intersection Observer
function useOnScreen(ref, options = {}) {
  const [isOnScreen, setIsOnScreen] = useState(false);

  useEffect(() => {
    const observer = new IntersectionObserver(([entry]) => {
      setIsOnScreen(entry.isIntersecting);
    }, options);

    const element = ref.current;
    if (element) {
      observer.observe(element);
    }

    return () => {
      if (element) {
        observer.unobserve(element);
      }
    };
  }, [ref, options]);

  return isOnScreen;
}

// useClickOutside.js
function useClickOutside(ref, handler) {
  useEffect(() => {
    const listener = (event) => {
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }
      handler(event);
    };

    document.addEventListener("mousedown", listener);
    document.addEventListener("touchstart", listener);

    return () => {
      document.removeEventListener("mousedown", listener);
      document.removeEventListener("touchstart", listener);
    };
  }, [ref, handler]);
}

// useKeyPress.js
function useKeyPress(targetKey) {
  const [keyPressed, setKeyPressed] = useState(false);

  useEffect(() => {
    const downHandler = ({ key }) => {
      if (key === targetKey) {
        setKeyPressed(true);
      }
    };

    const upHandler = ({ key }) => {
      if (key === targetKey) {
        setKeyPressed(false);
      }
    };

    window.addEventListener("keydown", downHandler);
    window.addEventListener("keyup", upHandler);

    return () => {
      window.removeEventListener("keydown", downHandler);
      window.removeEventListener("keyup", upHandler);
    };
  }, [targetKey]);

  return keyPressed;
}

// Demo Component s·ª≠ d·ª•ng c√°c hooks
function DemoApp() {
  const size = useWindowSize();
  const isMobile = useMediaQuery("(max-width: 768px)");
  const escapePressed = useKeyPress("Escape");

  const elementRef = useRef(null);
  const isVisible = useOnScreen(elementRef);

  const [showModal, setShowModal] = useState(false);
  const modalRef = useRef(null);
  useClickOutside(modalRef, () => setShowModal(false));

  useEffect(() => {
    if (escapePressed) {
      setShowModal(false);
    }
  }, [escapePressed]);

  return (
    <div className="demo-app">
      <h1>Custom Hooks Demo</h1>

      <div className="info">
        <p>
          Window Size: {size.width} x {size.height}
        </p>
        <p>Device: {isMobile ? "Mobile üì±" : "Desktop üíª"}</p>
        <p>ESC Pressed: {escapePressed ? "Yes" : "No"}</p>
      </div>

      <div style={{ height: "100vh" }}>
        <p>Scroll down...</p>
      </div>

      <div ref={elementRef} className="observed-element">
        {isVisible ? "üëÄ I am visible!" : "üò¥ Scroll to see me"}
      </div>

      <button onClick={() => setShowModal(true)}>Open Modal</button>

      {showModal && (
        <>
          <div className="modal-backdrop" />
          <div ref={modalRef} className="modal">
            <h2>Modal</h2>
            <p>Click outside or press ESC to close</p>
            <button onClick={() => setShowModal(false)}>Close</button>
          </div>
        </>
      )}
    </div>
  );
}
```

---

## üî® PH·∫¶N 3: TH·ª∞C H√ÄNH (60-90 ph√∫t)

### **Exercise 1: Tooltip Component v·ªõi useLayoutEffect**

```jsx
// TODO: Implement tooltip v·ªõi smart positioning

function Tooltip({ children, content, placement = "top" }) {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const triggerRef = useRef(null);
  const tooltipRef = useRef(null);

  // TODO: useLayoutEffect ƒë·ªÉ position tooltip
  // - Measure trigger v√† tooltip dimensions
  // - Calculate position based on placement
  // - Adjust n·∫øu overflow viewport
  // - Support placements: top, bottom, left, right

  // TODO: Show/hide on hover
  // - Add mouseenter/mouseleave listeners
  // - Delay show (300ms)
  // - Instant hide

  // TODO: Features
  // - Arrow pointing to trigger
  // - Fade in/out animation
  // - Auto-adjust placement if no space
  // - Support keyboard (focus/blur)

  return (
    <div className="tooltip-wrapper">
      <div
        ref={triggerRef}
        onMouseEnter={() => setIsVisible(true)}
        onMouseLeave={() => setIsVisible(false)}
      >
        {children}
      </div>

      {isVisible && (
        <div
          ref={tooltipRef}
          className="tooltip"
          style={{
            position: "fixed",
            top: position.top,
            left: position.left,
          }}
        >
          {content}
        </div>
      )}
    </div>
  );
}

// Usage
function App() {
  return (
    <div style={{ padding: "200px" }}>
      <Tooltip content="This is a tooltip" placement="top">
        <button>Hover me</button>
      </Tooltip>
    </div>
  );
}
```

### **Exercise 2: Virtual Scroll List**

```jsx
// TODO: Implement virtual scrolling cho large lists

function VirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // TODO: Calculate visible range
  // - D·ª±a v√†o scrollTop v√† containerHeight
  // - Add buffer (overscan) ƒë·ªÉ smooth scrolling
  // - Only render visible items

  // TODO: useLayoutEffect ƒë·ªÉ sync scroll
  // - Update scrollTop on scroll
  // - Throttle scroll handler

  // TODO: Features
  // - Support variable item heights
  // - Scroll to index
  // - Scroll to top/bottom
  // - Loading indicator
  // - Empty state

  const visibleStart = Math.floor(scrollTop / itemHeight);
  const visibleEnd = Math.ceil((scrollTop + containerHeight) / itemHeight);

  const visibleItems = items.slice(visibleStart, visibleEnd);
  const totalHeight = items.length * itemHeight;
  const offsetY = visibleStart * itemHeight;

  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: "auto",
        position: "relative",
      }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: totalHeight, position: "relative" }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, index) => (
            <div
              key={visibleStart + index}
              style={{ height: itemHeight }}
              className="list-item"
            >
              Item {visibleStart + index}: {item}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// Usage
function App() {
  const items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);

  return <VirtualList items={items} itemHeight={50} containerHeight={400} />;
}
```

### **Exercise 3: Custom Hooks cho Form Management**

```jsx
// TODO: useForm hook v·ªõi validation

function useForm(initialValues, validate) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // TODO: handleChange
  // - Update value
  // - Mark as touched
  // - Clear error for field

  // TODO: handleBlur
  // - Mark as touched
  // - Validate field

  // TODO: handleSubmit
  // - Validate all fields
  // - If valid, call onSubmit
  // - Handle async submission

  // TODO: Reset form

  // TODO: Set field value programmatically

  const handleChange = (name) => (e) => {
    const value =
      e.target.type === "checkbox" ? e.target.checked : e.target.value;
    setValues((prev) => ({ ...prev, [name]: value }));
    setErrors((prev) => ({ ...prev, [name]: null }));
  };

  const handleBlur = (name) => () => {
    setTouched((prev) => ({ ...prev, [name]: true }));
    if (validate) {
      const fieldErrors = validate({ ...values });
      if (fieldErrors[name]) {
        setErrors((prev) => ({ ...prev, [name]: fieldErrors[name] }));
      }
    }
  };

  const handleSubmit = (onSubmit) => async (e) => {
    e.preventDefault();

    // Validate all
    if (validate) {
      const validationErrors = validate(values);
      setErrors(validationErrors);

      if (Object.keys(validationErrors).length > 0) {
        return;
      }
    }

    setIsSubmitting(true);
    try {
      await onSubmit(values);
    } finally {
      setIsSubmitting(false);
    }
  };

  const reset = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
  };
}

// TODO: useField hook cho individual fields
function useField(name, formContext) {
  // TODO: Return field props v√† meta
  // - value, onChange, onBlur
  // - error, touched
}

// Usage
function RegistrationForm() {
  const validate = (values) => {
    const errors = {};

    if (!values.email) {
      errors.email = "Email l√† b·∫Øt bu·ªôc";
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = "Email kh√¥ng h·ª£p l·ªá";
    }

    if (!values.password) {
      errors.password = "M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc";
    } else if (values.password.length < 6) {
      errors.password = "M·∫≠t kh·∫©u ph·∫£i ‚â• 6 k√Ω t·ª±";
    }

    if (values.password !== values.confirmPassword) {
      errors.confirmPassword = "M·∫≠t kh·∫©u kh√¥ng kh·ªõp";
    }

    return errors;
  };

  const form = useForm(
    { email: "", password: "", confirmPassword: "" },
    validate
  );

  const onSubmit = async (values) => {
    console.log("Submitting:", values);
    await new Promise((resolve) => setTimeout(resolve, 1000));
    alert("ƒêƒÉng k√Ω th√†nh c√¥ng!");
    form.reset();
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <div>
        <label>Email:</label>
        <input
          type="email"
          value={form.values.email}
          onChange={form.handleChange("email")}
          onBlur={form.handleBlur("email")}
        />
        {form.touched.email && form.errors.email && (
          <span className="error">{form.errors.email}</span>
        )}
      </div>

      <div>
        <label>M·∫≠t kh·∫©u:</label>
        <input
          type="password"
          value={form.values.password}
          onChange={form.handleChange("password")}
          onBlur={form.handleBlur("password")}
        />
        {form.touched.password && form.errors.password && (
          <span className="error">{form.errors.password}</span>
        )}
      </div>

      <div>
        <label>X√°c nh·∫≠n m·∫≠t kh·∫©u:</label>
        <input
          type="password"
          value={form.values.confirmPassword}
          onChange={form.handleChange("confirmPassword")}
          onBlur={form.handleBlur("confirmPassword")}
        />
        {form.touched.confirmPassword && form.errors.confirmPassword && (
          <span className="error">{form.errors.confirmPassword}</span>
        )}
      </div>

      <button type="submit" disabled={form.isSubmitting}>
        {form.isSubmitting ? "ƒêang x·ª≠ l√Ω..." : "ƒêƒÉng k√Ω"}
      </button>
    </form>
  );
}
```

### **Exercise 4: Drag and Drop v·ªõi useLayoutEffect**

```jsx
// TODO: Implement draggable items

function DraggableList({ items, onReorder }) {
  const [draggingIndex, setDraggingIndex] = useState(null);
  const [dragOverIndex, setDragOverIndex] = useState(null);

  // TODO: Drag handlers
  // - onDragStart: set draggingIndex
  // - onDragOver: calculate dragOverIndex, show preview
  // - onDrop: reorder items, call onReorder
  // - onDragEnd: cleanup

  // TODO: useLayoutEffect ƒë·ªÉ update positions smoothly
  // - Measure item positions
  // - Animate during drag

  // TODO: Features
  // - Visual feedback (ghost element)
  // - Smooth animations
  // - Touch support
  // - Horizontal/vertical modes
  // - Disabled items
  // - Handle constraints

  const handleDragStart = (index) => (e) => {
    setDraggingIndex(index);
    e.dataTransfer.effectAllowed = "move";
  };

  const handleDragOver = (index) => (e) => {
    e.preventDefault();
    if (index !== draggingIndex) {
      setDragOverIndex(index);
    }
  };

  const handleDrop = (index) => (e) => {
    e.preventDefault();

    if (draggingIndex === null || draggingIndex === index) return;

    const newItems = [...items];
    const [removed] = newItems.splice(draggingIndex, 1);
    newItems.splice(index, 0, removed);

    onReorder(newItems);
    setDraggingIndex(null);
    setDragOverIndex(null);
  };

  return (
    <div className="draggable-list">
      {items.map((item, index) => (
        <div
          key={item.id}
          draggable
          onDragStart={handleDragStart(index)}
          onDragOver={handleDragOver(index)}
          onDrop={handleDrop(index)}
          className={`draggable-item ${
            index === draggingIndex ? "dragging" : ""
          } ${index === dragOverIndex ? "drag-over" : ""}`}
        >
          <span className="drag-handle">‚ò∞</span>
          {item.text}
        </div>
      ))}
    </div>
  );
}

// Usage
function App() {
  const [items, setItems] = useState([
    { id: 1, text: "Item 1" },
    { id: 2, text: "Item 2" },
    { id: 3, text: "Item 3" },
    { id: 4, text: "Item 4" },
  ]);

  return (
    <div>
      <h1>Draggable List</h1>
      <DraggableList items={items} onReorder={setItems} />
    </div>
  );
}
```

### **Exercise 5: Advanced Animation System (Challenge)**

```jsx
// TODO: useAnimation hook v·ªõi timeline control

function useAnimation(duration = 1000, easing = "linear") {
  const [progress, setProgress] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const startTimeRef = useRef(null);
  const rafRef = useRef(null);

  // TODO: Easing functions
  const easingFunctions = {
    linear: (t) => t,
    easeIn: (t) => t * t,
    easeOut: (t) => t * (2 - t),
    easeInOut: (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),
  };

  // TODO: Animation loop v·ªõi useLayoutEffect
  useLayoutEffect(() => {
    if (!isPlaying) return;

    const animate = (timestamp) => {
      if (!startTimeRef.current) {
        startTimeRef.current = timestamp;
      }

      const elapsed = timestamp - startTimeRef.current;
      const rawProgress = Math.min(elapsed / duration, 1);
      const easedProgress = easingFunctions[easing](rawProgress);

      setProgress(easedProgress);

      if (rawProgress < 1) {
        rafRef.current = requestAnimationFrame(animate);
      } else {
        setIsPlaying(false);
        startTimeRef.current = null;
      }
    };

    rafRef.current = requestAnimationFrame(animate);

    return () => {
      if (rafRef.current) {
        cancelAnimationFrame(rafRef.current);
      }
    };
  }, [isPlaying, duration, easing]);

  const play = () => {
    setIsPlaying(true);
    setProgress(0);
    startTimeRef.current = null;
  };

  const pause = () => setIsPlaying(false);
  const reset = () => {
    setIsPlaying(false);
    setProgress(0);
    startTimeRef.current = null;
  };

  return { progress, isPlaying, play, pause, reset };
}

// TODO: useSpring hook cho physics-based animations
function useSpring(target, config = {}) {
  const { stiffness = 100, damping = 10, mass = 1 } = config;
  const [value, setValue] = useState(target);
  const velocity = useRef(0);

  useLayoutEffect(() => {
    let rafId;
    let lastTime = performance.now();

    const animate = (time) => {
      const deltaTime = (time - lastTime) / 1000;
      lastTime = time;

      const spring = stiffness * (target - value);
      const damper = damping * velocity.current;
      const acceleration = (spring - damper) / mass;

      velocity.current += acceleration * deltaTime;
      const newValue = value + velocity.current * deltaTime;

      setValue(newValue);

      // Continue if not settled
      if (
        Math.abs(target - newValue) > 0.01 ||
        Math.abs(velocity.current) > 0.01
      ) {
        rafId = requestAnimationFrame(animate);
      } else {
        setValue(target);
        velocity.current = 0;
      }
    };

    rafId = requestAnimationFrame(animate);

    return () => cancelAnimationFrame(rafId);
  }, [target, stiffness, damping, mass]);

  return value;
}

// Demo Component
function AnimationDemo() {
  const [targetX, setTargetX] = useState(0);
  const springX = useSpring(targetX, {
    stiffness: 100,
    damping: 15,
  });

  const fadeAnimation = useAnimation(2000, "easeInOut");
  const scaleAnimation = useAnimation(1000, "easeOut");

  return (
    <div className="animation-demo">
      <h1>Animation System</h1>

      {/* Spring Animation */}
      <div className="spring-demo">
        <h2>Spring Physics</h2>
        <button onClick={() => setTargetX(targetX === 0 ? 300 : 0)}>
          Toggle Position
        </button>
        <div
          className="animated-box"
          style={{
            transform: `translateX(${springX}px)`,
            width: 50,
            height: 50,
            background: "blue",
          }}
        />
      </div>

      {/* Timeline Animation */}
      <div className="timeline-demo">
        <h2>Timeline Animation</h2>
        <button onClick={fadeAnimation.play}>Play Fade</button>
        <button onClick={fadeAnimation.pause}>Pause</button>
        <button onClick={fadeAnimation.reset}>Reset</button>
        <div
          className="animated-box"
          style={{
            opacity: fadeAnimation.progress,
            width: 100,
            height: 100,
            background: "red",
          }}
        />
        <p>Progress: {(fadeAnimation.progress * 100).toFixed(0)}%</p>
      </div>

      {/* Scale Animation */}
      <div className="scale-demo">
        <h2>Scale Animation</h2>
        <button onClick={scaleAnimation.play}>Play Scale</button>
        <div
          className="animated-box"
          style={{
            transform: `scale(${scaleAnimation.progress})`,
            width: 100,
            height: 100,
            background: "green",
          }}
        />
      </div>
    </div>
  );
}
```

---

## ‚úÖ PH·∫¶N 4: REVIEW & CHECKLIST (15-30 ph√∫t)

### **useLayoutEffect:**

- [ ] Ch·∫°y sync tr∆∞·ªõc browser paint
- [ ] D√πng cho DOM measurements
- [ ] D√πng cho animations c·∫ßn sync
- [ ] Blocking - c·∫©n th·∫≠n performance
- [ ] 99% tr∆∞·ªùng h·ª£p d√πng useEffect

### **useInsertionEffect:**

- [ ] Ch·ªâ cho CSS-in-JS libraries
- [ ] Ch·∫°y tr∆∞·ªõc useLayoutEffect
- [ ] KH√îNG d√πng cho app logic

### **You Might Not Need an Effect:**

- [ ] Derived state: t√≠nh to√°n, kh√¥ng setState
- [ ] Reset state: d√πng key prop
- [ ] Adjust state: trong render
- [ ] Notify parent: trong event handler
- [ ] POST requests: trong event handler

### **Custom Hooks:**

- [ ] Extract effect logic
- [ ] Reusable across components
- [ ] Prefix v·ªõi "use"
- [ ] Follow hooks rules

### **Optimization:**

- [ ] Memoize dependencies
- [ ] Split unrelated effects
- [ ] Conditional execution
- [ ] Use refs ƒë·ªÉ skip effects

### **Testing:**

- [ ] Test v·ªõi React Testing Library
- [ ] Test cleanup functions
- [ ] Use renderHook cho custom hooks
- [ ] Mock external dependencies

### **Common Mistakes:**

```jsx
// ‚ùå useLayoutEffect cho data fetching
useLayoutEffect(() => {
  fetch("/api/data"); // Blocks paint!
}, []);

// ‚ùå useInsertionEffect cho app logic
useInsertionEffect(() => {
  setState(newValue); // Wrong hook!
}, []);

// ‚ùå Effect thay v√¨ derived state
useEffect(() => {
  setFullName(`${firstName} ${lastName}`);
}, [firstName, lastName]);

// ‚ùå Effect ƒë·ªÉ notify parent
useEffect(() => {
  onChange(value);
}, [value]);

// ‚úÖ ƒê√öNG
useEffect(() => {
  fetch("/api/data"); // Non-blocking
}, []);

const fullName = `${firstName} ${lastName}`; // Derived

const handleChange = (newValue) => {
  setValue(newValue);
  onChange(newValue); // Notify in handler
};
```

---

## üéØ HOMEWORK

### **1. Advanced Tooltip System**

- Smart positioning v·ªõi collision detection
- Multiple placements
- Delay show/hide
- Portal rendering
- Arrow positioning
- Touch support

### **2. Infinite Scroll v·ªõi Virtual Scrolling**

- Render ch·ªâ visible items
- Smooth scrolling
- Dynamic item heights
- Bi-directional scrolling
- Scroll restoration
- Loading states

### **3. Custom Hooks Library**

- useAsync (async operations)
- useThrottle
- useDebounce
- usePrevious
- useToggle
- useLocalStorage
- useSessionStorage
- useCopyToClipboard
- useIdle
- useTimeout

### **4. Animation Framework**

- Timeline control (play, pause, reverse)
- Easing functions
- Spring physics
- Stagger animations
- Sequence animations
- Gesture-based animations

### **5. Advanced Form System (Challenge)**

- Field-level validation
- Async validation
- Dependent fields
- Dynamic fields (add/remove)
- Multi-step with progress
- Auto-save drafts
- Undo/redo
- File uploads v·ªõi progress

---

## üìö ƒê·ªçc Th√™m

### **Official Docs:**

- [React - useLayoutEffect](https://react.dev/reference/react/useLayoutEffect)
- [React - useInsertionEffect](https://react.dev/reference/react/useInsertionEffect)
- [React - You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)
- [React - Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)

### **Advanced Reading:**

- [React Hook Form - Performance](https://react-hook-form.com/advanced-usage#Performance)
- [Framer Motion - Animation](https://www.framer.com/motion/)
- [React Spring - Physics Based](https://www.react-spring.dev/)

---

## üìù Key Takeaways

1. **useLayoutEffect** - Ch·ªâ khi th·∫•y flicker
2. **useInsertionEffect** - CSS-in-JS only
3. **Avoid Unnecessary Effects** - Think twice tr∆∞·ªõc khi d√πng
4. **Custom Hooks** - Extract v√† reuse logic
5. **Optimization** - Memoize deps, split effects
6. **Testing** - Test effects v√† cleanup
7. **Performance** - useLayoutEffect c√≥ cost

---

## üí° Pro Tips

1. **Default useEffect**: Ch·ªâ chuy·ªÉn sang useLayoutEffect khi c·∫ßn
2. **Derived State**: T√≠nh to√°n t·ªët h∆°n sync
3. **Custom Hooks**: Name clearly, document dependencies
4. **Testing**: Test behavior, not implementation
5. **Performance**: Profile first, optimize second

---

**üéâ HO√ÄN TH√ÄNH TU·∫¶N 2!**

**Achievements unlocked:**

- ‚úÖ useState mastery
- ‚úÖ useReducer patterns
- ‚úÖ State management strategies
- ‚úÖ useEffect & side effects
- ‚úÖ Advanced effects & optimization

**üìä Progress: 33% (10/30 ng√†y)**
