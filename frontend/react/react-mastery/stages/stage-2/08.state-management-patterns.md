# üìÖ NG√ÄY 8: State Management Patterns

## üéØ M·ª•c ti√™u h√¥m nay

- Lifting State Up - Chia s·∫ª state gi·ªØa components
- Derived State - T√≠nh to√°n t·ª´ state/props
- State Batching trong React 18
- State Colocation - ƒê·∫∑t state ƒë√∫ng ch·ªó
- State normalization patterns
- Optimizing re-renders

---

## üìö PH·∫¶N 1: L√ù THUY·∫æT (30-45 ph√∫t)

### **1.1. Lifting State Up**

Khi nhi·ªÅu components c·∫ßn share state, ƒë∆∞a state l√™n component cha chung g·∫ßn nh·∫•t.

#### **Problem: Sibling Components c·∫ßn share state**

```jsx
// ‚ùå Kh√¥ng th·ªÉ share state tr·ª±c ti·∫øp
function TemperatureInput() {
  const [temperature, setTemperature] = useState("");
  return (
    <input
      value={temperature}
      onChange={(e) => setTemperature(e.target.value)}
    />
  );
}

function BoilingVerdict() {
  // L√†m sao l·∫•y temperature t·ª´ TemperatureInput? ‚ùå
  return <p>Water would {temperature >= 100 ? "boil" : "not boil"}</p>;
}

function App() {
  return (
    <>
      <TemperatureInput />
      <BoilingVerdict />
    </>
  );
}
```

#### **Solution: Lift State Up**

```jsx
// ‚úÖ State ·ªü parent, pass xu·ªëng children
function TemperatureInput({ temperature, onTemperatureChange }) {
  return (
    <input
      value={temperature}
      onChange={(e) => onTemperatureChange(e.target.value)}
    />
  );
}

function BoilingVerdict({ celsius }) {
  return (
    <p>
      N∆∞·ªõc s·∫Ω {celsius >= 100 ? "s√¥i" : "kh√¥ng s√¥i"} ·ªü {celsius}¬∞C
    </p>
  );
}

function Calculator() {
  // ‚úÖ State lifted up to parent
  const [temperature, setTemperature] = useState("");

  return (
    <>
      <TemperatureInput
        temperature={temperature}
        onTemperatureChange={setTemperature}
      />
      <BoilingVerdict celsius={parseFloat(temperature)} />
    </>
  );
}
```

#### **Real Example: Synchronized Inputs**

```jsx
// Temperature converter: Celsius ‚Üî Fahrenheit
const scaleNames = {
  c: "Celsius",
  f: "Fahrenheit",
};

function toCelsius(fahrenheit) {
  return ((fahrenheit - 32) * 5) / 9;
}

function toFahrenheit(celsius) {
  return (celsius * 9) / 5 + 32;
}

function tryConvert(temperature, convert) {
  const input = parseFloat(temperature);
  if (Number.isNaN(input)) {
    return "";
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) / 1000;
  return rounded.toString();
}

function TemperatureInput({ scale, temperature, onTemperatureChange }) {
  return (
    <fieldset>
      <legend>Nh·∫≠p nhi·ªát ƒë·ªô ({scaleNames[scale]}):</legend>
      <input
        value={temperature}
        onChange={(e) => onTemperatureChange(e.target.value)}
      />
    </fieldset>
  );
}

function Calculator() {
  const [temperature, setTemperature] = useState("");
  const [scale, setScale] = useState("c");

  const handleCelsiusChange = (temp) => {
    setScale("c");
    setTemperature(temp);
  };

  const handleFahrenheitChange = (temp) => {
    setScale("f");
    setTemperature(temp);
  };

  const celsius =
    scale === "f" ? tryConvert(temperature, toCelsius) : temperature;
  const fahrenheit =
    scale === "c" ? tryConvert(temperature, toFahrenheit) : temperature;

  return (
    <div>
      <TemperatureInput
        scale="c"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="f"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
      <BoilingVerdict celsius={parseFloat(celsius)} />
    </div>
  );
}
```

**Quy t·∫Øc Lifting State Up:**

1. T√¨m component cha chung g·∫ßn nh·∫•t
2. Di chuy·ªÉn state l√™n cha
3. Pass state xu·ªëng qua props
4. Pass callbacks ƒë·ªÉ update state

---

### **1.2. Derived State (Computed State)**

State t√≠nh to√°n t·ª´ existing state/props. **KH√îNG l∆∞u v√†o state!**

#### **‚ùå Anti-pattern: Redundant State**

```jsx
// ‚ùå SAI - fullName l√† redundant
function UserProfile() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [fullName, setFullName] = useState(""); // ‚ùå Kh√¥ng c·∫ßn!

  // Ph·∫£i sync fullName m·ªói khi firstName/lastName thay ƒë·ªïi
  useEffect(() => {
    setFullName(`${firstName} ${lastName}`);
  }, [firstName, lastName]);

  return (
    <>
      <input value={firstName} onChange={(e) => setFirstName(e.target.value)} />
      <input value={lastName} onChange={(e) => setLastName(e.target.value)} />
      <p>Full Name: {fullName}</p>
    </>
  );
}
```

#### **‚úÖ Correct: Derived State**

```jsx
// ‚úÖ ƒê√öNG - T√≠nh to√°n tr·ª±c ti·∫øp
function UserProfile() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");

  // ‚úÖ Derived state - kh√¥ng c·∫ßn useState
  const fullName = `${firstName} ${lastName}`;

  return (
    <>
      <input value={firstName} onChange={(e) => setFirstName(e.target.value)} />
      <input value={lastName} onChange={(e) => setLastName(e.target.value)} />
      <p>Full Name: {fullName}</p>
    </>
  );
}
```

#### **Practical Examples**

```jsx
// Example 1: Todo statistics
function TodoList() {
  const [todos, setTodos] = useState([]);

  // ‚úÖ Derived state
  const totalCount = todos.length;
  const completedCount = todos.filter((t) => t.completed).length;
  const activeCount = totalCount - completedCount;
  const completionRate =
    totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;

  return (
    <div>
      <p>T·ªïng: {totalCount}</p>
      <p>Ho√†n th√†nh: {completedCount}</p>
      <p>C√≤n l·∫°i: {activeCount}</p>
      <p>T·ªâ l·ªá: {completionRate}%</p>
    </div>
  );
}

// Example 2: Shopping cart totals
function ShoppingCart() {
  const [items, setItems] = useState([]);

  // ‚úÖ Derived state
  const subtotal = items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );
  const tax = subtotal * 0.1; // 10% VAT
  const shipping = subtotal > 500000 ? 0 : 30000;
  const total = subtotal + tax + shipping;

  return (
    <div>
      <p>T·∫°m t√≠nh: {subtotal.toLocaleString("vi-VN")}ƒë</p>
      <p>Thu·∫ø: {tax.toLocaleString("vi-VN")}ƒë</p>
      <p>Ph√≠ ship: {shipping.toLocaleString("vi-VN")}ƒë</p>
      <p>T·ªïng: {total.toLocaleString("vi-VN")}ƒë</p>
    </div>
  );
}

// Example 3: Form validation
function RegistrationForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");

  // ‚úÖ Derived state - validation
  const isEmailValid = /\S+@\S+\.\S+/.test(email);
  const isPasswordValid = password.length >= 6;
  const doPasswordsMatch = password === confirmPassword;
  const isFormValid = isEmailValid && isPasswordValid && doPasswordsMatch;

  return (
    <form>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      {email && !isEmailValid && <span>Email kh√¥ng h·ª£p l·ªá</span>}

      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      {password && !isPasswordValid && <span>M·∫≠t kh·∫©u ph·∫£i ‚â• 6 k√Ω t·ª±</span>}

      <input
        type="password"
        value={confirmPassword}
        onChange={(e) => setConfirmPassword(e.target.value)}
      />
      {confirmPassword && !doPasswordsMatch && <span>M·∫≠t kh·∫©u kh√¥ng kh·ªõp</span>}

      <button type="submit" disabled={!isFormValid}>
        ƒêƒÉng k√Ω
      </button>
    </form>
  );
}
```

**Khi n√†o d√πng Derived State:**

- ‚úÖ T√≠nh to√°n t·ª´ existing state/props
- ‚úÖ Filtering, sorting, grouping data
- ‚úÖ Validation results
- ‚úÖ Totals, statistics, aggregations
- ‚úÖ Formatting, transformations

**Khi n√†o KH√îNG d√πng Derived State:**

- ‚ùå Data t·ª´ API (d√πng state)
- ‚ùå User input (d√πng state)
- ‚ùå Expensive calculations (d√πng useMemo)

---

### **1.3. State Batching (React 18)**

React 18 t·ª± ƒë·ªông batch multiple state updates ƒë·ªÉ optimize performance.

#### **React 17 v√† tr∆∞·ªõc**

```jsx
// React 17: Ch·ªâ batch trong event handlers
function Counter() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  function handleClick() {
    // ‚úÖ Batched - ch·ªâ re-render 1 l·∫ßn
    setCount((c) => c + 1);
    setFlag((f) => !f);
  }

  setTimeout(() => {
    // ‚ùå KH√îNG batch - re-render 2 l·∫ßn
    setCount((c) => c + 1);
    setFlag((f) => !f);
  }, 1000);

  console.log("Render"); // Log m·ªói re-render

  return <button onClick={handleClick}>Click</button>;
}
```

#### **React 18: Automatic Batching**

```jsx
// React 18: T·ª± ƒë·ªông batch EVERYWHERE
function Counter() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  function handleClick() {
    // ‚úÖ Batched
    setCount((c) => c + 1);
    setFlag((f) => !f);
  }

  setTimeout(() => {
    // ‚úÖ Batched trong React 18!
    setCount((c) => c + 1);
    setFlag((f) => !f);
  }, 1000);

  fetch("/api/data").then(() => {
    // ‚úÖ Batched trong React 18!
    setCount((c) => c + 1);
    setFlag((f) => !f);
  });

  return <button onClick={handleClick}>Click</button>;
}
```

#### **Opt-out kh·ªèi Batching (n·∫øu c·∫ßn)**

```jsx
import { flushSync } from "react-dom";

function handleClick() {
  // Force synchronous update
  flushSync(() => {
    setCount((c) => c + 1);
  });
  // Re-render ngay l·∫≠p t·ª©c

  flushSync(() => {
    setFlag((f) => !f);
  });
  // Re-render l·∫°i l·∫ßn n·ªØa
}
```

**‚ö†Ô∏è L∆∞u √Ω:** Hi·∫øm khi c·∫ßn `flushSync`. Ch·ªâ d√πng khi c·∫ßn sync DOM ngay l·∫≠p t·ª©c (e.g., scroll position, focus).

---

### **1.4. State Colocation**

ƒê·∫∑t state g·∫ßn n∆°i s·ª≠ d·ª•ng nh·∫•t. Kh√¥ng lift up n·∫øu kh√¥ng c·∫ßn thi·∫øt.

#### **‚ùå Anti-pattern: State qu√° cao**

```jsx
// ‚ùå State c·ªßa Modal ·ªü App level - kh√¥ng c·∫ßn thi·∫øt
function App() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalContent, setModalContent] = useState("");

  return (
    <div>
      <Header />
      <Sidebar />
      <MainContent
        onOpenModal={(content) => {
          setModalContent(content);
          setIsModalOpen(true);
        }}
      />
      <Footer />
      <Modal
        isOpen={isModalOpen}
        content={modalContent}
        onClose={() => setIsModalOpen(false)}
      />
    </div>
  );
}
```

#### **‚úÖ Better: Colocation**

```jsx
// ‚úÖ State ·ªü component d√πng n√≥
function MainContent() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalContent, setModalContent] = useState("");

  return (
    <div>
      <button
        onClick={() => {
          setModalContent("Hello");
          setIsModalOpen(true);
        }}
      >
        Open Modal
      </button>

      <Modal
        isOpen={isModalOpen}
        content={modalContent}
        onClose={() => setIsModalOpen(false)}
      />
    </div>
  );
}

function App() {
  return (
    <div>
      <Header />
      <Sidebar />
      <MainContent /> {/* State c√¥ l·∫≠p */}
      <Footer />
    </div>
  );
}
```

**L·ª£i √≠ch Colocation:**

- ‚úÖ D·ªÖ maintain
- ‚úÖ √çt re-renders kh√¥ng c·∫ßn thi·∫øt
- ‚úÖ Code d·ªÖ ƒë·ªçc h∆°n
- ‚úÖ Component ƒë·ªôc l·∫≠p h∆°n

**Khi n√†o lift state up:**

- Components kh√°c c·∫ßn access state
- Sibling components c·∫ßn sync
- Parent c·∫ßn control children
- Global state (theme, auth, etc.)

---

### **1.5. State Normalization**

Organize state nh∆∞ database - tr√°nh duplication v√† nested updates.

#### **‚ùå Nested/Denormalized State**

```jsx
// ‚ùå Kh√≥ update, d·ªÖ inconsistent
const [state, setState] = useState({
  posts: [
    {
      id: 1,
      title: "Post 1",
      author: { id: 1, name: "John" },
      comments: [
        { id: 1, text: "Comment 1", author: { id: 2, name: "Jane" } },
        { id: 2, text: "Comment 2", author: { id: 1, name: "John" } },
      ],
    },
    {
      id: 2,
      title: "Post 2",
      author: { id: 1, name: "John" }, // Duplicate!
      comments: [],
    },
  ],
});

// Update author name r·∫•t kh√≥ - ph·∫£i update nhi·ªÅu ch·ªó
```

#### **‚úÖ Normalized State**

```jsx
// ‚úÖ Flat structure, d·ªÖ update
const [state, setState] = useState({
  users: {
    1: { id: 1, name: "John" },
    2: { id: 2, name: "Jane" },
  },
  posts: {
    1: { id: 1, title: "Post 1", authorId: 1, commentIds: [1, 2] },
    2: { id: 2, title: "Post 2", authorId: 1, commentIds: [] },
  },
  comments: {
    1: { id: 1, text: "Comment 1", authorId: 2 },
    2: { id: 2, text: "Comment 2", authorId: 1 },
  },
});

// Update author name d·ªÖ d√†ng
setState((prev) => ({
  ...prev,
  users: {
    ...prev.users,
    1: { ...prev.users[1], name: "John Doe" },
  },
}));
```

#### **Normalization Utilities**

```jsx
// Helper: Normalize array
function normalizeArray(array, idKey = "id") {
  return {
    byId: array.reduce((acc, item) => {
      acc[item[idKey]] = item;
      return acc;
    }, {}),
    allIds: array.map((item) => item[idKey]),
  };
}

// Usage
const users = [
  { id: 1, name: "John" },
  { id: 2, name: "Jane" },
];

const normalized = normalizeArray(users);
// {
//   byId: { 1: {...}, 2: {...} },
//   allIds: [1, 2]
// }

// Helper: Denormalize (l·∫•y data ƒë·ªÉ render)
function denormalize(ids, byId) {
  return ids.map((id) => byId[id]).filter(Boolean);
}

// Usage
const userList = denormalize(normalized.allIds, normalized.byId);
```

---

### **1.6. Avoiding Unnecessary Re-renders**

Optimize component re-renders v·ªõi c√°c techniques:

#### **1. Component Splitting**

```jsx
// ‚ùå ExpensiveComponent re-render khi count thay ƒë·ªïi
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ExpensiveComponent /> {/* Re-render kh√¥ng c·∫ßn thi·∫øt! */}
    </div>
  );
}

// ‚úÖ T√°ch th√†nh separate component
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}

function Parent() {
  return (
    <div>
      <Counter /> {/* State c√¥ l·∫≠p */}
      <ExpensiveComponent /> {/* Kh√¥ng re-render */}
    </div>
  );
}
```

#### **2. Children as Props**

```jsx
function Parent({ children }) {
  const [count, setCount] = useState(0);
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      {children}
    </div>
  );
}

// ‚úÖ children KH√îNG re-render (ƒë√£ render ·ªü c·∫•p cao h∆°n)
function App() {
  return (
    <Parent>
      <ExpensiveComponent /> {/* Kh√¥ng re-render khi Parent state thay ƒë·ªïi */}
    </Parent>
  );
}
```

#### **3. useMemo cho Expensive Calculations**

```jsx
function ProductList({ products, filter }) {
  // ‚ùå Filter ch·∫°y m·ªói render
  const filteredProducts = products.filter((p) => p.category === filter);

  // ‚úÖ Ch·ªâ filter khi products ho·∫∑c filter thay ƒë·ªïi
  const filteredProducts = useMemo(() => {
    console.log("Filtering...");
    return products.filter((p) => p.category === filter);
  }, [products, filter]);

  return (
    <ul>
      {filteredProducts.map((p) => (
        <li key={p.id}>{p.name}</li>
      ))}
    </ul>
  );
}
```

#### **4. useCallback cho Functions**

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  // ‚ùå handleClick l√† new function m·ªói render
  const handleClick = () => {
    console.log("Clicked");
  };

  // ‚úÖ handleClick ƒë∆∞·ª£c memoize
  const handleClick = useCallback(() => {
    console.log("Clicked");
  }, []);

  return <MemoizedChild onClick={handleClick} />;
}

const MemoizedChild = React.memo(function Child({ onClick }) {
  console.log("Child render");
  return <button onClick={onClick}>Click</button>;
});
```

#### **5. React.memo**

```jsx
// Prevent re-render n·∫øu props kh√¥ng ƒë·ªïi
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
  console.log("Expensive render");
  return <div>{/* expensive rendering */}</div>;
});

// Custom comparison function
const CustomMemo = React.memo(
  function Component({ user }) {
    return <div>{user.name}</div>;
  },
  (prevProps, nextProps) => {
    // Return true n·∫øu props gi·ªëng nhau (skip re-render)
    return prevProps.user.id === nextProps.user.id;
  }
);
```

---

## üíª PH·∫¶N 2: CODE DEMO (30-45 ph√∫t)

### **Demo 1: Lifting State - Todo Filter App**

```jsx
function TodoFilter({ filter, onFilterChange }) {
  return (
    <div className="filters">
      <button
        onClick={() => onFilterChange("all")}
        className={filter === "all" ? "active" : ""}
      >
        T·∫•t c·∫£
      </button>
      <button
        onClick={() => onFilterChange("active")}
        className={filter === "active" ? "active" : ""}
      >
        ƒêang l√†m
      </button>
      <button
        onClick={() => onFilterChange("completed")}
        className={filter === "completed" ? "active" : ""}
      >
        Ho√†n th√†nh
      </button>
    </div>
  );
}

function TodoList({ todos, filter, onToggle }) {
  // ‚úÖ Derived state - filtered todos
  const filteredTodos = useMemo(() => {
    console.log("Filtering todos...");
    switch (filter) {
      case "active":
        return todos.filter((t) => !t.completed);
      case "completed":
        return todos.filter((t) => t.completed);
      default:
        return todos;
    }
  }, [todos, filter]);

  return (
    <ul>
      {filteredTodos.map((todo) => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => onToggle(todo.id)}
          />
          <span
            style={{ textDecoration: todo.completed ? "line-through" : "none" }}
          >
            {todo.text}
          </span>
        </li>
      ))}
    </ul>
  );
}

function TodoStats({ todos }) {
  // ‚úÖ Derived state - statistics
  const stats = useMemo(
    () => ({
      total: todos.length,
      completed: todos.filter((t) => t.completed).length,
      active: todos.filter((t) => !t.completed).length,
    }),
    [todos]
  );

  return (
    <div className="stats">
      <p>T·ªïng: {stats.total}</p>
      <p>Ho√†n th√†nh: {stats.completed}</p>
      <p>C√≤n l·∫°i: {stats.active}</p>
    </div>
  );
}

function TodoApp() {
  // ‚úÖ State lifted up to parent
  const [todos, setTodos] = useState([
    { id: 1, text: "H·ªçc React", completed: false },
    { id: 2, text: "L√†m b√†i t·∫≠p", completed: true },
    { id: 3, text: "Review code", completed: false },
  ]);
  const [filter, setFilter] = useState("all");

  const handleToggle = useCallback((id) => {
    setTodos((prev) =>
      prev.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  }, []);

  return (
    <div className="todo-app">
      <h1>Todo App</h1>
      <TodoFilter filter={filter} onFilterChange={setFilter} />
      <TodoList todos={todos} filter={filter} onToggle={handleToggle} />
      <TodoStats todos={todos} />
    </div>
  );
}
```

### **Demo 2: Normalized State - Blog App**

```jsx
function BlogApp() {
  // ‚úÖ Normalized state structure
  const [state, setState] = useState({
    users: {
      1: { id: 1, name: "John Doe", avatar: "üë®" },
      2: { id: 2, name: "Jane Smith", avatar: "üë©" },
    },
    posts: {
      1: { id: 1, title: "React Hooks", authorId: 1, commentIds: [1, 2] },
      2: { id: 2, title: "State Management", authorId: 2, commentIds: [3] },
    },
    comments: {
      1: { id: 1, text: "Great post!", authorId: 2 },
      2: { id: 2, text: "Thanks!", authorId: 1 },
      3: { id: 3, text: "Very helpful", authorId: 1 },
    },
    postIds: [1, 2],
  });

  // Helper: Get post with relations
  const getPostWithDetails = useCallback(
    (postId) => {
      const post = state.posts[postId];
      const author = state.users[post.authorId];
      const comments = post.commentIds.map((commentId) => ({
        ...state.comments[commentId],
        author: state.users[state.comments[commentId].authorId],
      }));

      return { ...post, author, comments };
    },
    [state]
  );

  // Add comment
  const addComment = useCallback((postId, text, authorId) => {
    const commentId = Date.now();

    setState((prev) => ({
      ...prev,
      comments: {
        ...prev.comments,
        [commentId]: { id: commentId, text, authorId },
      },
      posts: {
        ...prev.posts,
        [postId]: {
          ...prev.posts[postId],
          commentIds: [...prev.posts[postId].commentIds, commentId],
        },
      },
    }));
  }, []);

  // Update user name (d·ªÖ d√†ng v·ªõi normalized state)
  const updateUserName = useCallback((userId, newName) => {
    setState((prev) => ({
      ...prev,
      users: {
        ...prev.users,
        [userId]: {
          ...prev.users[userId],
          name: newName,
        },
      },
    }));
  }, []);

  return (
    <div className="blog-app">
      <h1>Blog</h1>
      {state.postIds.map((postId) => {
        const post = getPostWithDetails(postId);
        return (
          <div key={postId} className="post">
            <h2>{post.title}</h2>
            <p>
              B·ªüi: {post.author.avatar} {post.author.name}
            </p>

            <div className="comments">
              <h3>B√¨nh lu·∫≠n ({post.comments.length})</h3>
              {post.comments.map((comment) => (
                <div key={comment.id} className="comment">
                  <strong>
                    {comment.author.avatar} {comment.author.name}:
                  </strong>
                  <p>{comment.text}</p>
                </div>
              ))}
            </div>

            <button onClick={() => addComment(postId, "New comment!", 1)}>
              Th√™m b√¨nh lu·∫≠n
            </button>
          </div>
        );
      })}

      <div className="user-manager">
        <h2>Qu·∫£n l√Ω Users</h2>
        {Object.values(state.users).map((user) => (
          <div key={user.id}>
            <span>
              {user.avatar} {user.name}
            </span>
            <button
              onClick={() => updateUserName(user.id, user.name + " Updated")}
            >
              ƒê·ªïi t√™n
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## üî® PH·∫¶N 3: TH·ª∞C H√ÄNH (60-90 ph√∫t)

### **Exercise 1: Multi-Filter Product List**

```jsx
// TODO: Implement product filtering v·ªõi lifting state up

function ProductFilters({ filters, onFilterChange }) {
  // TODO:
  // - Category filter (dropdown)
  // - Price range filter (min/max inputs)
  // - Rating filter (stars)
  // - In stock checkbox
  // - Search input

  return <div className="filters">{/* Your code */}</div>;
}

function ProductList({ products }) {
  // TODO: Render products
  return <div className="product-list">{/* Your code */}</div>;
}

function ProductStats({ products }) {
  // TODO: Derived state
  // - Total products
  // - Average price
  // - Average rating
  // - In stock count

  return <div className="stats">{/* Your code */}</div>;
}

function ProductPage() {
  const [products] = useState([
    {
      id: 1,
      name: "Laptop",
      category: "electronics",
      price: 1000,
      rating: 4.5,
      inStock: true,
    },
    {
      id: 2,
      name: "Phone",
      category: "electronics",
      price: 500,
      rating: 4.0,
      inStock: true,
    },
    {
      id: 3,
      name: "Desk",
      category: "furniture",
      price: 300,
      rating: 4.2,
      inStock: false,
    },
    // More products...
  ]);

  const [filters, setFilters] = useState({
    category: "all",
    minPrice: "",
    maxPrice: "",
    minRating: 0,
    inStockOnly: false,
    search: "",
  });

  // TODO: Filtered products (derived state v·ªõi useMemo)
  const filteredProducts = useMemo(() => {
    // Apply all filters
  }, [products, filters]);

  return (
    <div className="product-page">
      <ProductFilters filters={filters} onFilterChange={setFilters} />
      <ProductList products={filteredProducts} />
      <ProductStats products={filteredProducts} />
    </div>
  );
}
```

### **Exercise 2: E-commerce Cart v·ªõi Normalized State**

```jsx
// TODO: Implement shopping cart v·ªõi normalized structure

function CartApp() {
  const [state, setState] = useState({
    products: {
      // Catalog products
      1: { id: 1, name: "√Åo thun", price: 150000, image: "üëï", stock: 10 },
      2: { id: 2, name: "Qu·∫ßn jean", price: 350000, image: "üëñ", stock: 5 },
      3: { id: 3, name: "Gi√†y", price: 500000, image: "üëü", stock: 3 },
      4: { id: 4, name: "T√∫i", price: 250000, image: "üëú", stock: 8 },
    },
    cart: {
      // Cart items: { productId: quantity }
      // e.g., { 1: 2, 3: 1 } = 2 √°o thun, 1 gi√†y
    },
    coupons: {
      GIAM10: { code: "GIAM10", discount: 10, type: "percent" },
      GIAM50K: { code: "GIAM50K", discount: 50000, type: "fixed" },
    },
    appliedCoupon: null,
    shippingMethod: "standard", // 'standard' | 'express'
  });

  // TODO: Implement functions
  // - addToCart(productId)
  // - removeFromCart(productId)
  // - updateQuantity(productId, quantity)
  // - applyCoupon(code)
  // - removeCoupon()
  // - changeShippingMethod(method)

  // TODO: Derived state v·ªõi useMemo
  // - cartItems: denormalize cart
  // - subtotal
  // - discount (from coupon)
  // - shippingCost (standard: 30k, express: 50k, free if > 500k)
  // - tax (10%)
  // - total
  // - itemCount

  const addToCart = useCallback((productId) => {
    setState((prev) => {
      const product = prev.products[productId];
      const currentQty = prev.cart[productId] || 0;

      // Check stock
      if (currentQty >= product.stock) {
        alert("Kh√¥ng ƒë·ªß h√†ng!");
        return prev;
      }

      return {
        ...prev,
        cart: {
          ...prev.cart,
          [productId]: currentQty + 1,
        },
      };
    });
  }, []);

  // TODO: Implement other functions

  // TODO: Derived state
  const cartItems = useMemo(() => {
    // Convert cart object to array with product details
  }, [state.cart, state.products]);

  const subtotal = useMemo(() => {
    // Calculate subtotal
  }, [cartItems]);

  const discount = useMemo(() => {
    // Calculate discount from coupon
  }, [subtotal, state.appliedCoupon, state.coupons]);

  const shippingCost = useMemo(() => {
    // Calculate shipping
  }, [subtotal, state.shippingMethod]);

  const total = useMemo(() => {
    // Calculate total
  }, [subtotal, discount, shippingCost]);

  return (
    <div className="cart-app">
      <div className="products">
        <h2>S·∫£n ph·∫©m</h2>
        {Object.values(state.products).map((product) => (
          <div key={product.id} className="product-card">
            {/* TODO: Product card v·ªõi add to cart button */}
          </div>
        ))}
      </div>

      <div className="cart">
        <h2>Gi·ªè h√†ng</h2>
        {/* TODO: Cart items */}
        {/* TODO: Coupon section */}
        {/* TODO: Shipping method selector */}
        {/* TODO: Order summary */}
      </div>
    </div>
  );
}
```

### **Exercise 3: Real-time Chat v·ªõi State Colocation**

```jsx
// TODO: Implement chat app v·ªõi proper state placement

function ChatRoom({ roomId, currentUserId }) {
  // TODO: State cho chat room n√†y
  // - messages: array of messages
  // - isTyping: { userId: boolean }
  // - onlineUsers: array of user IDs

  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [replyingTo, setReplyingTo] = useState(null);

  // TODO: Implement
  // - sendMessage
  // - deleteMessage
  // - editMessage
  // - replyToMessage
  // - loadMoreMessages (pagination)

  // TODO: Simulate typing indicator
  // useEffect v·ªõi debounce khi user type

  return (
    <div className="chat-room">
      <div className="messages">{/* TODO: Message list */}</div>

      {replyingTo && (
        <div className="replying-to">
          ƒêang tr·∫£ l·ªùi: {replyingTo.text}
          <button onClick={() => setReplyingTo(null)}>√ó</button>
        </div>
      )}

      <div className="input-area">
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={(e) => e.key === "Enter" && sendMessage()}
          placeholder="Nh·∫≠p tin nh·∫Øn..."
        />
        <button onClick={sendMessage}>G·ª≠i</button>
      </div>
    </div>
  );
}

function ChatApp() {
  // TODO: State ·ªü App level (higher level)
  // - rooms: array of rooms
  // - currentRoomId
  // - currentUser

  const [rooms] = useState([
    { id: 1, name: "General", unread: 3 },
    { id: 2, name: "Random", unread: 0 },
    { id: 3, name: "Tech", unread: 1 },
  ]);

  const [currentRoomId, setCurrentRoomId] = useState(1);

  return (
    <div className="chat-app">
      <div className="sidebar">
        <h2>Rooms</h2>
        {rooms.map((room) => (
          <div
            key={room.id}
            className={`room ${room.id === currentRoomId ? "active" : ""}`}
            onClick={() => setCurrentRoomId(room.id)}
          >
            {room.name}
            {room.unread > 0 && <span className="badge">{room.unread}</span>}
          </div>
        ))}
      </div>

      <div className="main">
        {/* ChatRoom state c√¥ l·∫≠p cho m·ªói room */}
        <ChatRoom
          key={currentRoomId} // Re-mount khi ƒë·ªïi room
          roomId={currentRoomId}
          currentUserId={1}
        />
      </div>
    </div>
  );
}
```

### **Exercise 4: Dashboard v·ªõi Multiple Widgets**

```jsx
// TODO: Implement dashboard v·ªõi state optimization

// Widget c√≥ independent state
function SalesWidget() {
  const [period, setPeriod] = useState("week"); // 'week' | 'month' | 'year'
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);

  // TODO: Fetch data based on period
  useEffect(() => {
    // Simulate API call
  }, [period]);

  // TODO: Derived state - statistics
  const stats = useMemo(() => {
    // Calculate from data
  }, [data]);

  return (
    <div className="widget">
      <h3>Doanh thu</h3>
      {/* TODO: Render widget */}
    </div>
  );
}

function UserStatsWidget() {
  // TODO: Independent state
  return <div className="widget">{/* ... */}</div>;
}

function RecentOrdersWidget() {
  // TODO: Independent state
  return <div className="widget">{/* ... */}</div>;
}

function Dashboard() {
  // TODO: Shared/global state n·∫øu c·∫ßn
  // - theme
  // - user info
  // - notifications

  const [layout, setLayout] = useState("grid"); // 'grid' | 'list'

  return (
    <div className={`dashboard ${layout}`}>
      <h1>Dashboard</h1>

      <div className="controls">
        <button onClick={() => setLayout("grid")}>Grid</button>
        <button onClick={() => setLayout("list")}>List</button>
      </div>

      {/* M·ªói widget c√≥ state ri√™ng */}
      <SalesWidget />
      <UserStatsWidget />
      <RecentOrdersWidget />
    </div>
  );
}
```

### **Exercise 5: Form Wizard v·ªõi Complex State (Challenge)**

```jsx
// TODO: Multi-step form v·ªõi validation v√† derived state

const STEPS = ["account", "profile", "preferences", "review"];

function FormWizard() {
  const [currentStep, setCurrentStep] = useState(0);

  const [formData, setFormData] = useState({
    account: {
      email: "",
      username: "",
      password: "",
      confirmPassword: "",
    },
    profile: {
      firstName: "",
      lastName: "",
      birthDate: "",
      gender: "",
      phone: "",
      avatar: null,
    },
    preferences: {
      newsletter: false,
      notifications: {
        email: true,
        sms: false,
        push: true,
      },
      theme: "light",
      language: "vi",
    },
  });

  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  // TODO: Validation functions cho m·ªói step
  const validateAccount = useCallback(() => {
    const errors = {};
    const { email, username, password, confirmPassword } = formData.account;

    if (!email) {
      errors.email = "Email l√† b·∫Øt bu·ªôc";
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      errors.email = "Email kh√¥ng h·ª£p l·ªá";
    }

    if (!username) {
      errors.username = "Username l√† b·∫Øt bu·ªôc";
    } else if (username.length < 3) {
      errors.username = "Username ph·∫£i ‚â• 3 k√Ω t·ª±";
    }

    if (!password) {
      errors.password = "M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc";
    } else if (password.length < 6) {
      errors.password = "M·∫≠t kh·∫©u ph·∫£i ‚â• 6 k√Ω t·ª±";
    }

    if (password !== confirmPassword) {
      errors.confirmPassword = "M·∫≠t kh·∫©u kh√¥ng kh·ªõp";
    }

    return errors;
  }, [formData.account]);

  const validateProfile = useCallback(() => {
    // TODO: Validate profile step
  }, [formData.profile]);

  // TODO: Derived state - step validation
  const stepValidations = useMemo(
    () => ({
      account: validateAccount(),
      profile: validateProfile(),
      preferences: {}, // No validation
    }),
    [validateAccount, validateProfile]
  );

  // TODO: Derived state - can proceed to next step
  const canProceed = useMemo(() => {
    const currentStepName = STEPS[currentStep];
    const currentErrors = stepValidations[currentStepName];
    return Object.keys(currentErrors).length === 0;
  }, [currentStep, stepValidations]);

  // TODO: Derived state - overall form completion
  const completion = useMemo(() => {
    // Calculate % completion based on filled fields
    let totalFields = 0;
    let filledFields = 0;

    // Count all fields
    Object.values(formData).forEach((section) => {
      Object.values(section).forEach((value) => {
        totalFields++;
        if (value && value !== "" && value !== false) {
          filledFields++;
        }
      });
    });

    return Math.round((filledFields / totalFields) * 100);
  }, [formData]);

  const updateField = useCallback((step, field, value) => {
    setFormData((prev) => ({
      ...prev,
      [step]: {
        ...prev[step],
        [field]: value,
      },
    }));

    // Mark as touched
    setTouched((prev) => ({
      ...prev,
      [`${step}.${field}`]: true,
    }));
  }, []);

  const handleNext = () => {
    if (canProceed && currentStep < STEPS.length - 1) {
      setCurrentStep((prev) => prev + 1);
    }
  };

  const handlePrev = () => {
    if (currentStep > 0) {
      setCurrentStep((prev) => prev - 1);
    }
  };

  const handleSubmit = async () => {
    // TODO: Submit form
    console.log("Submitting:", formData);
  };

  const renderStepContent = () => {
    const stepName = STEPS[currentStep];
    const stepData = formData[stepName];
    const stepErrors = stepValidations[stepName];

    switch (stepName) {
      case "account":
        return (
          <div className="step-content">
            <h2>Th√¥ng tin t√†i kho·∫£n</h2>
            {/* TODO: Render form fields */}
          </div>
        );

      case "profile":
        return (
          <div className="step-content">
            <h2>Th√¥ng tin c√° nh√¢n</h2>
            {/* TODO: Render form fields */}
          </div>
        );

      case "preferences":
        return (
          <div className="step-content">
            <h2>T√πy ch·ªçn</h2>
            {/* TODO: Render preferences */}
          </div>
        );

      case "review":
        return (
          <div className="step-content">
            <h2>X√°c nh·∫≠n th√¥ng tin</h2>
            {/* TODO: Review all data */}
            <div className="review-section">
              <h3>T√†i kho·∫£n</h3>
              <p>Email: {formData.account.email}</p>
              <p>Username: {formData.account.username}</p>
            </div>
            <div className="review-section">
              <h3>H·ªì s∆°</h3>
              <p>
                T√™n: {formData.profile.firstName} {formData.profile.lastName}
              </p>
              <p>Ng√†y sinh: {formData.profile.birthDate}</p>
            </div>
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <div className="form-wizard">
      <h1>ƒêƒÉng k√Ω t√†i kho·∫£n</h1>

      {/* Progress indicator */}
      <div className="progress">
        <div className="progress-bar" style={{ width: `${completion}%` }}>
          {completion}%
        </div>
      </div>

      {/* Steps indicator */}
      <div className="steps">
        {STEPS.map((step, index) => (
          <div
            key={step}
            className={`step ${index === currentStep ? "active" : ""} ${
              index < currentStep ? "completed" : ""
            }`}
          >
            <div className="step-number">{index + 1}</div>
            <div className="step-name">{step}</div>
          </div>
        ))}
      </div>

      {/* Step content */}
      {renderStepContent()}

      {/* Navigation */}
      <div className="navigation">
        <button onClick={handlePrev} disabled={currentStep === 0}>
          Quay l·∫°i
        </button>

        {currentStep < STEPS.length - 1 ? (
          <button onClick={handleNext} disabled={!canProceed}>
            Ti·∫øp t·ª•c
          </button>
        ) : (
          <button onClick={handleSubmit}>Ho√†n t·∫•t</button>
        )}
      </div>

      {/* Validation summary */}
      {!canProceed && (
        <div className="validation-summary">
          <p>Vui l√≤ng ho√†n th√†nh c√°c tr∆∞·ªùng b·∫Øt bu·ªôc:</p>
          <ul>
            {Object.entries(stepValidations[STEPS[currentStep]]).map(
              ([field, error]) => (
                <li key={field}>{error}</li>
              )
            )}
          </ul>
        </div>
      )}
    </div>
  );
}
```

---

## ‚úÖ PH·∫¶N 4: REVIEW & CHECKLIST (15-30 ph√∫t)

### **Lifting State Up:**

- [ ] ƒê∆∞a state l√™n component cha chung g·∫ßn nh·∫•t
- [ ] Pass state down qua props
- [ ] Pass callbacks ƒë·ªÉ update state
- [ ] Single source of truth

### **Derived State:**

- [ ] T√≠nh to√°n t·ª´ existing state/props
- [ ] KH√îNG l∆∞u v√†o state
- [ ] D√πng useMemo cho expensive calculations
- [ ] Tr√°nh redundant state

### **State Batching:**

- [ ] React 18: automatic batching everywhere
- [ ] Multiple setState ƒë∆∞·ª£c batched
- [ ] `flushSync` ƒë·ªÉ opt-out (hi·∫øm khi c·∫ßn)

### **State Colocation:**

- [ ] ƒê·∫∑t state g·∫ßn n∆°i d√πng nh·∫•t
- [ ] Kh√¥ng lift up n·∫øu kh√¥ng c·∫ßn
- [ ] Component ƒë·ªôc l·∫≠p h∆°n
- [ ] √çt re-renders kh√¥ng c·∫ßn thi·∫øt

### **State Normalization:**

- [ ] Flat structure, kh√¥ng nested s√¢u
- [ ] D√πng IDs ƒë·ªÉ reference
- [ ] byId + allIds pattern
- [ ] D·ªÖ update, tr√°nh duplication

### **Optimization:**

- [ ] Component splitting
- [ ] Children as props
- [ ] useMemo cho expensive calculations
- [ ] useCallback cho functions
- [ ] React.memo cho components

### **Common Mistakes:**

```jsx
// ‚ùå Kh√¥ng c·∫ßn lift state
function App() {
  const [modalOpen, setModalOpen] = useState(false); // Ch·ªâ Modal d√πng
  return (
    <>
      <Header />
      <Content />
      <Modal open={modalOpen} /> {/* N√™n ·ªü Modal component */}
    </>
  );
}

// ‚ùå Redundant state
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const [fullName, setFullName] = useState(''); // ‚ùå Derived!

// ‚ùå Deep nesting
const [users, setUsers] = useState([
  { id: 1, posts: [{ id: 1, comments: [...] }] } // ‚ùå Kh√≥ update
]);

// ‚ùå Expensive calculation m·ªói render
const filtered = products.filter(...); // ‚ùå Ch·∫°y m·ªói render

// ‚úÖ ƒê√öNG
function Modal() {
  const [open, setOpen] = useState(false); // State colocation
}

const fullName = `${firstName} ${lastName}`; // ‚úÖ Derived

const [state] = useState({
  users: { 1: {...} },
  posts: { 1: {...} }
}); // ‚úÖ Normalized

const filtered = useMemo(() =>
  products.filter(...),
  [products, filter]
); // ‚úÖ Memoized
```

---

## üéØ HOMEWORK

### **1. Social Media Feed**

```jsx
// TODO: Implement feed v·ªõi proper state management
// Features:
// - Posts v·ªõi likes, comments, shares
// - Normalized state (users, posts, comments)
// - Like/unlike (optimistic update)
// - Add comment
// - Filter posts (following, recommended, trending)
// - Infinite scroll
// - Derived state: stats per post
```

### **2. Kanban Board v2**

```jsx
// TODO: Trello-like board
// Features:
// - Multiple boards
// - Normalized state (boards, lists, cards)
// - Drag & drop cards between lists
// - Card details (description, checklist, due date)
// - Search cards across all boards
// - Filter by labels, assignee
// - Statistics dashboard (derived state)
```

### **3. E-learning Platform**

```jsx
// TODO: Course management
// Features:
// - Courses, modules, lessons (normalized)
// - Progress tracking per user
// - Quizzes v·ªõi scores
// - Certificate generation (derived state)
// - Leaderboard (derived state)
// - Course completion % (derived state)
```

### **4. Expense Splitter**

```jsx
// TODO: Split expenses among friends
// Features:
// - Users, expenses, payments (normalized)
// - Add expense v·ªõi multiple payers
// - Calculate who owes whom (derived state)
// - Settle debts
// - Export settlement summary
// - Statistics per user
```

### **5. Project Management Tool (Challenge)**

```jsx
// TODO: Asana/Jira-like tool
// Features:
// - Projects, tasks, subtasks, comments
// - Normalized state structure
// - Task dependencies
// - Timeline view (Gantt chart)
// - Team members v√† assignments
// - Workload per member (derived state)
// - Project completion (derived state)
// - Time tracking
// - Export reports
```

---

## üìö ƒê·ªçc Th√™m

### **Official Docs:**

- [React - Sharing State Between Components](https://react.dev/learn/sharing-state-between-components)
- [React - Choosing the State Structure](https://react.dev/learn/choosing-the-state-structure)
- [React - Preserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state)
- [React 18 - Automatic Batching](https://react.dev/blog/2022/03/29/react-v18#new-feature-automatic-batching)

### **Advanced Reading:**

- [Kent C. Dodds - State Colocation](https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster)
- [Redux - Normalizing State Shape](https://redux.js.org/usage/structuring-reducers/normalizing-state-shape)
- [Dan Abramov - Before You memo()](https://overreacted.io/before-you-memo/)

---

## üìù Key Takeaways

1. **Lifting State Up** - Share state b·∫±ng c√°ch ƒë∆∞a l√™n parent
2. **Derived State** - T√≠nh to√°n, kh√¥ng duplicate state
3. **Automatic Batching** - React 18 batch t·ª± ƒë·ªông
4. **State Colocation** - ƒê·∫∑t state g·∫ßn n∆°i d√πng
5. **Normalization** - Flat structure, d·ªÖ update
6. **Optimization** - useMemo, useCallback, React.memo
7. **Single Source of Truth** - M·ªôt state, nhi·ªÅu consumers

---

## üí° Pro Tips

1. **Start simple**: ƒê·ª´ng normalize/optimize s·ªõm
2. **Measure first**: Profile tr∆∞·ªõc khi optimize
3. **Colocation**: M·∫∑c ƒë·ªãnh ƒë·ªÉ state th·∫•p, lift khi c·∫ßn
4. **Derived > Duplicate**: T√≠nh to√°n t·ªët h∆°n sync
5. **DevTools**: React DevTools Profiler ƒë·ªÉ t√¨m bottlenecks

---

## üéÆ Quick Quiz

1. Khi n√†o c·∫ßn lifting state up?
2. T·∫°i sao kh√¥ng n√™n duplicate derived state?
3. React 18 batch state updates ·ªü ƒë√¢u?
4. Normalized state gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ g√¨?
5. useMemo kh√°c g√¨ v·ªõi derived state th√¥ng th∆∞·ªùng?

**ƒê√°p √°n:**

1. Khi nhi·ªÅu components c·∫ßn share/sync state
2. Kh√≥ sync, d·ªÖ inconsistent, ph·ª©c t·∫°p h∆°n
3. M·ªçi n∆°i (event handlers, promises, timeouts)
4. Tr√°nh duplication, d·ªÖ update nested data
5. useMemo cache k·∫øt qu·∫£, ch·ªâ recalculate khi deps thay ƒë·ªïi

---

**üöÄ Ng√†y mai (Ng√†y 9):** useEffect & Side Effects - Data fetching, subscriptions, v√† cleanup! üí™

**Ho√†n th√†nh √≠t nh·∫•t 3/5 exercises!**
