# üìÖ NG√ÄY 7: useReducer - Complex State Logic

## üéØ M·ª•c ti√™u h√¥m nay

- Hi·ªÉu useReducer v√† khi n√†o d√πng
- Reducer pattern v√† Redux-like state management
- Action types v√† action creators
- So s√°nh useReducer vs useState
- Complex state logic patterns
- Best practices v√† optimization

---

## üìö PH·∫¶N 1: L√ù THUY·∫æT (30-45 ph√∫t)

### **1.1. useReducer L√† G√¨?**

useReducer l√† hook ƒë·ªÉ qu·∫£n l√Ω state ph·ª©c t·∫°p v·ªõi logic t·∫≠p trung v√†o m·ªôt reducer function.

#### **Syntax c∆° b·∫£n**

```jsx
const [state, dispatch] = useReducer(reducer, initialState);

// reducer: function x·ª≠ l√Ω state transitions
// initialState: gi√° tr·ªã kh·ªüi t·∫°o
// state: state hi·ªán t·∫°i
// dispatch: function ƒë·ªÉ g·ª≠i actions
```

#### **V√≠ d·ª• ƒë∆°n gi·∫£n**

```jsx
import { useReducer } from "react";

// 1. ƒê·ªãnh nghƒ©a reducer function
function counterReducer(state, action) {
  switch (action.type) {
    case "INCREMENT":
      return { count: state.count + 1 };
    case "DECREMENT":
      return { count: state.count - 1 };
    case "RESET":
      return { count: 0 };
    default:
      return state;
  }
}

// 2. Component s·ª≠ d·ª•ng useReducer
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "INCREMENT" })}>+</button>
      <button onClick={() => dispatch({ type: "DECREMENT" })}>-</button>
      <button onClick={() => dispatch({ type: "RESET" })}>Reset</button>
    </div>
  );
}
```

---

### **1.2. Reducer Pattern**

Reducer l√† pure function nh·∫≠n `(currentState, action)` v√† tr·∫£ v·ªÅ `newState`.

#### **Anatomy c·ªßa Reducer**

```jsx
function reducer(state, action) {
  // 1. Ki·ªÉm tra action type
  // 2. T√≠nh to√°n state m·ªõi d·ª±a tr√™n action
  // 3. Tr·∫£ v·ªÅ state m·ªõi (IMMUTABLE!)

  switch (action.type) {
    case "ACTION_TYPE":
      return { ...state /* updates */ };
    default:
      return state; // Lu√¥n return state n·∫øu kh√¥ng match
  }
}
```

#### **Quy t·∫Øc Reducer:**

‚úÖ **PH·∫¢I:**

- Pure function (no side effects)
- Kh√¥ng mutate state
- Kh√¥ng call API, random(), Date.now()
- Lu√¥n return new state object
- X·ª≠ l√Ω default case

‚ùå **KH√îNG ƒê∆Ø·ª¢C:**

- Mutate state tr·ª±c ti·∫øp
- Async operations
- Side effects
- Non-deterministic operations

```jsx
// ‚ùå SAI - Mutate state
function badReducer(state, action) {
  state.count++; // NEVER!
  return state;
}

// ‚ùå SAI - Side effects
function badReducer(state, action) {
  console.log("Action:", action); // Side effect!
  fetch("/api/data"); // Async operation!
  return { ...state };
}

// ‚úÖ ƒê√öNG - Pure function
function goodReducer(state, action) {
  switch (action.type) {
    case "INCREMENT":
      return { ...state, count: state.count + 1 };
    default:
      return state;
  }
}
```

---

### **1.3. Actions v√† Action Types**

#### **Action Object Structure**

```jsx
// Action c∆° b·∫£n
{
  type: 'ACTION_TYPE' // B·∫Øt bu·ªôc
}

// Action v·ªõi payload
{
  type: 'ADD_TODO',
  payload: { id: 1, text: 'Learn React' }
}

// Action v·ªõi multiple data
{
  type: 'UPDATE_USER',
  payload: {
    id: 123,
    updates: { name: 'John', age: 30 }
  }
}
```

#### **Action Types Constants**

```jsx
// ‚úÖ Best Practice: ƒê·ªãnh nghƒ©a constants
const ACTION_TYPES = {
  ADD_TODO: "ADD_TODO",
  TOGGLE_TODO: "TOGGLE_TODO",
  DELETE_TODO: "DELETE_TODO",
  SET_FILTER: "SET_FILTER",
};

// Ho·∫∑c d√πng object freeze
const ACTIONS = Object.freeze({
  ADD_TODO: "ADD_TODO",
  TOGGLE_TODO: "TOGGLE_TODO",
});

// Reducer
function todoReducer(state, action) {
  switch (action.type) {
    case ACTION_TYPES.ADD_TODO:
      return {
        ...state,
        todos: [...state.todos, action.payload],
      };
    case ACTION_TYPES.TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        ),
      };
    default:
      return state;
  }
}
```

**L·ª£i √≠ch c·ªßa constants:**

- Tr√°nh typo
- Autocomplete trong IDE
- Refactor d·ªÖ d√†ng
- Type safety (v·ªõi TypeScript)

#### **Action Creators**

Functions t·∫°o action objects (optional nh∆∞ng recommended):

```jsx
// Action creators
const todoActions = {
  add: (text) => ({
    type: "ADD_TODO",
    payload: {
      id: Date.now(),
      text,
      completed: false,
    },
  }),

  toggle: (id) => ({
    type: "TOGGLE_TODO",
    payload: id,
  }),

  delete: (id) => ({
    type: "DELETE_TODO",
    payload: id,
  }),

  update: (id, text) => ({
    type: "UPDATE_TODO",
    payload: { id, text },
  }),
};

// Usage
function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState);

  const handleAdd = (text) => {
    dispatch(todoActions.add(text)); // ‚úÖ Clean v√† d·ªÖ ƒë·ªçc
  };

  const handleToggle = (id) => {
    dispatch(todoActions.toggle(id));
  };
}
```

---

### **1.4. Initial State v√† Lazy Initialization**

#### **C√°ch 1: Initial State ƒë∆°n gi·∫£n**

```jsx
const initialState = {
  count: 0,
  step: 1,
};

const [state, dispatch] = useReducer(reducer, initialState);
```

#### **C√°ch 2: Lazy Initialization**

```jsx
// Init function
function init(initialCount) {
  return {
    count: initialCount,
    history: [initialCount],
  };
}

// Usage
const [state, dispatch] = useReducer(reducer, initialCount, init);

// init ch·ªâ ch·∫°y l·∫ßn ƒë·∫ßu
```

**Khi n√†o d√πng lazy init:**

- T√≠nh to√°n ph·ª©c t·∫°p
- ƒê·ªçc t·ª´ localStorage
- Depends on props

```jsx
function TodoApp({ userId }) {
  // ‚úÖ Lazy init t·ª´ localStorage
  function init() {
    const saved = localStorage.getItem(`todos-${userId}`);
    return saved ? JSON.parse(saved) : { todos: [], filter: "all" };
  }

  const [state, dispatch] = useReducer(todoReducer, null, init);
}
```

---

### **1.5. useReducer vs useState**

#### **Khi n√†o d√πng useState?**

‚úÖ D√πng useState khi:

- State ƒë∆°n gi·∫£n (primitives)
- Logic update ƒë∆°n gi·∫£n
- State ƒë·ªôc l·∫≠p
- √çt transitions

```jsx
// ‚úÖ useState ph√π h·ª£p
function Toggle() {
  const [isOpen, setIsOpen] = useState(false);
  return <button onClick={() => setIsOpen(!isOpen)}>Toggle</button>;
}

function Form() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  return (
    <>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <input value={email} onChange={(e) => setEmail(e.target.value)} />
    </>
  );
}
```

#### **Khi n√†o d√πng useReducer?**

‚úÖ D√πng useReducer khi:

- State ph·ª©c t·∫°p (nested objects/arrays)
- Nhi·ªÅu sub-values
- Logic update ph·ª©c t·∫°p
- State transitions li√™n quan nhau
- C·∫ßn t·∫≠p trung logic v√†o m·ªôt ch·ªó
- Testing logic ri√™ng bi·ªát

```jsx
// ‚úÖ useReducer ph√π h·ª£p
function TodoApp() {
  // State ph·ª©c t·∫°p v·ªõi nhi·ªÅu properties related
  const [state, dispatch] = useReducer(todoReducer, {
    todos: [],
    filter: "all",
    sortBy: "date",
    searchTerm: "",
    editingId: null,
  });

  // Nhi·ªÅu actions ph·ª©c t·∫°p
  dispatch({ type: "ADD_TODO", payload: newTodo });
  dispatch({ type: "BULK_DELETE", payload: selectedIds });
  dispatch({ type: "REORDER", payload: { from, to } });
}
```

#### **So s√°nh tr·ª±c ti·∫øp**

```jsx
// useState - Simple counter
function CounterWithState() {
  const [count, setCount] = useState(0);

  return (
    <>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </>
  );
}

// useReducer - Counter with history v√† undo
function CounterWithReducer() {
  const [state, dispatch] = useReducer(
    (state, action) => {
      switch (action.type) {
        case "INCREMENT":
          return {
            count: state.count + 1,
            history: [...state.history, state.count + 1],
          };
        case "DECREMENT":
          return {
            count: state.count - 1,
            history: [...state.history, state.count - 1],
          };
        case "UNDO":
          if (state.history.length <= 1) return state;
          const newHistory = state.history.slice(0, -1);
          return {
            count: newHistory[newHistory.length - 1],
            history: newHistory,
          };
        case "RESET":
          return { count: 0, history: [0] };
        default:
          return state;
      }
    },
    { count: 0, history: [0] }
  );

  return (
    <>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "INCREMENT" })}>+</button>
      <button onClick={() => dispatch({ type: "DECREMENT" })}>-</button>
      <button onClick={() => dispatch({ type: "UNDO" })}>Undo</button>
      <button onClick={() => dispatch({ type: "RESET" })}>Reset</button>
      <p>History: {state.history.join(", ")}</p>
    </>
  );
}
```

---

### **1.6. Complex State Patterns**

#### **Pattern 1: Nested State Updates**

```jsx
const initialState = {
  user: {
    profile: {
      name: "",
      email: "",
    },
    settings: {
      theme: "light",
      notifications: true,
    },
  },
  ui: {
    loading: false,
    error: null,
  },
};

function appReducer(state, action) {
  switch (action.type) {
    case "UPDATE_PROFILE":
      return {
        ...state,
        user: {
          ...state.user,
          profile: {
            ...state.user.profile,
            ...action.payload,
          },
        },
      };

    case "UPDATE_SETTINGS":
      return {
        ...state,
        user: {
          ...state.user,
          settings: {
            ...state.user.settings,
            ...action.payload,
          },
        },
      };

    case "SET_LOADING":
      return {
        ...state,
        ui: {
          ...state.ui,
          loading: action.payload,
        },
      };

    default:
      return state;
  }
}
```

#### **Pattern 2: Array Operations**

```jsx
function todoReducer(state, action) {
  switch (action.type) {
    // Th√™m item
    case "ADD":
      return {
        ...state,
        items: [...state.items, action.payload],
      };

    // X√≥a item
    case "DELETE":
      return {
        ...state,
        items: state.items.filter((item) => item.id !== action.payload),
      };

    // Update item
    case "UPDATE":
      return {
        ...state,
        items: state.items.map((item) =>
          item.id === action.payload.id
            ? { ...item, ...action.payload.updates }
            : item
        ),
      };

    // Bulk delete
    case "BULK_DELETE":
      return {
        ...state,
        items: state.items.filter((item) => !action.payload.includes(item.id)),
      };

    // Reorder (drag & drop)
    case "REORDER":
      const { from, to } = action.payload;
      const newItems = [...state.items];
      const [removed] = newItems.splice(from, 1);
      newItems.splice(to, 0, removed);
      return { ...state, items: newItems };

    // Clear completed
    case "CLEAR_COMPLETED":
      return {
        ...state,
        items: state.items.filter((item) => !item.completed),
      };

    default:
      return state;
  }
}
```

#### **Pattern 3: Multiple Related State**

```jsx
function formReducer(state, action) {
  switch (action.type) {
    case "SET_FIELD":
      return {
        ...state,
        values: {
          ...state.values,
          [action.payload.field]: action.payload.value,
        },
        // Clear error khi user type
        errors: {
          ...state.errors,
          [action.payload.field]: null,
        },
        // Mark field as touched
        touched: {
          ...state.touched,
          [action.payload.field]: true,
        },
      };

    case "SET_ERRORS":
      return {
        ...state,
        errors: action.payload,
      };

    case "SET_SUBMITTING":
      return {
        ...state,
        isSubmitting: action.payload,
      };

    case "RESET_FORM":
      return action.payload || initialState;

    case "SET_FIELD_ERROR":
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.payload.field]: action.payload.error,
        },
      };

    default:
      return state;
  }
}

// Initial state
const initialFormState = {
  values: {},
  errors: {},
  touched: {},
  isSubmitting: false,
};
```

#### **Pattern 4: State Machine Pattern**

```jsx
// Form wizard v·ªõi state machine
const STEPS = {
  PERSONAL: "PERSONAL",
  ADDRESS: "ADDRESS",
  PAYMENT: "PAYMENT",
  REVIEW: "REVIEW",
};

const initialState = {
  currentStep: STEPS.PERSONAL,
  data: {
    personal: {},
    address: {},
    payment: {},
  },
  canGoNext: false,
  canGoPrev: false,
};

function wizardReducer(state, action) {
  switch (action.type) {
    case "NEXT_STEP":
      const steps = Object.values(STEPS);
      const currentIndex = steps.indexOf(state.currentStep);
      const nextStep = steps[currentIndex + 1];

      if (!nextStep) return state;

      return {
        ...state,
        currentStep: nextStep,
        canGoPrev: true,
        canGoNext: nextStep !== STEPS.REVIEW,
      };

    case "PREV_STEP":
      const stepsArray = Object.values(STEPS);
      const index = stepsArray.indexOf(state.currentStep);
      const prevStep = stepsArray[index - 1];

      if (!prevStep) return state;

      return {
        ...state,
        currentStep: prevStep,
        canGoPrev: prevStep !== STEPS.PERSONAL,
        canGoNext: true,
      };

    case "UPDATE_STEP_DATA":
      return {
        ...state,
        data: {
          ...state.data,
          [state.currentStep.toLowerCase()]: {
            ...state.data[state.currentStep.toLowerCase()],
            ...action.payload,
          },
        },
      };

    case "RESET":
      return initialState;

    default:
      return state;
  }
}
```

---

### **1.7. Combining Multiple Reducers**

Khi app l·ªõn, split reducers theo domain:

```jsx
// User reducer
function userReducer(state, action) {
  switch (action.type) {
    case "LOGIN":
      return { ...state, user: action.payload, isAuthenticated: true };
    case "LOGOUT":
      return { ...state, user: null, isAuthenticated: false };
    default:
      return state;
  }
}

// Todos reducer
function todosReducer(state, action) {
  switch (action.type) {
    case "ADD_TODO":
      return { ...state, items: [...state.items, action.payload] };
    case "TOGGLE_TODO":
      return {
        ...state,
        items: state.items.map((todo) =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        ),
      };
    default:
      return state;
  }
}

// Combine reducers
function rootReducer(state, action) {
  return {
    user: userReducer(state.user, action),
    todos: todosReducer(state.todos, action),
  };
}

// Usage
const initialState = {
  user: { user: null, isAuthenticated: false },
  todos: { items: [], filter: "all" },
};

function App() {
  const [state, dispatch] = useReducer(rootReducer, initialState);

  // Dispatch works cho c·∫£ 2 reducers
  dispatch({ type: "LOGIN", payload: userData });
  dispatch({ type: "ADD_TODO", payload: newTodo });
}
```

---

## üíª PH·∫¶N 2: CODE DEMO (30-45 ph√∫t)

### **Demo 1: Todo App v·ªõi useReducer**

```jsx
// Action types
const ACTIONS = {
  ADD_TODO: "ADD_TODO",
  TOGGLE_TODO: "TOGGLE_TODO",
  DELETE_TODO: "DELETE_TODO",
  EDIT_TODO: "EDIT_TODO",
  SET_FILTER: "SET_FILTER",
  CLEAR_COMPLETED: "CLEAR_COMPLETED",
};

// Reducer
function todoReducer(state, action) {
  switch (action.type) {
    case ACTIONS.ADD_TODO:
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now(),
            text: action.payload,
            completed: false,
            createdAt: new Date().toISOString(),
          },
        ],
      };

    case ACTIONS.TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        ),
      };

    case ACTIONS.DELETE_TODO:
      return {
        ...state,
        todos: state.todos.filter((todo) => todo.id !== action.payload),
      };

    case ACTIONS.EDIT_TODO:
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload.id
            ? { ...todo, text: action.payload.text }
            : todo
        ),
      };

    case ACTIONS.SET_FILTER:
      return {
        ...state,
        filter: action.payload,
      };

    case ACTIONS.CLEAR_COMPLETED:
      return {
        ...state,
        todos: state.todos.filter((todo) => !todo.completed),
      };

    default:
      return state;
  }
}

// Component
function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, {
    todos: [],
    filter: "all", // 'all', 'active', 'completed'
  });

  const [inputValue, setInputValue] = useState("");

  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      dispatch({ type: ACTIONS.ADD_TODO, payload: inputValue });
      setInputValue("");
    }
  };

  const filteredTodos = state.todos.filter((todo) => {
    if (state.filter === "active") return !todo.completed;
    if (state.filter === "completed") return todo.completed;
    return true;
  });

  const stats = {
    total: state.todos.length,
    active: state.todos.filter((t) => !t.completed).length,
    completed: state.todos.filter((t) => t.completed).length,
  };

  return (
    <div className="todo-app">
      <h1>Danh S√°ch C√¥ng Vi·ªác</h1>

      {/* Form th√™m todo */}
      <form onSubmit={handleSubmit}>
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Th√™m c√¥ng vi·ªác m·ªõi..."
        />
        <button type="submit">Th√™m</button>
      </form>

      {/* Filters */}
      <div className="filters">
        <button
          onClick={() => dispatch({ type: ACTIONS.SET_FILTER, payload: "all" })}
        >
          T·∫•t c·∫£ ({stats.total})
        </button>
        <button
          onClick={() =>
            dispatch({ type: ACTIONS.SET_FILTER, payload: "active" })
          }
        >
          ƒêang l√†m ({stats.active})
        </button>
        <button
          onClick={() =>
            dispatch({ type: ACTIONS.SET_FILTER, payload: "completed" })
          }
        >
          Ho√†n th√†nh ({stats.completed})
        </button>
      </div>

      {/* Todo list */}
      <ul>
        {filteredTodos.map((todo) => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() =>
                dispatch({ type: ACTIONS.TOGGLE_TODO, payload: todo.id })
              }
            />
            <span
              style={{
                textDecoration: todo.completed ? "line-through" : "none",
              }}
            >
              {todo.text}
            </span>
            <button
              onClick={() =>
                dispatch({ type: ACTIONS.DELETE_TODO, payload: todo.id })
              }
            >
              X√≥a
            </button>
          </li>
        ))}
      </ul>

      {/* Actions */}
      {stats.completed > 0 && (
        <button onClick={() => dispatch({ type: ACTIONS.CLEAR_COMPLETED })}>
          X√≥a ƒë√£ ho√†n th√†nh
        </button>
      )}
    </div>
  );
}
```

### **Demo 2: Form v·ªõi Validation**

```jsx
const FORM_ACTIONS = {
  SET_FIELD: "SET_FIELD",
  SET_ERRORS: "SET_ERRORS",
  SET_SUBMITTING: "SET_SUBMITTING",
  RESET: "RESET",
};

function formReducer(state, action) {
  switch (action.type) {
    case FORM_ACTIONS.SET_FIELD:
      return {
        ...state,
        values: {
          ...state.values,
          [action.payload.name]: action.payload.value,
        },
        errors: {
          ...state.errors,
          [action.payload.name]: null,
        },
      };

    case FORM_ACTIONS.SET_ERRORS:
      return {
        ...state,
        errors: action.payload,
      };

    case FORM_ACTIONS.SET_SUBMITTING:
      return {
        ...state,
        isSubmitting: action.payload,
      };

    case FORM_ACTIONS.RESET:
      return {
        values: {},
        errors: {},
        isSubmitting: false,
      };

    default:
      return state;
  }
}

function RegistrationForm() {
  const [state, dispatch] = useReducer(formReducer, {
    values: {
      username: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
    errors: {},
    isSubmitting: false,
  });

  const validate = () => {
    const errors = {};

    if (!state.values.username) {
      errors.username = "T√™n ƒëƒÉng nh·∫≠p l√† b·∫Øt bu·ªôc";
    } else if (state.values.username.length < 3) {
      errors.username = "T√™n ƒëƒÉng nh·∫≠p ph·∫£i √≠t nh·∫•t 3 k√Ω t·ª±";
    }

    if (!state.values.email) {
      errors.email = "Email l√† b·∫Øt bu·ªôc";
    } else if (!/\S+@\S+\.\S+/.test(state.values.email)) {
      errors.email = "Email kh√¥ng h·ª£p l·ªá";
    }

    if (!state.values.password) {
      errors.password = "M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc";
    } else if (state.values.password.length < 6) {
      errors.password = "M·∫≠t kh·∫©u ph·∫£i √≠t nh·∫•t 6 k√Ω t·ª±";
    }

    if (state.values.password !== state.values.confirmPassword) {
      errors.confirmPassword = "M·∫≠t kh·∫©u kh√¥ng kh·ªõp";
    }

    return errors;
  };

  const handleChange = (e) => {
    dispatch({
      type: FORM_ACTIONS.SET_FIELD,
      payload: {
        name: e.target.name,
        value: e.target.value,
      },
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    const errors = validate();
    if (Object.keys(errors).length > 0) {
      dispatch({ type: FORM_ACTIONS.SET_ERRORS, payload: errors });
      return;
    }

    dispatch({ type: FORM_ACTIONS.SET_SUBMITTING, payload: true });

    try {
      // Simulate API call
      await new Promise((resolve) => setTimeout(resolve, 2000));
      console.log("Form submitted:", state.values);
      alert("ƒêƒÉng k√Ω th√†nh c√¥ng!");
      dispatch({ type: FORM_ACTIONS.RESET });
    } catch (error) {
      dispatch({
        type: FORM_ACTIONS.SET_ERRORS,
        payload: { submit: "C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i." },
      });
    } finally {
      dispatch({ type: FORM_ACTIONS.SET_SUBMITTING, payload: false });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>T√™n ƒëƒÉng nh·∫≠p:</label>
        <input
          name="username"
          value={state.values.username}
          onChange={handleChange}
          disabled={state.isSubmitting}
        />
        {state.errors.username && (
          <span className="error">{state.errors.username}</span>
        )}
      </div>

      <div>
        <label>Email:</label>
        <input
          name="email"
          type="email"
          value={state.values.email}
          onChange={handleChange}
          disabled={state.isSubmitting}
        />
        {state.errors.email && (
          <span className="error">{state.errors.email}</span>
        )}
      </div>

      <div>
        <label>M·∫≠t kh·∫©u:</label>
        <input
          name="password"
          type="password"
          value={state.values.password}
          onChange={handleChange}
          disabled={state.isSubmitting}
        />
        {state.errors.password && (
          <span className="error">{state.errors.password}</span>
        )}
      </div>

      <div>
        <label>X√°c nh·∫≠n m·∫≠t kh·∫©u:</label>
        <input
          name="confirmPassword"
          type="password"
          value={state.values.confirmPassword}
          onChange={handleChange}
          disabled={state.isSubmitting}
        />
        {state.errors.confirmPassword && (
          <span className="error">{state.errors.confirmPassword}</span>
        )}
      </div>

      {state.errors.submit && (
        <div className="error">{state.errors.submit}</div>
      )}

      <button type="submit" disabled={state.isSubmitting}>
        {state.isSubmitting ? "ƒêang x·ª≠ l√Ω..." : "ƒêƒÉng k√Ω"}
      </button>
    </form>
  );
}
```

---

## üî® PH·∫¶N 3: TH·ª∞C H√ÄNH (60-90 ph√∫t)

### **Exercise 1: Shopping Cart v·ªõi useReducer**

```jsx
// TODO: Implement shopping cart v·ªõi useReducer

const CART_ACTIONS = {
  ADD_ITEM: "ADD_ITEM",
  REMOVE_ITEM: "REMOVE_ITEM",
  UPDATE_QUANTITY: "UPDATE_QUANTITY",
  CLEAR_CART: "CLEAR_CART",
  APPLY_COUPON: "APPLY_COUPON",
  REMOVE_COUPON: "REMOVE_COUPON",
};

function cartReducer(state, action) {
  // TODO: Implement reducer
  // State structure:
  // {
  //   items: [{ id, name, price, quantity, image }],
  //   coupon: { code, discount }, // null n·∫øu kh√¥ng c√≥
  //   shipping: 30000
  // }
  // Features:
  // - Th√™m s·∫£n ph·∫©m (n·∫øu ƒë√£ c√≥ th√¨ tƒÉng quantity)
  // - X√≥a s·∫£n ph·∫©m
  // - Update quantity (x√≥a n·∫øu quantity = 0)
  // - Clear cart
  // - Apply coupon (validate code)
  // - Remove coupon
  // - Calculate: subtotal, discount, shipping, total
}

function ShoppingCart() {
  const [state, dispatch] = useReducer(cartReducer, {
    items: [],
    coupon: null,
    shipping: 30000,
  });

  // TODO: Implement
  const [couponInput, setCouponInput] = useState("");

  // Danh s√°ch s·∫£n ph·∫©m m·∫´u
  const products = [
    { id: 1, name: "√Åo thun", price: 150000, image: "üëï" },
    { id: 2, name: "Qu·∫ßn jean", price: 350000, image: "üëñ" },
    { id: 3, name: "Gi√†y th·ªÉ thao", price: 500000, image: "üëü" },
    { id: 4, name: "T√∫i x√°ch", price: 250000, image: "üëú" },
  ];

  // M√£ gi·∫£m gi√° h·ª£p l·ªá
  const validCoupons = {
    GIAM10: 10, // 10%
    GIAM50K: 50000, // 50k
    FREESHIP: 0, // Mi·ªÖn ph√≠ ship
  };

  // TODO: T√≠nh to√°n
  // const subtotal = ...
  // const discount = ...
  // const shippingCost = ...
  // const total = ...

  const handleAddToCart = (product) => {
    dispatch({
      type: CART_ACTIONS.ADD_ITEM,
      payload: product,
    });
  };

  const handleApplyCoupon = () => {
    // TODO: Validate v√† apply coupon
  };

  return (
    <div className="shopping-cart">
      <h1>Gi·ªè H√†ng</h1>

      {/* Product List */}
      <div className="products">
        <h2>S·∫£n ph·∫©m</h2>
        {products.map((product) => (
          <div key={product.id} className="product-card">
            <span className="product-icon">{product.image}</span>
            <div>
              <h3>{product.name}</h3>
              <p>{product.price.toLocaleString("vi-VN")}ƒë</p>
            </div>
            <button onClick={() => handleAddToCart(product)}>
              Th√™m v√†o gi·ªè
            </button>
          </div>
        ))}
      </div>

      {/* Cart Items */}
      <div className="cart-items">
        <h2>Gi·ªè h√†ng ({state.items.length} s·∫£n ph·∫©m)</h2>
        {/* TODO: Render cart items v·ªõi quantity controls */}
      </div>

      {/* Coupon */}
      <div className="coupon-section">
        {/* TODO: Coupon input v√† apply button */}
      </div>

      {/* Summary */}
      <div className="cart-summary">
        {/* TODO: Hi·ªÉn th·ªã subtotal, discount, shipping, total */}
      </div>
    </div>
  );
}
```

### **Exercise 2: User Authentication Flow**

```jsx
// TODO: Implement authentication state machine

const AUTH_ACTIONS = {
  LOGIN_START: "LOGIN_START",
  LOGIN_SUCCESS: "LOGIN_SUCCESS",
  LOGIN_FAILURE: "LOGIN_FAILURE",
  LOGOUT: "LOGOUT",
  REFRESH_TOKEN: "REFRESH_TOKEN",
  UPDATE_PROFILE: "UPDATE_PROFILE",
};

function authReducer(state, action) {
  // TODO: Implement reducer
  // State structure:
  // {
  //   user: { id, name, email, avatar } | null,
  //   isAuthenticated: boolean,
  //   isLoading: boolean,
  //   error: string | null,
  //   token: string | null
  // }
  // States: idle, loading, authenticated, error
  // Transitions:
  // - idle -> loading (LOGIN_START)
  // - loading -> authenticated (LOGIN_SUCCESS)
  // - loading -> error (LOGIN_FAILURE)
  // - authenticated -> idle (LOGOUT)
}

function AuthApp() {
  const [state, dispatch] = useReducer(authReducer, {
    user: null,
    isAuthenticated: false,
    isLoading: false,
    error: null,
    token: null,
  });

  const [credentials, setCredentials] = useState({
    email: "",
    password: "",
  });

  // TODO: Implement
  // - handleLogin (async)
  // - handleLogout
  // - handleUpdateProfile
  // - Load user from localStorage on mount
  // - Save to localStorage on login
  // - Clear localStorage on logout

  return (
    <div className="auth-app">
      {!state.isAuthenticated ? (
        <div className="login-form">{/* TODO: Login form */}</div>
      ) : (
        <div className="user-dashboard">
          {/* TODO: User profile v√† logout button */}
        </div>
      )}
    </div>
  );
}
```

### **Exercise 3: Quiz App v·ªõi Timer**

```jsx
// TODO: Implement quiz app v·ªõi useReducer

const QUIZ_ACTIONS = {
  START_QUIZ: "START_QUIZ",
  ANSWER_QUESTION: "ANSWER_QUESTION",
  NEXT_QUESTION: "NEXT_QUESTION",
  PREV_QUESTION: "PREV_QUESTION",
  SUBMIT_QUIZ: "SUBMIT_QUIZ",
  RESTART_QUIZ: "RESTART_QUIZ",
  TICK: "TICK", // Countdown timer
};

const quizQuestions = [
  {
    id: 1,
    question: "React ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi c√¥ng ty n√†o?",
    options: ["Google", "Facebook", "Microsoft", "Apple"],
    correctAnswer: 1,
  },
  {
    id: 2,
    question: "Hook n√†o d√πng ƒë·ªÉ qu·∫£n l√Ω state?",
    options: ["useEffect", "useState", "useContext", "useMemo"],
    correctAnswer: 1,
  },
  {
    id: 3,
    question: "JSX l√† vi·∫øt t·∫Øt c·ªßa g√¨?",
    options: [
      "JavaScript XML",
      "Java Syntax Extension",
      "JavaScript Extension",
      "JSON XML",
    ],
    correctAnswer: 0,
  },
  // Th√™m c√¢u h·ªèi kh√°c...
];

function quizReducer(state, action) {
  // TODO: Implement reducer
  // State structure:
  // {
  //   status: 'idle' | 'active' | 'finished',
  //   currentQuestionIndex: number,
  //   answers: { questionId: selectedOption },
  //   timeRemaining: number (seconds),
  //   score: number | null,
  //   startTime: timestamp,
  //   endTime: timestamp
  // }
  // Features:
  // - Start quiz (set timeRemaining = 300 = 5 ph√∫t)
  // - Answer question (l∆∞u v√†o answers object)
  // - Next/Previous question
  // - Submit quiz (t√≠nh score)
  // - Timer countdown (TICK action m·ªói gi√¢y)
  // - Auto submit khi h·∫øt gi·ªù
  // - Restart quiz
}

function QuizApp() {
  const [state, dispatch] = useReducer(quizReducer, {
    status: "idle",
    currentQuestionIndex: 0,
    answers: {},
    timeRemaining: 300, // 5 ph√∫t
    score: null,
    startTime: null,
    endTime: null,
  });

  // TODO: Setup timer v·ªõi useEffect
  // useEffect(() => {
  //   if (state.status === 'active' && state.timeRemaining > 0) {
  //     const timer = setInterval(() => {
  //       dispatch({ type: QUIZ_ACTIONS.TICK });
  //     }, 1000);
  //     return () => clearInterval(timer);
  //   } else if (state.timeRemaining === 0) {
  //     // Auto submit
  //   }
  // }, [state.status, state.timeRemaining]);

  const currentQuestion = quizQuestions[state.currentQuestionIndex];
  const progress =
    ((state.currentQuestionIndex + 1) / quizQuestions.length) * 100;

  // Format th·ªùi gian: mm:ss
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  };

  return (
    <div className="quiz-app">
      {state.status === "idle" && (
        <div className="quiz-start">
          <h1>Quiz React</h1>
          <p>T·ªïng s·ªë c√¢u h·ªèi: {quizQuestions.length}</p>
          <p>Th·ªùi gian: 5 ph√∫t</p>
          <button onClick={() => dispatch({ type: QUIZ_ACTIONS.START_QUIZ })}>
            B·∫Øt ƒë·∫ßu
          </button>
        </div>
      )}

      {state.status === "active" && (
        <div className="quiz-active">
          {/* Timer */}
          <div className="timer">
            Th·ªùi gian c√≤n l·∫°i: {formatTime(state.timeRemaining)}
          </div>

          {/* Progress */}
          <div className="progress">
            C√¢u {state.currentQuestionIndex + 1} / {quizQuestions.length}
            <div className="progress-bar" style={{ width: `${progress}%` }} />
          </div>

          {/* Question */}
          <div className="question">
            {/* TODO: Render question v√† options */}
          </div>

          {/* Navigation */}
          <div className="navigation">
            {/* TODO: Previous, Next, Submit buttons */}
          </div>
        </div>
      )}

      {state.status === "finished" && (
        <div className="quiz-results">
          {/* TODO: Hi·ªÉn th·ªã k·∫øt qu·∫£, review answers */}
        </div>
      )}
    </div>
  );
}
```

### **Exercise 4: Kanban Board**

```jsx
// TODO: Implement Kanban board v·ªõi drag & drop

const KANBAN_ACTIONS = {
  ADD_TASK: "ADD_TASK",
  MOVE_TASK: "MOVE_TASK",
  UPDATE_TASK: "UPDATE_TASK",
  DELETE_TASK: "DELETE_TASK",
  ADD_COLUMN: "ADD_COLUMN",
  DELETE_COLUMN: "DELETE_COLUMN",
};

function kanbanReducer(state, action) {
  // TODO: Implement reducer
  // State structure:
  // {
  //   columns: {
  //     'todo': {
  //       id: 'todo',
  //       title: 'C·∫ßn l√†m',
  //       taskIds: ['task-1', 'task-2']
  //     },
  //     'inProgress': { ... },
  //     'done': { ... }
  //   },
  //   tasks: {
  //     'task-1': {
  //       id: 'task-1',
  //       content: 'H·ªçc React',
  //       priority: 'high',
  //       assignee: 'John'
  //     }
  //   },
  //   columnOrder: ['todo', 'inProgress', 'done']
  // }
  // Features:
  // - Add task to column
  // - Move task between columns
  // - Update task details
  // - Delete task
  // - Add new column
  // - Delete column (move tasks to another column)
}

function KanbanBoard() {
  const [state, dispatch] = useReducer(kanbanReducer, {
    columns: {
      todo: { id: "todo", title: "C·∫ßn l√†m", taskIds: [] },
      inProgress: { id: "inProgress", title: "ƒêang l√†m", taskIds: [] },
      done: { id: "done", title: "Ho√†n th√†nh", taskIds: [] },
    },
    tasks: {},
    columnOrder: ["todo", "inProgress", "done"],
  });

  // TODO: Implement
  // - Drag & drop functionality
  // - Add task modal/form
  // - Task card v·ªõi edit/delete
  // - Column management
  // - Task filtering (by priority, assignee)
  // - Search tasks

  return (
    <div className="kanban-board">
      <h1>Kanban Board</h1>

      <div className="columns">
        {state.columnOrder.map((columnId) => {
          const column = state.columns[columnId];
          const tasks = column.taskIds.map((taskId) => state.tasks[taskId]);

          return (
            <div key={columnId} className="column">
              <h2>{column.title}</h2>
              <div className="tasks">
                {tasks.map((task) => (
                  <div key={task.id} className="task-card">
                    {/* TODO: Task card */}
                  </div>
                ))}
              </div>
              <button>+ Th√™m task</button>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

### **Exercise 5: Multi-Step Checkout (Challenge)**

```jsx
// TODO: Implement checkout flow v·ªõi validation

const CHECKOUT_ACTIONS = {
  SET_STEP: "SET_STEP",
  NEXT_STEP: "NEXT_STEP",
  PREV_STEP: "PREV_STEP",
  UPDATE_CART: "UPDATE_CART",
  UPDATE_SHIPPING: "UPDATE_SHIPPING",
  UPDATE_PAYMENT: "UPDATE_PAYMENT",
  APPLY_PROMO: "APPLY_PROMO",
  PLACE_ORDER: "PLACE_ORDER",
  SET_ERRORS: "SET_ERRORS",
};

const STEPS = {
  CART: 0,
  SHIPPING: 1,
  PAYMENT: 2,
  REVIEW: 3,
  CONFIRMATION: 4,
};

function checkoutReducer(state, action) {
  // TODO: Implement reducer
  // State structure:
  // {
  //   currentStep: number,
  //   cart: {
  //     items: [...],
  //     subtotal: number,
  //     shipping: number,
  //     tax: number,
  //     discount: number,
  //     total: number
  //   },
  //   shipping: {
  //     fullName: '',
  //     address: '',
  //     city: '',
  //     zipCode: '',
  //     phone: '',
  //     method: 'standard' | 'express'
  //   },
  //   payment: {
  //     method: 'card' | 'momo' | 'cod',
  //     cardNumber: '',
  //     cardName: '',
  //     expiryDate: '',
  //     cvv: ''
  //   },
  //   promoCode: { code: '', discount: 0 },
  //   errors: {},
  //   isProcessing: false,
  //   orderNumber: null
  // }
  // Features:
  // - Navigate between steps
  // - Validate each step before proceed
  // - Update cart (quantity, remove items)
  // - Calculate totals automatically
  // - Apply promo code
  // - Different payment methods
  // - Shipping methods (standard/express)
  // - Order confirmation
}

function CheckoutFlow() {
  const [state, dispatch] = useReducer(checkoutReducer, {
    currentStep: STEPS.CART,
    cart: {
      items: [
        { id: 1, name: "S·∫£n ph·∫©m 1", price: 100000, quantity: 2 },
        { id: 2, name: "S·∫£n ph·∫©m 2", price: 200000, quantity: 1 },
      ],
      subtotal: 0,
      shipping: 0,
      tax: 0,
      discount: 0,
      total: 0,
    },
    shipping: {
      fullName: "",
      address: "",
      city: "",
      zipCode: "",
      phone: "",
      method: "standard",
    },
    payment: {
      method: "card",
      cardNumber: "",
      cardName: "",
      expiryDate: "",
      cvv: "",
    },
    promoCode: { code: "", discount: 0 },
    errors: {},
    isProcessing: false,
    orderNumber: null,
  });

  const stepTitles = [
    "Gi·ªè h√†ng",
    "Th√¥ng tin giao h√†ng",
    "Thanh to√°n",
    "X√°c nh·∫≠n",
    "Ho√†n t·∫•t",
  ];

  // TODO: Validation functions
  const validateCart = () => {
    // Cart c√≥ items
  };

  const validateShipping = () => {
    // T·∫•t c·∫£ fields required
    // Phone format
    // Zip code format
  };

  const validatePayment = () => {
    // Card number format
    // Expiry date valid
    // CVV format
  };

  const handleNext = () => {
    // TODO: Validate current step tr∆∞·ªõc khi next
  };

  const handlePlaceOrder = async () => {
    // TODO: Submit order
  };

  return (
    <div className="checkout-flow">
      <h1>Thanh To√°n</h1>

      {/* Progress Steps */}
      <div className="steps">
        {stepTitles.map((title, index) => (
          <div
            key={index}
            className={`step ${index === state.currentStep ? "active" : ""} ${
              index < state.currentStep ? "completed" : ""
            }`}
          >
            <div className="step-number">{index + 1}</div>
            <div className="step-title">{title}</div>
          </div>
        ))}
      </div>

      {/* Step Content */}
      <div className="step-content">
        {state.currentStep === STEPS.CART && (
          <div className="cart-step">
            {/* TODO: Cart items v·ªõi quantity controls */}
          </div>
        )}

        {state.currentStep === STEPS.SHIPPING && (
          <div className="shipping-step">{/* TODO: Shipping form */}</div>
        )}

        {state.currentStep === STEPS.PAYMENT && (
          <div className="payment-step">
            {/* TODO: Payment methods v√† form */}
          </div>
        )}

        {state.currentStep === STEPS.REVIEW && (
          <div className="review-step">
            {/* TODO: Review t·∫•t c·∫£ th√¥ng tin */}
          </div>
        )}

        {state.currentStep === STEPS.CONFIRMATION && (
          <div className="confirmation-step">
            {/* TODO: Order confirmation */}
          </div>
        )}
      </div>

      {/* Navigation */}
      <div className="navigation">
        {state.currentStep > STEPS.CART &&
          state.currentStep < STEPS.CONFIRMATION && (
            <button
              onClick={() => dispatch({ type: CHECKOUT_ACTIONS.PREV_STEP })}
            >
              Quay l·∫°i
            </button>
          )}

        {state.currentStep < STEPS.REVIEW && (
          <button onClick={handleNext}>Ti·∫øp t·ª•c</button>
        )}

        {state.currentStep === STEPS.REVIEW && (
          <button onClick={handlePlaceOrder} disabled={state.isProcessing}>
            {state.isProcessing ? "ƒêang x·ª≠ l√Ω..." : "ƒê·∫∑t h√†ng"}
          </button>
        )}
      </div>

      {/* Order Summary Sidebar */}
      <div className="order-summary">
        {/* TODO: Summary hi·ªÉn th·ªã ·ªü t·∫•t c·∫£ steps */}
      </div>
    </div>
  );
}
```

---

## ‚úÖ PH·∫¶N 4: REVIEW & CHECKLIST (15-30 ph√∫t)

### **useReducer Basics:**

- [ ] Syntax: `const [state, dispatch] = useReducer(reducer, initialState)`
- [ ] Reducer l√† pure function: `(state, action) => newState`
- [ ] Action object c√≥ `type` v√† optional `payload`
- [ ] Dispatch g·ª≠i action ƒë·∫øn reducer

### **Reducer Rules:**

- [ ] Pure function (no side effects)
- [ ] Immutable updates
- [ ] Lu√¥n return state (default case)
- [ ] Kh√¥ng async operations
- [ ] Kh√¥ng mutate state

### **Action Patterns:**

- [ ] Action types constants
- [ ] Action creators cho reusability
- [ ] Payload structure consistent
- [ ] Descriptive action names

### **When to use useReducer:**

- [ ] Complex state logic
- [ ] Multiple sub-values
- [ ] State transitions related
- [ ] Next state depends on previous
- [ ] Need centralized logic

### **Best Practices:**

- [ ] Use constants cho action types
- [ ] Action creators cho consistency
- [ ] Split reducers cho large apps
- [ ] Lazy initialization n·∫øu c·∫ßn
- [ ] Testing reducer separately

### **Common Mistakes:**

```jsx
// ‚ùå Mutate state
function reducer(state, action) {
  state.count++; // NEVER!
  return state;
}

// ‚ùå Side effects trong reducer
function reducer(state, action) {
  console.log(action); // Side effect!
  localStorage.setItem("data", state); // Side effect!
  return state;
}

// ‚ùå Async trong reducer
function reducer(state, action) {
  fetch("/api/data"); // NEVER!
  return state;
}

// ‚ùå Kh√¥ng c√≥ default case
function reducer(state, action) {
  switch (action.type) {
    case "INCREMENT":
      return { count: state.count + 1 };
    // ‚ùå Missing default
  }
}

// ‚ùå Typo trong action type
dispatch({ type: "INCREMETN" }); // Typo! Kh√¥ng c√≥ g√¨ x·∫£y ra

// ‚úÖ ƒê√öNG
function reducer(state, action) {
  switch (action.type) {
    case ACTIONS.INCREMENT:
      return { ...state, count: state.count + 1 };
    default:
      return state;
  }
}

// Side effects trong useEffect, kh√¥ng ph·∫£i reducer
useEffect(() => {
  console.log("State changed:", state);
  localStorage.setItem("data", JSON.stringify(state));
}, [state]);
```

---

## üéØ HOMEWORK

### **1. Task Manager App**

Qu·∫£n l√Ω tasks v·ªõi categories, priorities, v√† deadlines:

```jsx
// Features:
// - Multiple task lists (Personal, Work, Shopping)
// - Priority levels (Low, Medium, High, Urgent)
// - Due dates v·ªõi reminders
// - Subtasks
// - Tags
// - Search v√† filters
// - Sort options
// - Archive completed tasks
// - Statistics dashboard
```

### **2. Expense Tracker v·ªõi Categories**

Tracking chi ti√™u chi ti·∫øt:

```jsx
// Features:
// - Multiple categories v√† subcategories
// - Recurring expenses
// - Budget limits per category
// - Monthly/yearly views
// - Charts v√† statistics
// - Export reports
// - Multi-currency support
// - Receipt attachments (optional)
```

### **3. Blog Post Editor**

Rich text editor v·ªõi preview:

```jsx
// Features:
// - Draft/Published status
// - Auto-save drafts
// - Version history
// - Tags v√† categories
// - Featured image
// - SEO metadata
// - Preview mode
// - Publish scheduling
// - Comment management
```

### **4. Music Player**

Audio player v·ªõi playlist:

```jsx
// Features:
// - Play/Pause/Stop/Next/Previous
// - Playlist management
// - Shuffle v√† repeat modes
// - Volume control
// - Progress bar v·ªõi seeking
// - Now playing info
// - Favorites
// - Search songs
// - Create custom playlists
```

### **5. Game: Tic Tac Toe v·ªõi AI (Challenge)**

```jsx
// Features:
// - 2 player mode
// - vs Computer (AI)
// - Move history v·ªõi time travel
// - Highlight winning line
// - Game statistics
// - Difficulty levels (Easy, Medium, Hard)
// - Undo move
// - Board size options (3x3, 4x4, 5x5)
```

---

## üìö ƒê·ªçc Th√™m

### **Official Docs:**

- [React - useReducer](https://react.dev/reference/react/useReducer)
- [React - Extracting State Logic into a Reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer)
- [React - Scaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context)

### **Advanced Topics:**

- [Redux Style Guide](https://redux.js.org/style-guide/) - Patterns √°p d·ª•ng ƒë∆∞·ª£c cho useReducer
- [Kent C. Dodds - Application State Management](https://kentcdodds.com/blog/application-state-management-with-react)
- [Robin Wieruch - useReducer vs useState](https://www.robinwieruch.de/react-usereducer-vs-usestate/)

---

## üìù Key Takeaways

1. **useReducer = useState for complex logic** - Centralize state updates
2. **Reducer = Pure Function** - Predictable v√† testable
3. **Actions describe WHAT happened** - Kh√¥ng ph·∫£i HOW to update
4. **Immutability is critical** - Lu√¥n return new state
5. **Constants prevent typos** - Action types n√™n l√† constants
6. **Action creators = Consistency** - Reusable action creation
7. **Testing is easier** - Test reducer ƒë·ªôc l·∫≠p v·ªõi component

---

## üí° Pro Tips

1. **DevTools**: React DevTools hi·ªÉn th·ªã actions v√† state changes
2. **Immer with useReducer**: `useImmerReducer` cho easier immutable updates
3. **TypeScript**: Type safety cho actions v√† state r·∫•t powerful
4. **Split Reducers**: Combine reducers cho large apps
5. **Logger Middleware**: Log actions ƒë·ªÉ debug (t·ª± implement ho·∫∑c d√πng library)

```jsx
// Debug logger
function loggerReducer(reducer) {
  return (state, action) => {
    console.group(action.type);
    console.log("Previous State:", state);
    console.log("Action:", action);
    const nextState = reducer(state, action);
    console.log("Next State:", nextState);
    console.groupEnd();
    return nextState;
  };
}

// Usage
const [state, dispatch] = useReducer(loggerReducer(todoReducer), initialState);
```

---

## üîç Debug Tips

### **1. State kh√¥ng update:**

```jsx
// Check: C√≥ return new state kh√¥ng?
case 'UPDATE':
  state.value = newValue; // ‚ùå Mutate
  return state; // Same reference!

// Fix:
case 'UPDATE':
  return { ...state, value: newValue }; // ‚úÖ New object
```

### **2. Action kh√¥ng trigger:**

```jsx
// Check: Typo trong action type?
dispatch({ type: "ADD_TOD" }); // Typo!

// Fix: D√πng constants
dispatch({ type: ACTIONS.ADD_TODO }); // ‚úÖ Type-safe
```

### **3. Infinite loop:**

```jsx
// Check: Dispatch trong reducer?
function reducer(state, action) {
  dispatch({ type: "OTHER" }); // ‚ùå NEVER!
  return state;
}

// Fix: Dispatch trong useEffect, kh√¥ng ph·∫£i reducer
```

---

## üéÆ Quick Quiz

Tr∆∞·ªõc khi qua ng√†y 8, test ki·∫øn th·ª©c:

1. useReducer nh·∫≠n bao nhi√™u tham s·ªë? Ch√∫ng l√† g√¨?
2. Reducer function nh·∫≠n g√¨ v√† return g√¨?
3. T·∫°i sao ph·∫£i d√πng immutable updates?
4. Khi n√†o d√πng useReducer thay v√¨ useState?
5. Side effects n√™n ƒë·∫∑t ·ªü ƒë√¢u?

**ƒê√°p √°n:**

1. 2 ho·∫∑c 3: (reducer, initialState, [init])
2. (currentState, action) => newState
3. React so s√°nh reference ƒë·ªÉ detect changes
4. Complex state, nhi·ªÅu transitions, centralized logic
5. useEffect, KH√îNG trong reducer

---

**üöÄ Ng√†y mai (Ng√†y 8):** State Management Patterns - Lifting State Up, Derived State, v√† State Batching! üí™
