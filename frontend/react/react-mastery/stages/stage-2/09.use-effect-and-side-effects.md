# üìÖ NG√ÄY 9: useEffect & Side Effects

## üéØ M·ª•c ti√™u h√¥m nay

- Hi·ªÉu s√¢u v·ªÅ useEffect v√† side effects
- Dependencies array v√† rules
- Cleanup functions
- Common patterns: data fetching, subscriptions, timers
- useLayoutEffect vs useEffect
- Avoiding infinite loops v√† race conditions
- Best practices

---

## üìö PH·∫¶N 1: L√ù THUY·∫æT (30-45 ph√∫t)

### **1.1. useEffect L√† G√¨?**

useEffect cho ph√©p th·ª±c hi·ªán side effects trong function components.

**Side effects l√† g√¨?**

- Data fetching
- Subscriptions
- Manually changing the DOM
- Timers (setTimeout, setInterval)
- Logging
- Browser APIs (localStorage, geolocation, etc.)

#### **Syntax c∆° b·∫£n**

```jsx
useEffect(() => {
  // Effect code here

  return () => {
    // Cleanup code (optional)
  };
}, [dependencies]); // Dependencies array
```

**Ba c√°ch d√πng useEffect:**

```jsx
// 1. Ch·∫°y sau M·ªåI render (kh√¥ng c√≥ deps)
useEffect(() => {
  console.log("Ch·∫°y sau m·ªói render");
});

// 2. Ch·∫°y ch·ªâ khi MOUNT (deps = [])
useEffect(() => {
  console.log("Ch·ªâ ch·∫°y 1 l·∫ßn khi mount");
}, []);

// 3. Ch·∫°y khi dependencies THAY ƒê·ªîI
useEffect(() => {
  console.log("Ch·∫°y khi count thay ƒë·ªïi");
}, [count]);
```

---

### **1.2. Dependencies Array**

Dependencies array quy·∫øt ƒë·ªãnh KHI N√ÄO effect ch·∫°y.

#### **Empty Array [] - Ch·ªâ ch·∫°y l·∫ßn ƒë·∫ßu**

```jsx
function Component() {
  useEffect(() => {
    console.log("Component mounted");

    return () => {
      console.log("Component unmounted");
    };
  }, []); // ‚úÖ Ch·ªâ ch·∫°y khi mount/unmount

  return <div>Hello</div>;
}
```

**Use cases cho []:**

- Setup subscriptions
- Fetch initial data
- Add event listeners
- Initialize libraries

#### **With Dependencies - Ch·∫°y khi deps thay ƒë·ªïi**

```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    console.log("Fetching results for:", query);

    fetch(`/api/search?q=${query}`)
      .then((res) => res.json())
      .then((data) => setResults(data));
  }, [query]); // ‚úÖ Ch·∫°y khi query thay ƒë·ªïi

  return <div>{/* render results */}</div>;
}
```

#### **‚ö†Ô∏è ESLint Rule: exhaustive-deps**

```jsx
function Component() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState("");

  // ‚ùå Missing dependency: count
  useEffect(() => {
    console.log("Count is:", count);
  }, []); // ESLint warning!

  // ‚úÖ Include all dependencies
  useEffect(() => {
    console.log("Count is:", count);
  }, [count]);

  // ‚ùå Missing dependency: name
  useEffect(() => {
    document.title = `${name}: ${count}`;
  }, [count]); // Missing 'name'

  // ‚úÖ All dependencies included
  useEffect(() => {
    document.title = `${name}: ${count}`;
  }, [count, name]);
}
```

**Quy t·∫Øc Dependencies:**

1. Bao g·ªìm T·∫§T C·∫¢ values t·ª´ component scope m√† effect s·ª≠ d·ª•ng
2. Props, state, functions, variables
3. KH√îNG bao g·ªìm: setState functions, refs
4. N·∫øu mu·ªën ignore warning, c√≥ l√Ω do r√µ r√†ng

---

### **1.3. Cleanup Functions**

Cleanup function ch·∫°y TR∆Ø·ªöC khi:

1. Effect ch·∫°y l·∫°i (khi dependencies thay ƒë·ªïi)
2. Component unmount

#### **Basic Cleanup**

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    console.log("Setup interval");

    const interval = setInterval(() => {
      setSeconds((s) => s + 1);
    }, 1000);

    // ‚úÖ Cleanup: Clear interval
    return () => {
      console.log("Cleanup interval");
      clearInterval(interval);
    };
  }, []); // Ch·∫°y 1 l·∫ßn

  return <div>Seconds: {seconds}</div>;
}
```

#### **Cleanup v·ªõi Dependencies**

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    console.log(`Connecting to room: ${roomId}`);
    const connection = chatAPI.connect(roomId);

    return () => {
      console.log(`Disconnecting from room: ${roomId}`);
      connection.disconnect();
    };
  }, [roomId]); // Cleanup v√† reconnect khi roomId thay ƒë·ªïi

  return <div>Chat Room: {roomId}</div>;
}

// Flow khi roomId thay ƒë·ªïi t·ª´ '1' ‚Üí '2':
// 1. Cleanup: Disconnect from room 1
// 2. Effect: Connect to room 2
```

#### **Common Cleanup Patterns**

```jsx
function Component() {
  useEffect(() => {
    // 1. Event Listeners
    const handleResize = () => console.log("Resized");
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  useEffect(() => {
    // 2. Subscriptions
    const subscription = observable.subscribe((data) => {
      console.log(data);
    });
    return () => subscription.unsubscribe();
  }, []);

  useEffect(() => {
    // 3. Timers
    const timer = setTimeout(() => console.log("Delayed"), 1000);
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    // 4. Abort Fetch Requests
    const controller = new AbortController();

    fetch("/api/data", { signal: controller.signal })
      .then((res) => res.json())
      .then((data) => console.log(data))
      .catch((err) => {
        if (err.name === "AbortError") {
          console.log("Fetch aborted");
        }
      });

    return () => controller.abort();
  }, []);

  return <div>Component</div>;
}
```

---

### **1.4. Data Fetching Patterns**

#### **Basic Fetch**

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    setError(null);

    fetch(`/api/users/${userId}`)
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch");
        return res.json();
      })
      .then((data) => {
        setUser(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);

  if (loading) return <div>ƒêang t·∫£i...</div>;
  if (error) return <div>L·ªói: {error}</div>;
  if (!user) return null;

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

#### **Race Condition Problem**

```jsx
// ‚ùå PROBLEM: Race condition
function SearchResults({ query }) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    fetch(`/api/search?q=${query}`)
      .then((res) => res.json())
      .then((data) => setResults(data));
  }, [query]);

  // V·∫•n ƒë·ªÅ:
  // 1. User type "react"
  // 2. Request 1 g·ª≠i ƒëi
  // 3. User type "redux"
  // 4. Request 2 g·ª≠i ƒëi
  // 5. Request 2 tr·∫£ v·ªÅ ‚Üí setResults (ƒë√∫ng)
  // 6. Request 1 tr·∫£ v·ªÅ ‚Üí setResults (sai! query ƒë√£ ƒë·ªïi)
}
```

#### **‚úÖ Solution 1: Ignore Flag**

```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    let ignore = false; // ‚úÖ Flag ƒë·ªÉ ignore stale responses

    fetch(`/api/search?q=${query}`)
      .then((res) => res.json())
      .then((data) => {
        if (!ignore) {
          // ‚úÖ Ch·ªâ update n·∫øu ch∆∞a cleanup
          setResults(data);
        }
      });

    return () => {
      ignore = true; // ‚úÖ Set flag trong cleanup
    };
  }, [query]);

  return <div>{/* render results */}</div>;
}
```

#### **‚úÖ Solution 2: AbortController**

```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    const controller = new AbortController();

    fetch(`/api/search?q=${query}`, {
      signal: controller.signal,
    })
      .then((res) => res.json())
      .then((data) => setResults(data))
      .catch((err) => {
        if (err.name === "AbortError") {
          console.log("Request aborted");
        }
      });

    return () => {
      controller.abort(); // ‚úÖ Cancel request
    };
  }, [query]);

  return <div>{/* render results */}</div>;
}
```

#### **Async/Await Pattern**

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let ignore = false;

    const fetchUser = async () => {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) throw new Error("Failed to fetch");

        const data = await response.json();

        if (!ignore) {
          setUser(data);
          setLoading(false);
        }
      } catch (err) {
        if (!ignore) {
          setError(err.message);
          setLoading(false);
        }
      }
    };

    fetchUser();

    return () => {
      ignore = true;
    };
  }, [userId]);

  // ... render
}
```

---

### **1.5. Common Patterns**

#### **1. Document Title**

```jsx
function PageTitle({ title }) {
  useEffect(() => {
    const previousTitle = document.title;
    document.title = title;

    return () => {
      document.title = previousTitle; // Restore
    };
  }, [title]);
}
```

#### **2. Local Storage Sync**

```jsx
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const saved = localStorage.getItem(key);
    return saved ? JSON.parse(saved) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

// Usage
function TodoApp() {
  const [todos, setTodos] = useLocalStorage("todos", []);
  // todos t·ª± ƒë·ªông sync v·ªõi localStorage
}
```

#### **3. Event Listeners**

```jsx
function MousePosition() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener("mousemove", handleMouseMove);

    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
    };
  }, []); // No dependencies - setup once

  return (
    <div>
      X: {position.x}, Y: {position.y}
    </div>
  );
}
```

#### **4. Debounced Effect**

```jsx
function SearchInput() {
  const [query, setQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");

  // Debounce input
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query);
    }, 500); // 500ms delay

    return () => clearTimeout(timer);
  }, [query]);

  // Fetch v·ªõi debounced query
  useEffect(() => {
    if (debouncedQuery) {
      fetch(`/api/search?q=${debouncedQuery}`)
        .then((res) => res.json())
        .then((data) => console.log(data));
    }
  }, [debouncedQuery]);

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="T√¨m ki·∫øm..."
    />
  );
}
```

#### **5. Interval v·ªõi Dynamic Value**

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  const [delay, setDelay] = useState(1000);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount((c) => c + 1); // ‚úÖ Functional update
    }, delay);

    return () => clearInterval(interval);
  }, [delay]); // ‚úÖ Re-setup khi delay thay ƒë·ªïi

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setDelay(500)}>Speed up</button>
      <button onClick={() => setDelay(1000)}>Normal</button>
    </div>
  );
}
```

#### **6. Focus Management**

```jsx
function AutoFocusInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current?.focus();
  }, []); // Focus khi mount

  return <input ref={inputRef} />;
}

// Focus khi condition thay ƒë·ªïi
function ConditionalFocus({ shouldFocus }) {
  const inputRef = useRef(null);

  useEffect(() => {
    if (shouldFocus) {
      inputRef.current?.focus();
    }
  }, [shouldFocus]);

  return <input ref={inputRef} />;
}
```

---

### **1.6. useLayoutEffect vs useEffect**

#### **useEffect (Async)**

- Ch·∫°y SAU khi browser paint
- Non-blocking
- D√πng cho h·∫ßu h·∫øt side effects

#### **useLayoutEffect (Sync)**

- Ch·∫°y TR∆Ø·ªöC khi browser paint
- Blocking (c√≥ th·ªÉ g√¢y lag)
- D√πng cho DOM measurements, animations

```jsx
// useEffect - Async (default)
function Component() {
  useEffect(() => {
    // 1. Component render
    // 2. Browser paint
    // 3. Effect ch·∫°y ‚Üê C√≥ th·ªÉ th·∫•y flicker
  }, []);
}

// useLayoutEffect - Sync
function Component() {
  useLayoutEffect(() => {
    // 1. Component render
    // 2. Effect ch·∫°y ‚Üê Tr∆∞·ªõc khi paint
    // 3. Browser paint
  }, []);
}
```

#### **Khi n√†o d√πng useLayoutEffect:**

```jsx
// ‚úÖ DOM measurements
function Tooltip() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const ref = useRef(null);

  useLayoutEffect(() => {
    const rect = ref.current.getBoundingClientRect();
    setPosition({ x: rect.x, y: rect.y });
  }, []);

  return <div ref={ref}>Tooltip</div>;
}

// ‚úÖ Animations c·∫ßn sync
function AnimatedComponent() {
  const [width, setWidth] = useState(0);

  useLayoutEffect(() => {
    // Measure v√† animate tr∆∞·ªõc khi paint
    const element = document.getElementById("animated");
    const newWidth = element.scrollWidth;
    setWidth(newWidth);
  }, []);

  return (
    <div id="animated" style={{ width }}>
      Content
    </div>
  );
}

// ‚ùå Kh√¥ng c·∫ßn useLayoutEffect cho data fetching
function DataComponent() {
  useLayoutEffect(() => {
    // ‚ùå Blocking!
    fetch("/api/data")
      .then((res) => res.json())
      .then((data) => console.log(data));
  }, []);
}

// ‚úÖ D√πng useEffect
function DataComponent() {
  useEffect(() => {
    // ‚úÖ Non-blocking
    fetch("/api/data")
      .then((res) => res.json())
      .then((data) => console.log(data));
  }, []);
}
```

**Rule of thumb:**

- M·∫∑c ƒë·ªãnh d√πng `useEffect`
- Ch·ªâ d√πng `useLayoutEffect` khi th·∫•y visual flicker
- N·∫øu kh√¥ng ch·∫Øc ‚Üí d√πng `useEffect`

---

### **1.7. Common Pitfalls**

#### **1. Infinite Loop**

```jsx
// ‚ùå Infinite loop - missing deps
function Component() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    setCount(count + 1); // Triggers re-render
  }); // No deps array ‚Üí ch·∫°y m·ªói render ‚Üí infinite loop!
}

// ‚ùå Infinite loop - wrong deps
function Component() {
  const [data, setData] = useState([]);

  useEffect(() => {
    fetch("/api/data")
      .then((res) => res.json())
      .then((result) => setData(result)); // Update state
  }, [data]); // data thay ƒë·ªïi ‚Üí effect ch·∫°y ‚Üí data thay ƒë·ªïi ‚Üí ...
}

// ‚úÖ Fixed
function Component() {
  const [data, setData] = useState([]);

  useEffect(() => {
    fetch("/api/data")
      .then((res) => res.json())
      .then((result) => setData(result));
  }, []); // Ch·ªâ fetch 1 l·∫ßn
}
```

#### **2. Stale Closure**

```jsx
// ‚ùå Stale closure
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      console.log(count); // Lu√¥n log 0!
      setCount(count + 1); // count lu√¥n l√† 0
    }, 1000);

    return () => clearInterval(interval);
  }, []); // count kh√¥ng trong deps

  return <div>Count: {count}</div>;
}

// ‚úÖ Solution 1: Functional update
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount((c) => c + 1); // ‚úÖ c lu√¥n l√† gi√° tr·ªã m·ªõi nh·∫•t
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return <div>Count: {count}</div>;
}

// ‚úÖ Solution 2: Include in deps (re-setup interval)
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      console.log(count); // ‚úÖ ƒê√∫ng count
      setCount(count + 1);
    }, 1000);

    return () => clearInterval(interval);
  }, [count]); // Re-setup m·ªói gi√¢y

  return <div>Count: {count}</div>;
}
```

#### **3. Missing Cleanup**

```jsx
// ‚ùå Memory leak
function Component() {
  useEffect(() => {
    const interval = setInterval(() => {
      console.log("Tick");
    }, 1000);
    // ‚ùå Missing cleanup!
  }, []);
}

// ‚úÖ With cleanup
function Component() {
  useEffect(() => {
    const interval = setInterval(() => {
      console.log("Tick");
    }, 1000);

    return () => clearInterval(interval); // ‚úÖ Cleanup
  }, []);
}
```

#### **4. Functions in Dependencies**

```jsx
// ‚ùå Function recreated m·ªói render
function Component({ userId }) {
  const fetchUser = () => {
    // New function m·ªói render
    fetch(`/api/users/${userId}`)
      .then((res) => res.json())
      .then((data) => console.log(data));
  };

  useEffect(() => {
    fetchUser();
  }, [fetchUser]); // fetchUser thay ƒë·ªïi m·ªói render ‚Üí effect ch·∫°y m·ªói render
}

// ‚úÖ Solution 1: Move function inside effect
function Component({ userId }) {
  useEffect(() => {
    const fetchUser = () => {
      fetch(`/api/users/${userId}`)
        .then((res) => res.json())
        .then((data) => console.log(data));
    };

    fetchUser();
  }, [userId]); // ‚úÖ Ch·ªâ userId trong deps
}

// ‚úÖ Solution 2: useCallback
function Component({ userId }) {
  const fetchUser = useCallback(() => {
    fetch(`/api/users/${userId}`)
      .then((res) => res.json())
      .then((data) => console.log(data));
  }, [userId]); // ‚úÖ Memoized

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);
}
```

---

## üíª PH·∫¶N 2: CODE DEMO (30-45 ph√∫t)

### **Demo 1: Real-time Search**

```jsx
function SearchApp() {
  const [query, setQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Debounce input
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query);
    }, 500);

    return () => clearTimeout(timer);
  }, [query]);

  // Fetch results
  useEffect(() => {
    if (!debouncedQuery) {
      setResults([]);
      return;
    }

    let ignore = false;
    setLoading(true);
    setError(null);

    fetch(`https://api.github.com/search/repositories?q=${debouncedQuery}`)
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch");
        return res.json();
      })
      .then((data) => {
        if (!ignore) {
          setResults(data.items || []);
          setLoading(false);
        }
      })
      .catch((err) => {
        if (!ignore) {
          setError(err.message);
          setLoading(false);
        }
      });

    return () => {
      ignore = true;
    };
  }, [debouncedQuery]);

  return (
    <div className="search-app">
      <h1>GitHub Repository Search</h1>

      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="T√¨m ki·∫øm repository..."
      />

      {loading && <div>ƒêang t√¨m ki·∫øm...</div>}
      {error && <div className="error">L·ªói: {error}</div>}

      <div className="results">
        {results.map((repo) => (
          <div key={repo.id} className="repo-card">
            <h3>{repo.name}</h3>
            <p>{repo.description}</p>
            <p>
              ‚≠ê {repo.stargazers_count} | üç¥ {repo.forks_count}
            </p>
            <a href={repo.html_url} target="_blank" rel="noopener noreferrer">
              Xem tr√™n GitHub
            </a>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### **Demo 2: Real-time Chat**

```jsx
function ChatRoom({ roomId, userId }) {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [onlineUsers, setOnlineUsers] = useState([]);
  const messagesEndRef = useRef(null);

  // Connect to chat room
  useEffect(() => {
    console.log(`Connecting to room ${roomId}...`);

    // Simulate WebSocket connection
    const ws = {
      send: (msg) => console.log("Send:", msg),
      close: () => console.log("Close connection"),
    };

    // Simulate receiving messages
    const messageInterval = setInterval(() => {
      const newMessage = {
        id: Date.now(),
        userId: Math.random() > 0.5 ? userId : "other",
        text: `Message ${Date.now()}`,
        timestamp: new Date().toISOString(),
      };
      setMessages((prev) => [...prev, newMessage]);
    }, 5000);

    // Cleanup
    return () => {
      console.log(`Disconnecting from room ${roomId}...`);
      clearInterval(messageInterval);
      ws.close();
    };
  }, [roomId, userId]);

  // Auto scroll to bottom
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  // Track online users
  useEffect(() => {
    // Simulate tracking
    setOnlineUsers([userId, "user2", "user3"]);

    const interval = setInterval(() => {
      // Simulate users joining/leaving
      setOnlineUsers((prev) => {
        const random = Math.random();
        if (random > 0.7 && prev.length < 5) {
          return [...prev, `user${Date.now()}`];
        } else if (random < 0.3 && prev.length > 1) {
          return prev.slice(0, -1);
        }
        return prev;
      });
    }, 10000);

    return () => clearInterval(interval);
  }, [userId]);

  const sendMessage = () => {
    if (!inputValue.trim()) return;

    const newMessage = {
      id: Date.now(),
      userId,
      text: inputValue,
      timestamp: new Date().toISOString(),
    };

    setMessages((prev) => [...prev, newMessage]);
    setInputValue("");
  };

  return (
    <div className="chat-room">
      <div className="chat-header">
        <h2>Room: {roomId}</h2>
        <div className="online-users">
          Online: {onlineUsers.length}
          <span className="user-list">
            {onlineUsers.map((id) => (
              <span key={id} className="user-badge">
                {id}
              </span>
            ))}
          </span>
        </div>
      </div>

      <div className="messages">
        {messages.map((msg) => (
          <div
            key={msg.id}
            className={`message ${msg.userId === userId ? "own" : "other"}`}
          >
            <strong>{msg.userId}:</strong> {msg.text}
            <small>{new Date(msg.timestamp).toLocaleTimeString()}</small>
          </div>
        ))}
        <div ref={messagesEndRef} />
      </div>

      <div className="input-area">
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={(e) => e.key === "Enter" && sendMessage()}
          placeholder="Nh·∫≠p tin nh·∫Øn..."
        />
        <button onClick={sendMessage}>G·ª≠i</button>
      </div>
    </div>
  );
}

function ChatApp() {
  const [rooms] = useState([
    { id: "general", name: "General" },
    { id: "tech", name: "Tech Talk" },
    { id: "random", name: "Random" },
  ]);
  const [currentRoom, setCurrentRoom] = useState("general");

  return (
    <div className="chat-app">
      <div className="sidebar">
        <h2>Rooms</h2>
        {rooms.map((room) => (
          <button
            key={room.id}
            onClick={() => setCurrentRoom(room.id)}
            className={currentRoom === room.id ? "active" : ""}
          >
            {room.name}
          </button>
        ))}
      </div>

      <ChatRoom
        key={currentRoom} // Re-mount khi ƒë·ªïi room
        roomId={currentRoom}
        userId="user1"
      />
    </div>
  );
}
```

---

## üî® PH·∫¶N 3: TH·ª∞C H√ÄNH (60-90 ph√∫t)

### **Exercise 1: Weather Dashboard**

```jsx
// TODO: Implement weather dashboard v·ªõi auto-refresh

function WeatherDashboard() {
  // TODO: State
  // - city (user input)
  // - weather data
  // - loading, error
  // - lastUpdated timestamp
  // - autoRefresh (boolean)
  // - refreshInterval (30s, 1m, 5m)

  // TODO: Effects
  // 1. Fetch weather khi city thay ƒë·ªïi
  // 2. Auto-refresh n·∫øu autoRefresh = true
  // 3. Update lastUpdated
  // 4. Cleanup intervals

  // TODO: Features
  // - Search by city
  // - Display: temp, humidity, wind speed, condition
  // - Auto-refresh toggle
  // - Refresh interval selector
  // - Manual refresh button
  // - Last updated time
  // - Error handling
  // - Loading state

  return <div className="weather-dashboard">{/* Your code */}</div>;
}
```

### **Exercise 2: Infinite Scroll List**

```jsx
// TODO: Implement infinite scroll

function InfiniteScrollList() {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const observerTarget = useRef(null);

  // TODO: Effect ƒë·ªÉ fetch data
  useEffect(() => {
    // Fetch items for current page
    // Append to existing items
    // Set hasMore based on response
  }, [page]);

  // TODO: Intersection Observer cho infinite scroll
  useEffect(() => {
    // Setup IntersectionObserver
    // Khi user scroll ƒë·∫øn bottom ‚Üí load more (setPage)
    // Cleanup observer
  }, [loading, hasMore]);

  // TODO: Features
  // - Load 20 items per page
  // - Show loading spinner khi fetch
  // - "No more items" message khi h·∫øt
  // - Smooth scrolling
  // - Error handling

  return (
    <div className="infinite-scroll-list">
      {items.map((item, index) => (
        <div key={item.id} className="item">
          {/* Render item */}
        </div>
      ))}

      {loading && <div className="loading">ƒêang t·∫£i...</div>}

      {!hasMore && <div className="end-message">H·∫øt r·ªìi!</div>}

      {/* Observer target */}
      <div ref={observerTarget} />
    </div>
  );
}
```

### **Exercise 3: Live Stock Ticker**

```jsx
// TODO: Implement real-time stock price updates

function StockTicker() {
  // TODO: State
  // - stocks: array of { symbol, price, change }
  // - selectedStock: currently viewing
  // - priceHistory: array of historical prices
  // - isConnected: WebSocket status

  // TODO: Effects
  // 1. Connect to WebSocket (simulated)
  // 2. Subscribe to selected stocks
  // 3. Update prices in real-time
  // 4. Track price history
  // 5. Cleanup on unmount

  const [stocks, setStocks] = useState([
    { symbol: "AAPL", name: "Apple", price: 150.0, change: 0 },
    { symbol: "GOOGL", name: "Google", price: 2800.0, change: 0 },
    { symbol: "MSFT", name: "Microsoft", price: 300.0, change: 0 },
    { symbol: "TSLA", name: "Tesla", price: 700.0, change: 0 },
  ]);

  const [selectedStock, setSelectedStock] = useState("AAPL");
  const [priceHistory, setPriceHistory] = useState([]);

  // TODO: Simulate WebSocket updates
  useEffect(() => {
    // Update prices every 2 seconds
    // Random price changes (-5% to +5%)
    // Update stocks state
    // Track history for selected stock
  }, [selectedStock]);

  // TODO: Features
  // - Real-time price updates
  // - Price change indicators (‚Üë green, ‚Üì red)
  // - Price history chart (last 20 updates)
  // - Connection status indicator
  // - Add/remove stocks
  // - Alerts for price thresholds

  return (
    <div className="stock-ticker">
      <h1>Live Stock Ticker</h1>

      <div className="stock-list">
        {stocks.map((stock) => (
          <div
            key={stock.symbol}
            className={`stock-item ${
              selectedStock === stock.symbol ? "selected" : ""
            }`}
            onClick={() => setSelectedStock(stock.symbol)}
          >
            <h3>{stock.symbol}</h3>
            <p className="price">${stock.price.toFixed(2)}</p>
            <p
              className={`change ${
                stock.change >= 0 ? "positive" : "negative"
              }`}
            >
              {stock.change >= 0 ? "‚Üë" : "‚Üì"}{" "}
              {Math.abs(stock.change).toFixed(2)}%
            </p>
          </div>
        ))}
      </div>

      <div className="price-chart">
        <h2>L·ªãch s·ª≠ gi√°: {selectedStock}</h2>
        {/* TODO: Render price history */}
      </div>
    </div>
  );
}
```

### **Exercise 4: Form Auto-Save**

```jsx
// TODO: Implement auto-save form

function AutoSaveForm() {
  const [formData, setFormData] = useState({
    title: "",
    content: "",
    tags: [],
    category: "",
  });

  const [saveStatus, setSaveStatus] = useState("saved"); // 'saved' | 'saving' | 'unsaved'
  const [lastSaved, setLastSaved] = useState(null);
  const [savingError, setSavingError] = useState(null);

  // TODO: Effects
  // 1. Load draft from localStorage on mount
  // 2. Debounced auto-save (2 seconds after user stops typing)
  // 3. Save to localStorage
  // 4. Show save status
  // 5. Handle save errors

  // Load draft on mount
  useEffect(() => {
    const saved = localStorage.getItem("draft");
    if (saved) {
      setFormData(JSON.parse(saved));
      setLastSaved(new Date(localStorage.getItem("draft-timestamp")));
    }
  }, []);

  // Debounced auto-save
  useEffect(() => {
    // Set status to 'unsaved' immediately when data changes
    setSaveStatus("unsaved");

    // Debounce save
    const timer = setTimeout(() => {
      // TODO: Save to localStorage
      // Set status to 'saving'
      // Simulate API call
      // Set status to 'saved'
      // Update lastSaved
    }, 2000);

    return () => clearTimeout(timer);
  }, [formData]);

  // Warn before leaving with unsaved changes
  useEffect(() => {
    const handleBeforeUnload = (e) => {
      if (saveStatus === "unsaved" || saveStatus === "saving") {
        e.preventDefault();
        e.returnValue = "";
      }
    };

    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => window.removeEventListener("beforeunload", handleBeforeUnload);
  }, [saveStatus]);

  const updateField = (field, value) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    // TODO: Final submit
    // Clear draft from localStorage
  };

  return (
    <form onSubmit={handleSubmit} className="auto-save-form">
      <h1>T·∫°o b√†i vi·∫øt</h1>

      <div className="save-status">
        {saveStatus === "saved" && (
          <span className="status-saved">
            ‚úì ƒê√£ l∆∞u {lastSaved && `l√∫c ${lastSaved.toLocaleTimeString()}`}
          </span>
        )}
        {saveStatus === "saving" && (
          <span className="status-saving">üíæ ƒêang l∆∞u...</span>
        )}
        {saveStatus === "unsaved" && (
          <span className="status-unsaved">‚óè Ch∆∞a l∆∞u</span>
        )}
        {savingError && (
          <span className="status-error">‚ùå L·ªói: {savingError}</span>
        )}
      </div>

      <div>
        <label>Ti√™u ƒë·ªÅ:</label>
        <input
          value={formData.title}
          onChange={(e) => updateField("title", e.target.value)}
        />
      </div>

      <div>
        <label>N·ªôi dung:</label>
        <textarea
          value={formData.content}
          onChange={(e) => updateField("content", e.target.value)}
          rows={10}
        />
      </div>

      <div>
        <label>Category:</label>
        <select
          value={formData.category}
          onChange={(e) => updateField("category", e.target.value)}
        >
          <option value="">Ch·ªçn category</option>
          <option value="tech">Tech</option>
          <option value="lifestyle">Lifestyle</option>
          <option value="travel">Travel</option>
        </select>
      </div>

      <button type="submit">Xu·∫•t b·∫£n</button>
    </form>
  );
}
```

### **Exercise 5: Multi-Tab Sync (Challenge)**

```jsx
// TODO: Sync state across browser tabs

function MultiTabSyncApp() {
  const [count, setCount] = useState(0);
  const [messages, setMessages] = useState([]);
  const [activeUsers, setActiveUsers] = useState(1);
  const [tabId] = useState(() => `tab-${Date.now()}`);

  // TODO: Effects
  // 1. Broadcast state changes to other tabs (BroadcastChannel API)
  // 2. Listen for changes from other tabs
  // 3. Sync count across tabs
  // 4. Track active tabs
  // 5. Remove tab on unmount

  // Broadcast changes
  useEffect(() => {
    // Create BroadcastChannel
    const channel = new BroadcastChannel("app-sync");

    // Listen for messages from other tabs
    channel.onmessage = (event) => {
      const { type, payload, senderId } = event.data;

      if (senderId === tabId) return; // Ignore own messages

      switch (type) {
        case "COUNT_UPDATE":
          setCount(payload);
          break;
        case "MESSAGE_ADD":
          setMessages((prev) => [...prev, payload]);
          break;
        case "TAB_OPENED":
          setActiveUsers((prev) => prev + 1);
          // Send current state to new tab
          channel.postMessage({
            type: "STATE_SYNC",
            payload: { count, messages },
            senderId: tabId,
          });
          break;
        case "TAB_CLOSED":
          setActiveUsers((prev) => Math.max(1, prev - 1));
          break;
        case "STATE_SYNC":
          if (messages.length === 0) {
            setCount(payload.count);
            setMessages(payload.messages);
          }
          break;
        default:
          break;
      }
    };

    // Announce tab opened
    channel.postMessage({
      type: "TAB_OPENED",
      senderId: tabId,
    });

    // Cleanup
    return () => {
      channel.postMessage({
        type: "TAB_CLOSED",
        senderId: tabId,
      });
      channel.close();
    };
  }, [tabId, count, messages]);

  // Broadcast count changes
  useEffect(() => {
    if (count === 0) return; // Skip initial value

    const channel = new BroadcastChannel("app-sync");
    channel.postMessage({
      type: "COUNT_UPDATE",
      payload: count,
      senderId: tabId,
    });
    channel.close();
  }, [count, tabId]);

  const addMessage = (text) => {
    const message = {
      id: Date.now(),
      text,
      timestamp: new Date().toISOString(),
      tabId,
    };

    setMessages((prev) => [...prev, message]);

    // Broadcast to other tabs
    const channel = new BroadcastChannel("app-sync");
    channel.postMessage({
      type: "MESSAGE_ADD",
      payload: message,
      senderId: tabId,
    });
    channel.close();
  };

  // TODO: Features
  // - Shared counter across tabs
  // - Shared message list
  // - Show active tab count
  // - Highlight messages from current tab
  // - Sync immediately when tab opens
  // - Handle tab close gracefully

  return (
    <div className="multi-tab-sync">
      <h1>Multi-Tab Sync Demo</h1>

      <div className="stats">
        <p>Tab ID: {tabId}</p>
        <p>Active Tabs: {activeUsers}</p>
      </div>

      <div className="counter">
        <h2>Shared Counter: {count}</h2>
        <button onClick={() => setCount(count + 1)}>+1</button>
        <button onClick={() => setCount(count - 1)}>-1</button>
        <button onClick={() => setCount(0)}>Reset</button>
      </div>

      <div className="messages">
        <h2>Shared Messages</h2>
        <div className="message-list">
          {messages.map((msg) => (
            <div
              key={msg.id}
              className={`message ${msg.tabId === tabId ? "own" : "other"}`}
            >
              <strong>{msg.tabId === tabId ? "B·∫°n" : msg.tabId}:</strong>{" "}
              {msg.text}
              <small>{new Date(msg.timestamp).toLocaleTimeString()}</small>
            </div>
          ))}
        </div>
        <div className="message-input">
          <input
            type="text"
            placeholder="Nh·∫≠p tin nh·∫Øn..."
            onKeyPress={(e) => {
              if (e.key === "Enter" && e.target.value.trim()) {
                addMessage(e.target.value);
                e.target.value = "";
              }
            }}
          />
        </div>
      </div>

      <div className="instructions">
        <p>üí° M·ªü nhi·ªÅu tab ƒë·ªÉ xem ƒë·ªìng b·ªô!</p>
      </div>
    </div>
  );
}
```

---

## ‚úÖ PH·∫¶N 4: REVIEW & CHECKLIST (15-30 ph√∫t)

### **useEffect Basics:**

- [ ] Syntax: `useEffect(effect, [deps])`
- [ ] Ch·∫°y sau render (async)
- [ ] Return cleanup function (optional)
- [ ] Dependencies array control khi n√†o ch·∫°y

### **Dependencies Array:**

- [ ] No array: ch·∫°y m·ªói render
- [ ] Empty []: ch·ªâ mount/unmount
- [ ] [deps]: ch·∫°y khi deps thay ƒë·ªïi
- [ ] Include ALL values used trong effect
- [ ] ESLint exhaustive-deps rule

### **Cleanup Functions:**

- [ ] Ch·∫°y tr∆∞·ªõc effect ti·∫øp theo
- [ ] Ch·∫°y khi unmount
- [ ] Clear timers, subscriptions, listeners
- [ ] Cancel requests
- [ ] Prevent memory leaks

### **Common Patterns:**

- [ ] Data fetching v·ªõi race condition handling
- [ ] Debounced effects
- [ ] Event listeners
- [ ] LocalStorage sync
- [ ] Timers v√† intervals
- [ ] Focus management

### **useLayoutEffect:**

- [ ] Ch·∫°y sync, tr∆∞·ªõc browser paint
- [ ] D√πng cho DOM measurements
- [ ] Blocking - c·∫©n th·∫≠n performance
- [ ] Default d√πng useEffect

### **Common Mistakes:**

```jsx
// ‚ùå Infinite loop - no deps
useEffect(() => {
  setState(newValue);
}); // Ch·∫°y m·ªói render!

// ‚ùå Missing deps
useEffect(() => {
  console.log(count); // count not in deps
}, []);

// ‚ùå Missing cleanup
useEffect(() => {
  const interval = setInterval(() => {}, 1000);
  // Missing: return () => clearInterval(interval);
}, []);

// ‚ùå Stale closure
useEffect(() => {
  setTimeout(() => {
    console.log(count); // Stale value
  }, 1000);
}, []); // count not in deps

// ‚ùå Race condition
useEffect(() => {
  fetch("/api/data")
    .then((res) => res.json())
    .then((data) => setState(data)); // Might be stale!
}, [query]);

// ‚úÖ ƒê√öNG
useEffect(() => {
  setState(newValue);
}, [deps]); // With dependencies

useEffect(() => {
  console.log(count);
}, [count]); // Include count

useEffect(() => {
  const interval = setInterval(() => {}, 1000);
  return () => clearInterval(interval); // ‚úÖ Cleanup
}, []);

useEffect(() => {
  setTimeout(() => {
    setCount((c) => c + 1); // Functional update
  }, 1000);
}, []); // ‚úÖ Functional update

useEffect(() => {
  let ignore = false; // ‚úÖ Race condition handling

  fetch("/api/data")
    .then((res) => res.json())
    .then((data) => {
      if (!ignore) setState(data);
    });

  return () => {
    ignore = true;
  };
}, [query]);
```

---

## üéØ HOMEWORK

### **1. News Feed v·ªõi Auto-Refresh**

```jsx
// Features:
// - Fetch news articles
// - Auto-refresh every 60s
// - Pull-to-refresh
// - Mark as read (localStorage)
// - Filter by category
// - Search articles
// - Pagination
```

### **2. Pomodoro Timer**

```jsx
// Features:
// - 25min work / 5min break
// - Audio notification
// - Pause/resume
// - Skip break
// - Session history
// - Statistics (daily, weekly)
// - Auto-start next session
```

### **3. Live Notification Center**

```jsx
// Features:
// - Real-time notifications (simulated)
// - Mark as read
// - Delete notification
// - Filter by type
// - Sound on new notification
// - Browser notification API
// - Persist unread count
```

### **4. Collaborative Whiteboard**

```jsx
// Features:
// - Draw on canvas
// - Sync drawing across tabs (BroadcastChannel)
// - Multiple colors and brush sizes
// - Undo/redo
// - Clear canvas
// - Save/load drawings
// - Show active users
```

### **5. Advanced Data Table (Challenge)**

```jsx
// Features:
// - Server-side pagination
// - Sorting (multi-column)
// - Filtering (multiple filters)
// - Search with debounce
// - Column visibility toggle
// - Export to CSV
// - Infinite scroll mode
// - Virtual scrolling for large datasets
// - Row selection
// - Bulk actions
```

---

## üìö ƒê·ªçc Th√™m

### **Official Docs:**

- [React - useEffect](https://react.dev/reference/react/useEffect)
- [React - Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects)
- [React - You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)
- [React - Lifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)
- [React - Separating Events from Effects](https://react.dev/learn/separating-events-from-effects)

### **Must Read:**

- [Dan Abramov - A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)
- [Kent C. Dodds - useEffect vs useLayoutEffect](https://kentcdodds.com/blog/useeffect-vs-uselayouteffect)

---

## üìù Key Takeaways

1. **useEffect = Side Effects** - Anything outside React's control
2. **Dependencies Matter** - Include ALL used values
3. **Cleanup is Critical** - Prevent memory leaks
4. **Race Conditions** - Always handle async properly
5. **Stale Closures** - Use functional updates
6. **Don't Over-use** - Not everything needs useEffect
7. **useLayoutEffect** - Only for DOM measurements

---

## üí° Pro Tips

1. **Think in effects**: "What should happen AFTER render?"
2. **Cleanup mindset**: Every setup needs cleanup
3. **Functional updates**: Avoid stale closures
4. **Ignore flag pattern**: Handle race conditions
5. **DevTools**: React DevTools shows effect calls
6. **Extract logic**: Custom hooks cho reusability

---

## üîç Debug Tips

### **Effect ch·∫°y qu√° nhi·ªÅu l·∫ßn:**

```jsx
// Log ƒë·ªÉ debug
useEffect(() => {
  console.log("Effect ran");
  console.log("Dependencies:", { dep1, dep2 });
}, [dep1, dep2]);
```

### **Memory leak:**

```jsx
// Check DevTools Console cho warnings
// Warning: Can't perform a React state update on an unmounted component
// ‚Üí Missing cleanup!
```

### **Stale closure:**

```jsx
// Th√™m console.log ƒë·ªÉ check values
useEffect(() => {
  console.log("Count in effect:", count);
  // N·∫øu count kh√¥ng update ‚Üí stale closure
}, []);
```

---

## üéÆ Quick Quiz

1. useEffect ch·∫°y khi n√†o trong lifecycle?
2. Cleanup function ch·∫°y khi n√†o?
3. T·∫°i sao c·∫ßn dependencies array?
4. Race condition l√† g√¨? Gi·∫£i quy·∫øt th·∫ø n√†o?
5. Khi n√†o d√πng useLayoutEffect?

**ƒê√°p √°n:**

1. Sau khi render xong v√† browser paint
2. Tr∆∞·ªõc effect ti·∫øp theo v√† khi unmount
3. ƒê·ªÉ React bi·∫øt khi n√†o c·∫ßn ch·∫°y l·∫°i effect
4. Multiple async operations, response v·ªÅ kh√¥ng ƒë√∫ng th·ª© t·ª±. Fix: ignore flag ho·∫∑c AbortController
5. Khi c·∫ßn ƒëo DOM ho·∫∑c sync updates tr∆∞·ªõc paint

---

**üöÄ Ng√†y mai (Ng√†y 10):** Advanced Effects - useLayoutEffect, useInsertionEffect, v√† Effect Best Practices! üí™
